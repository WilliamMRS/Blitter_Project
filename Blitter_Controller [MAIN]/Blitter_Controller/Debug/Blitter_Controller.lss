
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000236  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001c2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800100  00800100  00000236  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000236  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000268  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000040  00000000  00000000  000002a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000a64  00000000  00000000  000002e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000088e  00000000  00000000  00000d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000324  00000000  00000000  000015da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000ac  00000000  00000000  00001900  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000491  00000000  00000000  000019ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000127  00000000  00000000  00001e3d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  00001f64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 84 00 	jmp	0x108	; 0x108 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a2 30       	cpi	r26, 0x02	; 2
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 db 00 	call	0x1b6	; 0x1b6 <main>
  7c:	0c 94 df 00 	jmp	0x1be	; 0x1be <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <transmitUART>:
	// Check and print results of various components on the blitter board:
}

int transmitUART (char data){
	short timeoutLimit = 1000;
	short timeout = 0;
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
  88:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
  8c:	95 ff       	sbrs	r25, 5
  8e:	05 c0       	rjmp	.+10     	; 0x9a <transmitUART+0x16>
			UARTBuffer = data;
  90:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	08 95       	ret
		}else{
			timeout++;
  9a:	2f 5f       	subi	r18, 0xFF	; 255
  9c:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
  9e:	29 3e       	cpi	r18, 0xE9	; 233
  a0:	93 e0       	ldi	r25, 0x03	; 3
  a2:	39 07       	cpc	r19, r25
  a4:	8c f3       	brlt	.-30     	; 0x88 <transmitUART+0x4>
				return 0;
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
  aa:	08 95       	ret

000000ac <systemCheck>:
    }
}

// Type S for system check:
void systemCheck(){
	transmitUART(CR);
  ac:	8d e0       	ldi	r24, 0x0D	; 13
  ae:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(S);
  b2:	83 e5       	ldi	r24, 0x53	; 83
  b4:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(y);
  b8:	89 e7       	ldi	r24, 0x79	; 121
  ba:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(s);
  be:	83 e7       	ldi	r24, 0x73	; 115
  c0:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(t);
  c4:	84 e7       	ldi	r24, 0x74	; 116
  c6:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(e);
  ca:	85 e6       	ldi	r24, 0x65	; 101
  cc:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(m);
  d0:	8d e6       	ldi	r24, 0x6D	; 109
  d2:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(_space);
  d6:	80 e2       	ldi	r24, 0x20	; 32
  d8:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(c);
  dc:	83 e6       	ldi	r24, 0x63	; 99
  de:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(h);
  e2:	88 e6       	ldi	r24, 0x68	; 104
  e4:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(e);
  e8:	85 e6       	ldi	r24, 0x65	; 101
  ea:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(c);
  ee:	83 e6       	ldi	r24, 0x63	; 99
  f0:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(k);
  f4:	8b e6       	ldi	r24, 0x6B	; 107
  f6:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(_colon);
  fa:	8a e3       	ldi	r24, 0x3A	; 58
  fc:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	transmitUART(CR);
 100:	8d e0       	ldi	r24, 0x0D	; 13
 102:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
 106:	08 95       	ret

00000108 <__vector_13>:
			}
		}
	}
}

ISR(USART0_RX_vect){
 108:	1f 92       	push	r1
 10a:	0f 92       	push	r0
 10c:	0f b6       	in	r0, 0x3f	; 63
 10e:	0f 92       	push	r0
 110:	11 24       	eor	r1, r1
 112:	2f 93       	push	r18
 114:	3f 93       	push	r19
 116:	4f 93       	push	r20
 118:	5f 93       	push	r21
 11a:	6f 93       	push	r22
 11c:	7f 93       	push	r23
 11e:	8f 93       	push	r24
 120:	9f 93       	push	r25
 122:	af 93       	push	r26
 124:	bf 93       	push	r27
 126:	ef 93       	push	r30
 128:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	receivedByte = UARTBuffer; // local temporary variable for received byte
 12a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
 12e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <receivedByte>
	if (receivedByte){
 132:	88 23       	and	r24, r24
 134:	61 f0       	breq	.+24     	; 0x14e <__vector_13+0x46>
		if (receivedByte == 45) { // that's the '-' sign.
 136:	8d 32       	cpi	r24, 0x2D	; 45
 138:	31 f4       	brne	.+12     	; 0x146 <__vector_13+0x3e>
			remoteEcho = ~remoteEcho;
 13a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 13e:	80 95       	com	r24
 140:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 144:	04 c0       	rjmp	.+8      	; 0x14e <__vector_13+0x46>
		}else if(receivedByte == S){
 146:	83 35       	cpi	r24, 0x53	; 83
 148:	11 f4       	brne	.+4      	; 0x14e <__vector_13+0x46>
			systemCheck();
 14a:	0e 94 56 00 	call	0xac	; 0xac <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 14e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 152:	88 23       	and	r24, r24
 154:	89 f0       	breq	.+34     	; 0x178 <__vector_13+0x70>
 156:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <receivedByte>
 15a:	80 32       	cpi	r24, 0x20	; 32
 15c:	40 f4       	brcc	.+16     	; 0x16e <__vector_13+0x66>
 15e:	87 30       	cpi	r24, 0x07	; 7
 160:	31 f0       	breq	.+12     	; 0x16e <__vector_13+0x66>
 162:	8d 30       	cpi	r24, 0x0D	; 13
 164:	21 f0       	breq	.+8      	; 0x16e <__vector_13+0x66>
 166:	8a 30       	cpi	r24, 0x0A	; 10
 168:	11 f0       	breq	.+4      	; 0x16e <__vector_13+0x66>
 16a:	88 30       	cpi	r24, 0x08	; 8
 16c:	29 f4       	brne	.+10     	; 0x178 <__vector_13+0x70>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 16e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 172:	95 fd       	sbrc	r25, 5
			UARTBuffer = receivedByte;
 174:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
}
 178:	ff 91       	pop	r31
 17a:	ef 91       	pop	r30
 17c:	bf 91       	pop	r27
 17e:	af 91       	pop	r26
 180:	9f 91       	pop	r25
 182:	8f 91       	pop	r24
 184:	7f 91       	pop	r23
 186:	6f 91       	pop	r22
 188:	5f 91       	pop	r21
 18a:	4f 91       	pop	r20
 18c:	3f 91       	pop	r19
 18e:	2f 91       	pop	r18
 190:	0f 90       	pop	r0
 192:	0f be       	out	0x3f, r0	; 63
 194:	0f 90       	pop	r0
 196:	1f 90       	pop	r1
 198:	18 95       	reti

0000019a <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 19a:	8f e2       	ldi	r24, 0x2F	; 47
 19c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 1a0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 1a4:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 1a8:	88 e9       	ldi	r24, 0x98	; 152
 1aa:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 1ae:	86 e0       	ldi	r24, 0x06	; 6
 1b0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 1b4:	08 95       	ret

000001b6 <main>:
char receivedByte;
uint8_t remoteEcho = 0;

int main(void)
{	
    initUART(); // initialize the UART
 1b6:	0e 94 cd 00 	call	0x19a	; 0x19a <initUART>
	sei(); //Enable global interrupt
 1ba:	78 94       	sei
 1bc:	ff cf       	rjmp	.-2      	; 0x1bc <main+0x6>

000001be <_exit>:
 1be:	f8 94       	cli

000001c0 <__stop_program>:
 1c0:	ff cf       	rjmp	.-2      	; 0x1c0 <__stop_program>
