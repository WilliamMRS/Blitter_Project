
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000003ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000037a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000003ee  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003ee  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000420  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  00000460  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000114e  00000000  00000000  00000568  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ad8  00000000  00000000  000016b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007f7  00000000  00000000  0000218e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001f0  00000000  00000000  00002988  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005ec  00000000  00000000  00002b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000365  00000000  00000000  00003164  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b8  00000000  00000000  000034c9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a1 30       	cpi	r26, 0x01	; 1
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <main>
  7c:	0c 94 bb 01 	jmp	0x376	; 0x376 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	PORTB |= (1 << WR);// WR HIGH
}

void rdSignal(void){
	PORTE &= ~(1 << RD); // RD LOW
	PORTE |= (1 << RD); // RD HIGH
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	9e b1       	in	r25, 0x0e	; 14
  a8:	90 68       	ori	r25, 0x80	; 128
  aa:	9e b9       	out	0x0e, r25	; 14
  ac:	82 b9       	out	0x02, r24	; 2
  ae:	68 b9       	out	0x08, r22	; 8
  b0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  b4:	08 95       	ret

000000b6 <initHY32D>:
  b6:	84 b1       	in	r24, 0x04	; 4
  b8:	80 64       	ori	r24, 0x40	; 64
  ba:	84 b9       	out	0x04, r24	; 4
  bc:	84 b1       	in	r24, 0x04	; 4
  be:	80 62       	ori	r24, 0x20	; 32
  c0:	84 b9       	out	0x04, r24	; 4
  c2:	84 b1       	in	r24, 0x04	; 4
  c4:	80 61       	ori	r24, 0x10	; 16
  c6:	84 b9       	out	0x04, r24	; 4
  c8:	8d b1       	in	r24, 0x0d	; 13
  ca:	80 64       	ori	r24, 0x40	; 64
  cc:	8d b9       	out	0x0d, r24	; 13
  ce:	8d b1       	in	r24, 0x0d	; 13
  d0:	80 68       	ori	r24, 0x80	; 128
  d2:	8d b9       	out	0x0d, r24	; 13
  d4:	85 b1       	in	r24, 0x05	; 5
  d6:	80 64       	ori	r24, 0x40	; 64
  d8:	85 b9       	out	0x05, r24	; 5
  da:	85 b1       	in	r24, 0x05	; 5
  dc:	80 62       	ori	r24, 0x20	; 32
  de:	85 b9       	out	0x05, r24	; 5
  e0:	85 b1       	in	r24, 0x05	; 5
  e2:	80 61       	ori	r24, 0x10	; 16
  e4:	85 b9       	out	0x05, r24	; 5
  e6:	8e b1       	in	r24, 0x0e	; 14
  e8:	80 64       	ori	r24, 0x40	; 64
  ea:	8e b9       	out	0x0e, r24	; 14
  ec:	8e b1       	in	r24, 0x0e	; 14
  ee:	80 68       	ori	r24, 0x80	; 128
  f0:	8e b9       	out	0x0e, r24	; 14
  f2:	8f ef       	ldi	r24, 0xFF	; 255
  f4:	81 b9       	out	0x01, r24	; 1
  f6:	87 b9       	out	0x07, r24	; 7
  f8:	87 e0       	ldi	r24, 0x07	; 7
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 100:	60 e0       	ldi	r22, 0x00	; 0
 102:	81 e2       	ldi	r24, 0x21	; 33
 104:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 110:	60 e0       	ldi	r22, 0x00	; 0
 112:	81 e0       	ldi	r24, 0x01	; 1
 114:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 118:	87 e0       	ldi	r24, 0x07	; 7
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	60 e0       	ldi	r22, 0x00	; 0
 122:	83 e3       	ldi	r24, 0x33	; 51
 124:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 128:	81 e1       	ldi	r24, 0x11	; 17
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 130:	68 e6       	ldi	r22, 0x68	; 104
 132:	80 e3       	ldi	r24, 0x30	; 48
 134:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 138:	82 e0       	ldi	r24, 0x02	; 2
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 140:	60 e0       	ldi	r22, 0x00	; 0
 142:	80 e0       	ldi	r24, 0x00	; 0
 144:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 148:	08 95       	ret

0000014a <setIOtoOutput>:
}

void setIOtoOutput(void){
	DDRA = 0xFF;
 14a:	8f ef       	ldi	r24, 0xFF	; 255
 14c:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
 14e:	87 b9       	out	0x07, r24	; 7
 150:	08 95       	ret

00000152 <setIOtoInput>:
}
void setIOtoInput(void){
	DDRA = 0x00;
 152:	11 b8       	out	0x01, r1	; 1
	DDRC = 0x00;
 154:	17 b8       	out	0x07, r1	; 7
 156:	08 95       	ret

00000158 <readDataLines>:
	transmitUART((char)data);
	return data;
}
	
// debugging function
void serialOutBinary(unsigned short number){
 158:	cf 93       	push	r28
 15a:	df 93       	push	r29
 15c:	0e 94 a9 00 	call	0x152	; 0x152 <setIOtoInput>
 160:	8e b1       	in	r24, 0x0e	; 14
 162:	8f 7b       	andi	r24, 0xBF	; 191
 164:	8e b9       	out	0x0e, r24	; 14
 166:	86 b1       	in	r24, 0x06	; 6
 168:	80 b1       	in	r24, 0x00	; 0
 16a:	c6 b1       	in	r28, 0x06	; 6
 16c:	d0 e0       	ldi	r29, 0x00	; 0
 16e:	dc 2f       	mov	r29, r28
 170:	cc 27       	eor	r28, r28
 172:	80 b1       	in	r24, 0x00	; 0
 174:	c8 2b       	or	r28, r24
 176:	8e b1       	in	r24, 0x0e	; 14
 178:	80 64       	ori	r24, 0x40	; 64
 17a:	8e b9       	out	0x0e, r24	; 14
 17c:	0e 94 a5 00 	call	0x14a	; 0x14a <setIOtoOutput>
 180:	ce 01       	movw	r24, r28
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	08 95       	ret

00000188 <statusRead>:
 188:	cf 93       	push	r28
 18a:	84 b1       	in	r24, 0x04	; 4
 18c:	8f 7b       	andi	r24, 0xBF	; 191
 18e:	84 b9       	out	0x04, r24	; 4
 190:	8e b1       	in	r24, 0x0e	; 14
 192:	8f 77       	andi	r24, 0x7F	; 127
 194:	8e b9       	out	0x0e, r24	; 14
 196:	0e 94 ac 00 	call	0x158	; 0x158 <readDataLines>
 19a:	c9 2f       	mov	r28, r25
 19c:	0e 94 3b 01 	call	0x276	; 0x276 <intToAscii>
 1a0:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
 1a4:	8c 2f       	mov	r24, r28
 1a6:	0e 94 3b 01 	call	0x276	; 0x276 <intToAscii>
 1aa:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
 1ae:	8d e0       	ldi	r24, 0x0D	; 13
 1b0:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
 1b4:	84 b1       	in	r24, 0x04	; 4
 1b6:	80 64       	ori	r24, 0x40	; 64
 1b8:	84 b9       	out	0x04, r24	; 4
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	cf 91       	pop	r28
 1c0:	08 95       	ret

000001c2 <main>:
}
	
int main(void)
{	
    initUART(); // initialize the UART
 1c2:	0e 94 3d 01 	call	0x27a	; 0x27a <initUART>
	initHY32D();
 1c6:	0e 94 5b 00 	call	0xb6	; 0xb6 <initHY32D>
	startupMessage();
 1ca:	0e 94 8d 01 	call	0x31a	; 0x31a <startupMessage>
	sei(); //Enable global interrupt
 1ce:	78 94       	sei
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1d0:	2f ef       	ldi	r18, 0xFF	; 255
 1d2:	8f e7       	ldi	r24, 0x7F	; 127
 1d4:	96 e1       	ldi	r25, 0x16	; 22
 1d6:	21 50       	subi	r18, 0x01	; 1
 1d8:	80 40       	sbci	r24, 0x00	; 0
 1da:	90 40       	sbci	r25, 0x00	; 0
 1dc:	e1 f7       	brne	.-8      	; 0x1d6 <main+0x14>
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <main+0x1e>
 1e0:	00 00       	nop
	
    while (1) 
    {
		_delay_ms(1000);
		statusRead();
 1e2:	0e 94 c4 00 	call	0x188	; 0x188 <statusRead>
 1e6:	f4 cf       	rjmp	.-24     	; 0x1d0 <main+0xe>

000001e8 <__vector_13>:
		Få kontakt med flashminnet
		Tegn fra flashminnet til skjermen*/
    }
}

ISR(USART0_RX_vect){
 1e8:	1f 92       	push	r1
 1ea:	0f 92       	push	r0
 1ec:	0f b6       	in	r0, 0x3f	; 63
 1ee:	0f 92       	push	r0
 1f0:	11 24       	eor	r1, r1
 1f2:	2f 93       	push	r18
 1f4:	3f 93       	push	r19
 1f6:	4f 93       	push	r20
 1f8:	5f 93       	push	r21
 1fa:	6f 93       	push	r22
 1fc:	7f 93       	push	r23
 1fe:	8f 93       	push	r24
 200:	9f 93       	push	r25
 202:	af 93       	push	r26
 204:	bf 93       	push	r27
 206:	cf 93       	push	r28
 208:	ef 93       	push	r30
 20a:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	unsigned char receivedByte = UARTBuffer; // local temporary variable for received byte
 20c:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 210:	cc 23       	and	r28, r28
 212:	61 f0       	breq	.+24     	; 0x22c <__EEPROM_REGION_LENGTH__+0x2c>
		if (receivedByte == 45) { // that's the '-' sign.
 214:	cd 32       	cpi	r28, 0x2D	; 45
 216:	31 f4       	brne	.+12     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
			remoteEcho = ~remoteEcho;
 218:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 21c:	80 95       	com	r24
 21e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 222:	04 c0       	rjmp	.+8      	; 0x22c <__EEPROM_REGION_LENGTH__+0x2c>
		}else if(receivedByte == S){
 224:	c3 35       	cpi	r28, 0x53	; 83
 226:	11 f4       	brne	.+4      	; 0x22c <__EEPROM_REGION_LENGTH__+0x2c>
			systemCheck();
 228:	0e 94 5f 01 	call	0x2be	; 0x2be <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 22c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 230:	88 23       	and	r24, r24
 232:	79 f0       	breq	.+30     	; 0x252 <__EEPROM_REGION_LENGTH__+0x52>
 234:	c0 32       	cpi	r28, 0x20	; 32
 236:	40 f4       	brcc	.+16     	; 0x248 <__EEPROM_REGION_LENGTH__+0x48>
 238:	c7 30       	cpi	r28, 0x07	; 7
 23a:	31 f0       	breq	.+12     	; 0x248 <__EEPROM_REGION_LENGTH__+0x48>
 23c:	cd 30       	cpi	r28, 0x0D	; 13
 23e:	21 f0       	breq	.+8      	; 0x248 <__EEPROM_REGION_LENGTH__+0x48>
 240:	ca 30       	cpi	r28, 0x0A	; 10
 242:	11 f0       	breq	.+4      	; 0x248 <__EEPROM_REGION_LENGTH__+0x48>
 244:	c8 30       	cpi	r28, 0x08	; 8
 246:	29 f4       	brne	.+10     	; 0x252 <__EEPROM_REGION_LENGTH__+0x52>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 248:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 24c:	85 fd       	sbrc	r24, 5
			UARTBuffer = receivedByte;
 24e:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
 252:	ff 91       	pop	r31
 254:	ef 91       	pop	r30
 256:	cf 91       	pop	r28
 258:	bf 91       	pop	r27
 25a:	af 91       	pop	r26
 25c:	9f 91       	pop	r25
 25e:	8f 91       	pop	r24
 260:	7f 91       	pop	r23
 262:	6f 91       	pop	r22
 264:	5f 91       	pop	r21
 266:	4f 91       	pop	r20
 268:	3f 91       	pop	r19
 26a:	2f 91       	pop	r18
 26c:	0f 90       	pop	r0
 26e:	0f be       	out	0x3f, r0	; 63
 270:	0f 90       	pop	r0
 272:	1f 90       	pop	r1
 274:	18 95       	reti

00000276 <intToAscii>:
 *  Author: William M. R. Schmidt
 */ 

char intToAscii(char number) {
	return '0' + number;
 276:	80 5d       	subi	r24, 0xD0	; 208
 278:	08 95       	ret

0000027a <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 27a:	8f e2       	ldi	r24, 0x2F	; 47
 27c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 280:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 284:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 288:	88 e9       	ldi	r24, 0x98	; 152
 28a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 28e:	86 e0       	ldi	r24, 0x06	; 6
 290:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 294:	08 95       	ret

00000296 <transmitUART>:
}

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 296:	20 e0       	ldi	r18, 0x00	; 0
 298:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 29a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 29e:	95 ff       	sbrs	r25, 5
 2a0:	05 c0       	rjmp	.+10     	; 0x2ac <transmitUART+0x16>
			UARTBuffer = data;
 2a2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	08 95       	ret
			}else{
			timeout++;
 2ac:	2f 5f       	subi	r18, 0xFF	; 255
 2ae:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 2b0:	29 3e       	cpi	r18, 0xE9	; 233
 2b2:	93 e0       	ldi	r25, 0x03	; 3
 2b4:	39 07       	cpc	r19, r25
 2b6:	8c f3       	brlt	.-30     	; 0x29a <transmitUART+0x4>
				return 0;
 2b8:	80 e0       	ldi	r24, 0x00	; 0
 2ba:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 2bc:	08 95       	ret

000002be <systemCheck>:
#include "ASCII.h"
#include "UART.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 2be:	8d e0       	ldi	r24, 0x0D	; 13
 2c0:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(S);
 2c4:	83 e5       	ldi	r24, 0x53	; 83
 2c6:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(y);
 2ca:	89 e7       	ldi	r24, 0x79	; 121
 2cc:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(s);
 2d0:	83 e7       	ldi	r24, 0x73	; 115
 2d2:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(t);
 2d6:	84 e7       	ldi	r24, 0x74	; 116
 2d8:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(e);
 2dc:	85 e6       	ldi	r24, 0x65	; 101
 2de:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(m);
 2e2:	8d e6       	ldi	r24, 0x6D	; 109
 2e4:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(_space);
 2e8:	80 e2       	ldi	r24, 0x20	; 32
 2ea:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(c);
 2ee:	83 e6       	ldi	r24, 0x63	; 99
 2f0:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(h);
 2f4:	88 e6       	ldi	r24, 0x68	; 104
 2f6:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(e);
 2fa:	85 e6       	ldi	r24, 0x65	; 101
 2fc:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(c);
 300:	83 e6       	ldi	r24, 0x63	; 99
 302:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(k);
 306:	8b e6       	ldi	r24, 0x6B	; 107
 308:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(_colon);
 30c:	8a e3       	ldi	r24, 0x3A	; 58
 30e:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(CR);
 312:	8d e0       	ldi	r24, 0x0D	; 13
 314:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
 318:	08 95       	ret

0000031a <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART(CR);
 31a:	8d e0       	ldi	r24, 0x0D	; 13
 31c:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(B);
 320:	82 e4       	ldi	r24, 0x42	; 66
 322:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(l);
 326:	8c e6       	ldi	r24, 0x6C	; 108
 328:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(i);
 32c:	89 e6       	ldi	r24, 0x69	; 105
 32e:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(t);
 332:	84 e7       	ldi	r24, 0x74	; 116
 334:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(t);
 338:	84 e7       	ldi	r24, 0x74	; 116
 33a:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(e);
 33e:	85 e6       	ldi	r24, 0x65	; 101
 340:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(r);
 344:	82 e7       	ldi	r24, 0x72	; 114
 346:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(_space);
 34a:	80 e2       	ldi	r24, 0x20	; 32
 34c:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(r);
 350:	82 e7       	ldi	r24, 0x72	; 114
 352:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(e);
 356:	85 e6       	ldi	r24, 0x65	; 101
 358:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(a);
 35c:	81 e6       	ldi	r24, 0x61	; 97
 35e:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(d);
 362:	84 e6       	ldi	r24, 0x64	; 100
 364:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(y);
 368:	89 e7       	ldi	r24, 0x79	; 121
 36a:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
	transmitUART(CR);
 36e:	8d e0       	ldi	r24, 0x0D	; 13
 370:	0e 94 4b 01 	call	0x296	; 0x296 <transmitUART>
 374:	08 95       	ret

00000376 <_exit>:
 376:	f8 94       	cli

00000378 <__stop_program>:
 378:	ff cf       	rjmp	.-2      	; 0x378 <__stop_program>
