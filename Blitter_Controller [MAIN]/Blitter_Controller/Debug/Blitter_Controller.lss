
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000758  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006e4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  00000758  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000758  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000788  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000128  00000000  00000000  000007c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000019cf  00000000  00000000  000008f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b75  00000000  00000000  000022bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b7f  00000000  00000000  00002e34  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000270  00000000  00000000  000039b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000652  00000000  00000000  00003c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008b9  00000000  00000000  00004276  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00004b2f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 69 02 	jmp	0x4d2	; 0x4d2 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 5f 02 	call	0x4be	; 0x4be <main>
  7c:	0c 94 70 03 	jmp	0x6e0	; 0x6e0 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DC_HIGH;
	WR_HIGH;
	data = readDataLines();
	transmitUART((char)data);
	return data;
}
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <setIOtoOutput>:
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	81 b9       	out	0x01, r24	; 1
  e8:	87 b9       	out	0x07, r24	; 7
  ea:	08 95       	ret

000000ec <setIOtoInput>:
  ec:	11 b8       	out	0x01, r1	; 1
  ee:	17 b8       	out	0x07, r1	; 7
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	8f e3       	ldi	r24, 0x3F	; 63
  f4:	92 e0       	ldi	r25, 0x02	; 2
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <setIOtoInput+0xa>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <setIOtoInput+0x14>
 100:	00 00       	nop
 102:	08 95       	ret

00000104 <fillScreen>:
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ef 92       	push	r14
 10a:	ff 92       	push	r15
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	ec 01       	movw	r28, r24
 112:	85 b1       	in	r24, 0x05	; 5
 114:	8f 7b       	andi	r24, 0xBF	; 191
 116:	85 b9       	out	0x05, r24	; 5
 118:	82 e2       	ldi	r24, 0x22	; 34
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	c1 2c       	mov	r12, r1
 122:	d1 2c       	mov	r13, r1
 124:	76 01       	movw	r14, r12
 126:	08 c0       	rjmp	.+16     	; 0x138 <fillScreen+0x34>
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 12e:	8f ef       	ldi	r24, 0xFF	; 255
 130:	c8 1a       	sub	r12, r24
 132:	d8 0a       	sbc	r13, r24
 134:	e8 0a       	sbc	r14, r24
 136:	f8 0a       	sbc	r15, r24
 138:	c1 14       	cp	r12, r1
 13a:	8c e2       	ldi	r24, 0x2C	; 44
 13c:	d8 06       	cpc	r13, r24
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	e8 06       	cpc	r14, r24
 142:	f1 04       	cpc	r15, r1
 144:	88 f3       	brcs	.-30     	; 0x128 <fillScreen+0x24>
 146:	85 b1       	in	r24, 0x05	; 5
 148:	80 64       	ori	r24, 0x40	; 64
 14a:	85 b9       	out	0x05, r24	; 5
 14c:	df 91       	pop	r29
 14e:	cf 91       	pop	r28
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

0000015a <colorTest>:
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	85 b1       	in	r24, 0x05	; 5
 160:	8f 7b       	andi	r24, 0xBF	; 191
 162:	85 b9       	out	0x05, r24	; 5
 164:	82 e2       	ldi	r24, 0x22	; 34
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 16c:	c0 e0       	ldi	r28, 0x00	; 0
 16e:	d0 e0       	ldi	r29, 0x00	; 0
 170:	05 c0       	rjmp	.+10     	; 0x17c <colorTest+0x22>
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	9f ef       	ldi	r25, 0xFF	; 255
 176:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 17a:	21 96       	adiw	r28, 0x01	; 1
 17c:	c1 15       	cp	r28, r1
 17e:	8e e1       	ldi	r24, 0x1E	; 30
 180:	d8 07       	cpc	r29, r24
 182:	bc f3       	brlt	.-18     	; 0x172 <colorTest+0x18>
 184:	c0 e0       	ldi	r28, 0x00	; 0
 186:	d0 e0       	ldi	r29, 0x00	; 0
 188:	05 c0       	rjmp	.+10     	; 0x194 <colorTest+0x3a>
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 192:	21 96       	adiw	r28, 0x01	; 1
 194:	c1 15       	cp	r28, r1
 196:	8e e1       	ldi	r24, 0x1E	; 30
 198:	d8 07       	cpc	r29, r24
 19a:	bc f3       	brlt	.-18     	; 0x18a <colorTest+0x30>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <colorTest+0x52>
 1a2:	8e ed       	ldi	r24, 0xDE	; 222
 1a4:	97 ef       	ldi	r25, 0xF7	; 247
 1a6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1aa:	21 96       	adiw	r28, 0x01	; 1
 1ac:	c1 15       	cp	r28, r1
 1ae:	8e e1       	ldi	r24, 0x1E	; 30
 1b0:	d8 07       	cpc	r29, r24
 1b2:	bc f3       	brlt	.-18     	; 0x1a2 <colorTest+0x48>
 1b4:	c0 e0       	ldi	r28, 0x00	; 0
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <colorTest+0x6a>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	98 ef       	ldi	r25, 0xF8	; 248
 1be:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1c2:	21 96       	adiw	r28, 0x01	; 1
 1c4:	c1 15       	cp	r28, r1
 1c6:	8e e1       	ldi	r24, 0x1E	; 30
 1c8:	d8 07       	cpc	r29, r24
 1ca:	bc f3       	brlt	.-18     	; 0x1ba <colorTest+0x60>
 1cc:	c0 e0       	ldi	r28, 0x00	; 0
 1ce:	d0 e0       	ldi	r29, 0x00	; 0
 1d0:	05 c0       	rjmp	.+10     	; 0x1dc <colorTest+0x82>
 1d2:	87 ee       	ldi	r24, 0xE7	; 231
 1d4:	9c ef       	ldi	r25, 0xFC	; 252
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	c1 15       	cp	r28, r1
 1de:	8e e1       	ldi	r24, 0x1E	; 30
 1e0:	d8 07       	cpc	r29, r24
 1e2:	bc f3       	brlt	.-18     	; 0x1d2 <colorTest+0x78>
 1e4:	c0 e0       	ldi	r28, 0x00	; 0
 1e6:	d0 e0       	ldi	r29, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <colorTest+0x9a>
 1ea:	8f e1       	ldi	r24, 0x1F	; 31
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1f2:	21 96       	adiw	r28, 0x01	; 1
 1f4:	c1 15       	cp	r28, r1
 1f6:	8e e1       	ldi	r24, 0x1E	; 30
 1f8:	d8 07       	cpc	r29, r24
 1fa:	bc f3       	brlt	.-18     	; 0x1ea <colorTest+0x90>
 1fc:	c0 e0       	ldi	r28, 0x00	; 0
 1fe:	d0 e0       	ldi	r29, 0x00	; 0
 200:	05 c0       	rjmp	.+10     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
 202:	8f e1       	ldi	r24, 0x1F	; 31
 204:	98 ef       	ldi	r25, 0xF8	; 248
 206:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	c1 15       	cp	r28, r1
 20e:	8e e1       	ldi	r24, 0x1E	; 30
 210:	d8 07       	cpc	r29, r24
 212:	bc f3       	brlt	.-18     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
 214:	c0 e0       	ldi	r28, 0x00	; 0
 216:	d0 e0       	ldi	r29, 0x00	; 0
 218:	05 c0       	rjmp	.+10     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	97 e0       	ldi	r25, 0x07	; 7
 21e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 222:	21 96       	adiw	r28, 0x01	; 1
 224:	c1 15       	cp	r28, r1
 226:	8e e1       	ldi	r24, 0x1E	; 30
 228:	d8 07       	cpc	r29, r24
 22a:	bc f3       	brlt	.-18     	; 0x21a <__EEPROM_REGION_LENGTH__+0x1a>
 22c:	c0 e0       	ldi	r28, 0x00	; 0
 22e:	d0 e0       	ldi	r29, 0x00	; 0
 230:	05 c0       	rjmp	.+10     	; 0x23c <__EEPROM_REGION_LENGTH__+0x3c>
 232:	80 ee       	ldi	r24, 0xE0	; 224
 234:	9f ef       	ldi	r25, 0xFF	; 255
 236:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 23a:	21 96       	adiw	r28, 0x01	; 1
 23c:	c1 15       	cp	r28, r1
 23e:	8e e1       	ldi	r24, 0x1E	; 30
 240:	d8 07       	cpc	r29, r24
 242:	bc f3       	brlt	.-18     	; 0x232 <__EEPROM_REGION_LENGTH__+0x32>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 24a:	8f e1       	ldi	r24, 0x1F	; 31
 24c:	95 e0       	ldi	r25, 0x05	; 5
 24e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 252:	21 96       	adiw	r28, 0x01	; 1
 254:	c1 15       	cp	r28, r1
 256:	8e e1       	ldi	r24, 0x1E	; 30
 258:	d8 07       	cpc	r29, r24
 25a:	bc f3       	brlt	.-18     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 25c:	85 b1       	in	r24, 0x05	; 5
 25e:	80 64       	ori	r24, 0x40	; 64
 260:	85 b9       	out	0x05, r24	; 5
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <initHY32D>:
 268:	84 b1       	in	r24, 0x04	; 4
 26a:	80 64       	ori	r24, 0x40	; 64
 26c:	84 b9       	out	0x04, r24	; 4
 26e:	84 b1       	in	r24, 0x04	; 4
 270:	80 62       	ori	r24, 0x20	; 32
 272:	84 b9       	out	0x04, r24	; 4
 274:	84 b1       	in	r24, 0x04	; 4
 276:	80 61       	ori	r24, 0x10	; 16
 278:	84 b9       	out	0x04, r24	; 4
 27a:	8d b1       	in	r24, 0x0d	; 13
 27c:	80 64       	ori	r24, 0x40	; 64
 27e:	8d b9       	out	0x0d, r24	; 13
 280:	8d b1       	in	r24, 0x0d	; 13
 282:	80 68       	ori	r24, 0x80	; 128
 284:	8d b9       	out	0x0d, r24	; 13
 286:	85 b1       	in	r24, 0x05	; 5
 288:	80 64       	ori	r24, 0x40	; 64
 28a:	85 b9       	out	0x05, r24	; 5
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	80 61       	ori	r24, 0x10	; 16
 290:	85 b9       	out	0x05, r24	; 5
 292:	8e b1       	in	r24, 0x0e	; 14
 294:	80 64       	ori	r24, 0x40	; 64
 296:	8e b9       	out	0x0e, r24	; 14
 298:	8e b1       	in	r24, 0x0e	; 14
 29a:	80 68       	ori	r24, 0x80	; 128
 29c:	8e b9       	out	0x0e, r24	; 14
 29e:	8f ef       	ldi	r24, 0xFF	; 255
 2a0:	81 b9       	out	0x01, r24	; 1
 2a2:	87 b9       	out	0x07, r24	; 7
 2a4:	2f ef       	ldi	r18, 0xFF	; 255
 2a6:	8f e3       	ldi	r24, 0x3F	; 63
 2a8:	92 e0       	ldi	r25, 0x02	; 2
 2aa:	21 50       	subi	r18, 0x01	; 1
 2ac:	80 40       	sbci	r24, 0x00	; 0
 2ae:	90 40       	sbci	r25, 0x00	; 0
 2b0:	e1 f7       	brne	.-8      	; 0x2aa <initHY32D+0x42>
 2b2:	00 c0       	rjmp	.+0      	; 0x2b4 <initHY32D+0x4c>
 2b4:	00 00       	nop
 2b6:	85 b1       	in	r24, 0x05	; 5
 2b8:	81 60       	ori	r24, 0x01	; 1
 2ba:	85 b9       	out	0x05, r24	; 5
 2bc:	8f ef       	ldi	r24, 0xFF	; 255
 2be:	93 e2       	ldi	r25, 0x23	; 35
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <initHY32D+0x58>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <initHY32D+0x5e>
 2c6:	00 00       	nop
 2c8:	85 b1       	in	r24, 0x05	; 5
 2ca:	8e 7f       	andi	r24, 0xFE	; 254
 2cc:	85 b9       	out	0x05, r24	; 5
 2ce:	8f ef       	ldi	r24, 0xFF	; 255
 2d0:	9b e6       	ldi	r25, 0x6B	; 107
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <initHY32D+0x6a>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <initHY32D+0x70>
 2d8:	00 00       	nop
 2da:	85 b1       	in	r24, 0x05	; 5
 2dc:	81 60       	ori	r24, 0x01	; 1
 2de:	85 b9       	out	0x05, r24	; 5
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	9b e6       	ldi	r25, 0x6B	; 107
 2e4:	01 97       	sbiw	r24, 0x01	; 1
 2e6:	f1 f7       	brne	.-4      	; 0x2e4 <initHY32D+0x7c>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <initHY32D+0x82>
 2ea:	00 00       	nop
 2ec:	61 e2       	ldi	r22, 0x21	; 33
 2ee:	70 e0       	ldi	r23, 0x00	; 0
 2f0:	87 e0       	ldi	r24, 0x07	; 7
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	70 e0       	ldi	r23, 0x00	; 0
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 304:	63 e2       	ldi	r22, 0x23	; 35
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	87 e0       	ldi	r24, 0x07	; 7
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	70 e0       	ldi	r23, 0x00	; 0
 314:	80 e1       	ldi	r24, 0x10	; 16
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	97 ed       	ldi	r25, 0xD7	; 215
 320:	01 97       	sbiw	r24, 0x01	; 1
 322:	f1 f7       	brne	.-4      	; 0x320 <initHY32D+0xb8>
 324:	00 c0       	rjmp	.+0      	; 0x326 <initHY32D+0xbe>
 326:	00 00       	nop
 328:	63 e3       	ldi	r22, 0x33	; 51
 32a:	70 e0       	ldi	r23, 0x00	; 0
 32c:	87 e0       	ldi	r24, 0x07	; 7
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 334:	60 e3       	ldi	r22, 0x30	; 48
 336:	78 e6       	ldi	r23, 0x68	; 104
 338:	81 e1       	ldi	r24, 0x11	; 17
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	82 e0       	ldi	r24, 0x02	; 2
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 34c:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 350:	08 95       	ret

00000352 <screenTest>:
 352:	85 b1       	in	r24, 0x05	; 5
 354:	8f 7b       	andi	r24, 0xBF	; 191
 356:	85 b9       	out	0x05, r24	; 5
 358:	8f ef       	ldi	r24, 0xFF	; 255
 35a:	9f ef       	ldi	r25, 0xFF	; 255
 35c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 360:	80 e0       	ldi	r24, 0x00	; 0
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 368:	8e ed       	ldi	r24, 0xDE	; 222
 36a:	97 ef       	ldi	r25, 0xF7	; 247
 36c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 370:	8f e1       	ldi	r24, 0x1F	; 31
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 378:	8f e1       	ldi	r24, 0x1F	; 31
 37a:	95 e0       	ldi	r25, 0x05	; 5
 37c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 380:	80 e0       	ldi	r24, 0x00	; 0
 382:	98 ef       	ldi	r25, 0xF8	; 248
 384:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 388:	8f e1       	ldi	r24, 0x1F	; 31
 38a:	98 ef       	ldi	r25, 0xF8	; 248
 38c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 390:	80 ee       	ldi	r24, 0xE0	; 224
 392:	97 e0       	ldi	r25, 0x07	; 7
 394:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 398:	80 ee       	ldi	r24, 0xE0	; 224
 39a:	9f ef       	ldi	r25, 0xFF	; 255
 39c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a0:	8f ef       	ldi	r24, 0xFF	; 255
 3a2:	9f e7       	ldi	r25, 0x7F	; 127
 3a4:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a8:	87 ee       	ldi	r24, 0xE7	; 231
 3aa:	9c ef       	ldi	r25, 0xFC	; 252
 3ac:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3b0:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 3b4:	85 b1       	in	r24, 0x05	; 5
 3b6:	80 64       	ori	r24, 0x40	; 64
 3b8:	85 b9       	out	0x05, r24	; 5
 3ba:	08 95       	ret

000003bc <readDataLines>:
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
 3c0:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
 3c4:	8e b1       	in	r24, 0x0e	; 14
 3c6:	8f 7b       	andi	r24, 0xBF	; 191
 3c8:	8e b9       	out	0x0e, r24	; 14
 3ca:	86 b1       	in	r24, 0x06	; 6
 3cc:	80 b1       	in	r24, 0x00	; 0
 3ce:	c6 b1       	in	r28, 0x06	; 6
 3d0:	d0 e0       	ldi	r29, 0x00	; 0
 3d2:	dc 2f       	mov	r29, r28
 3d4:	cc 27       	eor	r28, r28
 3d6:	80 b1       	in	r24, 0x00	; 0
 3d8:	c8 2b       	or	r28, r24
 3da:	8e b1       	in	r24, 0x0e	; 14
 3dc:	80 64       	ori	r24, 0x40	; 64
 3de:	8e b9       	out	0x0e, r24	; 14
 3e0:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
 3e4:	ce 01       	movw	r24, r28
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	08 95       	ret

000003ec <lcdStatusRead>:

void lcdStatusRead(void){ // reads SR register
 3ec:	1f 93       	push	r17
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
	unsigned short data;
	CS_LOW;
 3f2:	85 b1       	in	r24, 0x05	; 5
 3f4:	8f 7b       	andi	r24, 0xBF	; 191
 3f6:	85 b9       	out	0x05, r24	; 5
	DC_LOW;
 3f8:	8e b1       	in	r24, 0x0e	; 14
 3fa:	8f 77       	andi	r24, 0x7F	; 127
 3fc:	8e b9       	out	0x0e, r24	; 14
	data = readDataLines();// read data coming through IO lines
 3fe:	0e 94 de 01 	call	0x3bc	; 0x3bc <readDataLines>
 402:	c8 2f       	mov	r28, r24
 404:	d9 2f       	mov	r29, r25
	uint8_t udata = ((data >> 8) & 0xFF);
	uint8_t ldata = (data & 0xFF);
	transmitUART(CR);
 406:	8d e0       	ldi	r24, 0x0D	; 13
 408:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('S'); 	transmitUART('C'); 	transmitUART('R'); transmitUART('E'); 	transmitUART('E');
 40c:	83 e5       	ldi	r24, 0x53	; 83
 40e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 412:	83 e4       	ldi	r24, 0x43	; 67
 414:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 418:	82 e5       	ldi	r24, 0x52	; 82
 41a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 41e:	85 e4       	ldi	r24, 0x45	; 69
 420:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 424:	85 e4       	ldi	r24, 0x45	; 69
 426:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('N'); 	transmitUART(' '); transmitUART('S'); 	transmitUART('T'); transmitUART('A');
 42a:	8e e4       	ldi	r24, 0x4E	; 78
 42c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 430:	80 e2       	ldi	r24, 0x20	; 32
 432:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 436:	83 e5       	ldi	r24, 0x53	; 83
 438:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 43c:	84 e5       	ldi	r24, 0x54	; 84
 43e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 442:	81 e4       	ldi	r24, 0x41	; 65
 444:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('T'); 	transmitUART('U'); transmitUART('S'); 	transmitUART(':'); transmitUART(' ');
 448:	84 e5       	ldi	r24, 0x54	; 84
 44a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 44e:	85 e5       	ldi	r24, 0x55	; 85
 450:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 454:	83 e5       	ldi	r24, 0x53	; 83
 456:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 45a:	8a e3       	ldi	r24, 0x3A	; 58
 45c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 460:	80 e2       	ldi	r24, 0x20	; 32
 462:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('0');
 466:	80 e3       	ldi	r24, 0x30	; 48
 468:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('x');
 46c:	88 e7       	ldi	r24, 0x78	; 120
 46e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	uint8_t udatauhex = ((udata >> 4) & 0x0F);
	uint8_t udatalhex = (udata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 472:	1d 2f       	mov	r17, r29
 474:	1f 70       	andi	r17, 0x0F	; 15
	transmitUART(toHex(udatauhex));
 476:	8d 2f       	mov	r24, r29
 478:	82 95       	swap	r24
 47a:	8f 70       	andi	r24, 0x0F	; 15
 47c:	0e 94 c6 02 	call	0x58c	; 0x58c <toHex>
 480:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART(toHex(udatalhex));
 484:	81 2f       	mov	r24, r17
 486:	0e 94 c6 02 	call	0x58c	; 0x58c <toHex>
 48a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	uint8_t ldatauhex = ((ldata >> 4) & 0x0F);
	uint8_t ldatalhex = (ldata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 48e:	dc 2f       	mov	r29, r28
 490:	df 70       	andi	r29, 0x0F	; 15
	transmitUART(toHex(ldatauhex));
 492:	8c 2f       	mov	r24, r28
 494:	82 95       	swap	r24
 496:	8f 70       	andi	r24, 0x0F	; 15
 498:	0e 94 c6 02 	call	0x58c	; 0x58c <toHex>
 49c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART(toHex(ldatalhex));
 4a0:	8d 2f       	mov	r24, r29
 4a2:	0e 94 c6 02 	call	0x58c	; 0x58c <toHex>
 4a6:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART(CR);
 4aa:	8d e0       	ldi	r24, 0x0D	; 13
 4ac:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	CS_HIGH;
 4b0:	85 b1       	in	r24, 0x05	; 5
 4b2:	80 64       	ori	r24, 0x40	; 64
 4b4:	85 b9       	out	0x05, r24	; 5
 4b6:	df 91       	pop	r29
 4b8:	cf 91       	pop	r28
 4ba:	1f 91       	pop	r17
 4bc:	08 95       	ret

000004be <main>:
uint8_t remoteEcho = 0;

int main(void)
{	
	// Startup sequence
    initUART(); // initialize the UART
 4be:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <initUART>
	initHY32D(); // initialize HY32D screen
 4c2:	0e 94 34 01 	call	0x268	; 0x268 <initHY32D>
	sei(); //Enable global interrupt
 4c6:	78 94       	sei
	systemCheck();
 4c8:	0e 94 12 03 	call	0x624	; 0x624 <systemCheck>
	startupMessage();
 4cc:	0e 94 45 03 	call	0x68a	; 0x68a <startupMessage>
 4d0:	ff cf       	rjmp	.-2      	; 0x4d0 <main+0x12>

000004d2 <__vector_13>:
		- INFO:Utviklingen vil skje på egen maskinvareplattform.
		*/
    }
}

ISR(USART0_RX_vect){
 4d2:	1f 92       	push	r1
 4d4:	0f 92       	push	r0
 4d6:	0f b6       	in	r0, 0x3f	; 63
 4d8:	0f 92       	push	r0
 4da:	11 24       	eor	r1, r1
 4dc:	2f 93       	push	r18
 4de:	3f 93       	push	r19
 4e0:	4f 93       	push	r20
 4e2:	5f 93       	push	r21
 4e4:	6f 93       	push	r22
 4e6:	7f 93       	push	r23
 4e8:	8f 93       	push	r24
 4ea:	9f 93       	push	r25
 4ec:	af 93       	push	r26
 4ee:	bf 93       	push	r27
 4f0:	cf 93       	push	r28
 4f2:	ef 93       	push	r30
 4f4:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	uint8_t receivedByte = UARTBuffer; // local temporary variable for received byte
 4f6:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 4fa:	cc 23       	and	r28, r28
 4fc:	21 f1       	breq	.+72     	; 0x546 <__stack+0x47>
		if (receivedByte == 45) { // that's the '-' sign.
 4fe:	cd 32       	cpi	r28, 0x2D	; 45
 500:	31 f4       	brne	.+12     	; 0x50e <__stack+0xf>
			remoteEcho = ~remoteEcho;
 502:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 506:	80 95       	com	r24
 508:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 50c:	1c c0       	rjmp	.+56     	; 0x546 <__stack+0x47>
		}else if(receivedByte == 's'){
 50e:	c3 37       	cpi	r28, 0x73	; 115
 510:	19 f4       	brne	.+6      	; 0x518 <__stack+0x19>
			systemCheck();
 512:	0e 94 12 03 	call	0x624	; 0x624 <systemCheck>
 516:	17 c0       	rjmp	.+46     	; 0x546 <__stack+0x47>
		}else if(receivedByte == 'l'){
 518:	cc 36       	cpi	r28, 0x6C	; 108
 51a:	19 f4       	brne	.+6      	; 0x522 <__stack+0x23>
			lcdStatusRead();
 51c:	0e 94 f6 01 	call	0x3ec	; 0x3ec <lcdStatusRead>
 520:	12 c0       	rjmp	.+36     	; 0x546 <__stack+0x47>
		}else if(receivedByte == 'b'){
 522:	c2 36       	cpi	r28, 0x62	; 98
 524:	29 f4       	brne	.+10     	; 0x530 <__stack+0x31>
			fillScreen(Blue);
 526:	80 e0       	ldi	r24, 0x00	; 0
 528:	98 ef       	ldi	r25, 0xF8	; 248
 52a:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 52e:	0b c0       	rjmp	.+22     	; 0x546 <__stack+0x47>
		}else if(receivedByte == 'r'){
 530:	c2 37       	cpi	r28, 0x72	; 114
 532:	29 f4       	brne	.+10     	; 0x53e <__stack+0x3f>
			fillScreen(Red);
 534:	8f e1       	ldi	r24, 0x1F	; 31
 536:	90 e0       	ldi	r25, 0x00	; 0
 538:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 53c:	04 c0       	rjmp	.+8      	; 0x546 <__stack+0x47>
		}else if(receivedByte == 'T'){
 53e:	c4 35       	cpi	r28, 0x54	; 84
 540:	11 f4       	brne	.+4      	; 0x546 <__stack+0x47>
			screenTest();
 542:	0e 94 a9 01 	call	0x352	; 0x352 <screenTest>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 546:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 54a:	88 23       	and	r24, r24
 54c:	69 f0       	breq	.+26     	; 0x568 <__stack+0x69>
 54e:	c0 32       	cpi	r28, 0x20	; 32
 550:	40 f4       	brcc	.+16     	; 0x562 <__stack+0x63>
 552:	c7 30       	cpi	r28, 0x07	; 7
 554:	31 f0       	breq	.+12     	; 0x562 <__stack+0x63>
 556:	cd 30       	cpi	r28, 0x0D	; 13
 558:	21 f0       	breq	.+8      	; 0x562 <__stack+0x63>
 55a:	ca 30       	cpi	r28, 0x0A	; 10
 55c:	11 f0       	breq	.+4      	; 0x562 <__stack+0x63>
 55e:	c8 30       	cpi	r28, 0x08	; 8
 560:	19 f4       	brne	.+6      	; 0x568 <__stack+0x69>
		transmitUART(receivedByte);
 562:	8c 2f       	mov	r24, r28
 564:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	}
 568:	ff 91       	pop	r31
 56a:	ef 91       	pop	r30
 56c:	cf 91       	pop	r28
 56e:	bf 91       	pop	r27
 570:	af 91       	pop	r26
 572:	9f 91       	pop	r25
 574:	8f 91       	pop	r24
 576:	7f 91       	pop	r23
 578:	6f 91       	pop	r22
 57a:	5f 91       	pop	r21
 57c:	4f 91       	pop	r20
 57e:	3f 91       	pop	r19
 580:	2f 91       	pop	r18
 582:	0f 90       	pop	r0
 584:	0f be       	out	0x3f, r0	; 63
 586:	0f 90       	pop	r0
 588:	1f 90       	pop	r1
 58a:	18 95       	reti

0000058c <toHex>:
 */ 

#include "stdint.h"

uint8_t toHex(uint8_t number) {
	uint8_t num = '0'+number;
 58c:	80 5d       	subi	r24, 0xD0	; 208
	if(num < 58){
 58e:	8a 33       	cpi	r24, 0x3A	; 58
 590:	c0 f0       	brcs	.+48     	; 0x5c2 <toHex+0x36>
		return num;
	}
	else if(num == 58){
 592:	8a 33       	cpi	r24, 0x3A	; 58
 594:	59 f0       	breq	.+22     	; 0x5ac <toHex+0x20>
		return 'A';
	}
	else if(num == 59){
 596:	8b 33       	cpi	r24, 0x3B	; 59
 598:	59 f0       	breq	.+22     	; 0x5b0 <toHex+0x24>
		return 'B';
	}
	else if(num == 60){
 59a:	8c 33       	cpi	r24, 0x3C	; 60
 59c:	59 f0       	breq	.+22     	; 0x5b4 <toHex+0x28>
		return 'C';
	}
	else if(num == 61){
 59e:	8d 33       	cpi	r24, 0x3D	; 61
 5a0:	59 f0       	breq	.+22     	; 0x5b8 <toHex+0x2c>
		return 'D';
	}
	else if(num == 62){
 5a2:	8e 33       	cpi	r24, 0x3E	; 62
 5a4:	59 f0       	breq	.+22     	; 0x5bc <toHex+0x30>
		return 'E';
	}
	else if(num == 63){
 5a6:	8f 33       	cpi	r24, 0x3F	; 63
 5a8:	59 f0       	breq	.+22     	; 0x5c0 <toHex+0x34>
		return 'F';
	}
 5aa:	08 95       	ret
	uint8_t num = '0'+number;
	if(num < 58){
		return num;
	}
	else if(num == 58){
		return 'A';
 5ac:	81 e4       	ldi	r24, 0x41	; 65
 5ae:	08 95       	ret
	}
	else if(num == 59){
		return 'B';
 5b0:	82 e4       	ldi	r24, 0x42	; 66
 5b2:	08 95       	ret
	}
	else if(num == 60){
		return 'C';
 5b4:	83 e4       	ldi	r24, 0x43	; 67
 5b6:	08 95       	ret
	}
	else if(num == 61){
		return 'D';
 5b8:	84 e4       	ldi	r24, 0x44	; 68
 5ba:	08 95       	ret
	}
	else if(num == 62){
		return 'E';
 5bc:	85 e4       	ldi	r24, 0x45	; 69
 5be:	08 95       	ret
	}
	else if(num == 63){
		return 'F';
 5c0:	86 e4       	ldi	r24, 0x46	; 70
	}
 5c2:	08 95       	ret

000005c4 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 5c4:	8f e2       	ldi	r24, 0x2F	; 47
 5c6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 5ca:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 5ce:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 5d2:	88 e9       	ldi	r24, 0x98	; 152
 5d4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 5d8:	86 e0       	ldi	r24, 0x06	; 6
 5da:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 5de:	08 95       	ret

000005e0 <puttyCompatibleCheck>:
}

uint8_t puttyCompatibleCheck(uint8_t byte){
	if((byte > 31) || (byte == Bell) || (byte == CR) || (byte == LF) || (byte == backspace)){
 5e0:	80 32       	cpi	r24, 0x20	; 32
 5e2:	48 f4       	brcc	.+18     	; 0x5f6 <puttyCompatibleCheck+0x16>
 5e4:	87 30       	cpi	r24, 0x07	; 7
 5e6:	39 f0       	breq	.+14     	; 0x5f6 <puttyCompatibleCheck+0x16>
 5e8:	8d 30       	cpi	r24, 0x0D	; 13
 5ea:	29 f0       	breq	.+10     	; 0x5f6 <puttyCompatibleCheck+0x16>
 5ec:	8a 30       	cpi	r24, 0x0A	; 10
 5ee:	19 f0       	breq	.+6      	; 0x5f6 <puttyCompatibleCheck+0x16>
 5f0:	88 30       	cpi	r24, 0x08	; 8
 5f2:	09 f0       	breq	.+2      	; 0x5f6 <puttyCompatibleCheck+0x16>
		return byte;
		}else{
		return (uint8_t)64;
 5f4:	80 e4       	ldi	r24, 0x40	; 64
	}
}
 5f6:	08 95       	ret

000005f8 <transmitUART>:

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 5f8:	20 e0       	ldi	r18, 0x00	; 0
 5fa:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 5fc:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 600:	95 ff       	sbrs	r25, 5
 602:	07 c0       	rjmp	.+14     	; 0x612 <transmitUART+0x1a>
			UARTBuffer = puttyCompatibleCheck(data);
 604:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <puttyCompatibleCheck>
 608:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 60c:	81 e0       	ldi	r24, 0x01	; 1
 60e:	90 e0       	ldi	r25, 0x00	; 0
 610:	08 95       	ret
			}else{
			timeout++;
 612:	2f 5f       	subi	r18, 0xFF	; 255
 614:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 616:	29 3e       	cpi	r18, 0xE9	; 233
 618:	93 e0       	ldi	r25, 0x03	; 3
 61a:	39 07       	cpc	r19, r25
 61c:	7c f3       	brlt	.-34     	; 0x5fc <transmitUART+0x4>
				return 0;
 61e:	80 e0       	ldi	r24, 0x00	; 0
 620:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 622:	08 95       	ret

00000624 <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 624:	8d e0       	ldi	r24, 0x0D	; 13
 626:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('-');
 62a:	8d e2       	ldi	r24, 0x2D	; 45
 62c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART(CR);
 630:	8d e0       	ldi	r24, 0x0D	; 13
 632:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('S');	transmitUART('y'); 	transmitUART('s'); 	transmitUART('t'); 	transmitUART('e');
 636:	83 e5       	ldi	r24, 0x53	; 83
 638:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 63c:	89 e7       	ldi	r24, 0x79	; 121
 63e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 642:	83 e7       	ldi	r24, 0x73	; 115
 644:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 648:	84 e7       	ldi	r24, 0x74	; 116
 64a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 64e:	85 e6       	ldi	r24, 0x65	; 101
 650:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('m');	transmitUART(' '); 	transmitUART('c'); 	transmitUART('h'); 	transmitUART('e');
 654:	8d e6       	ldi	r24, 0x6D	; 109
 656:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 65a:	80 e2       	ldi	r24, 0x20	; 32
 65c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 660:	83 e6       	ldi	r24, 0x63	; 99
 662:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 666:	88 e6       	ldi	r24, 0x68	; 104
 668:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 66c:	85 e6       	ldi	r24, 0x65	; 101
 66e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('c');	transmitUART('k'); 	transmitUART(':');
 672:	83 e6       	ldi	r24, 0x63	; 99
 674:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 678:	8b e6       	ldi	r24, 0x6B	; 107
 67a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 67e:	8a e3       	ldi	r24, 0x3A	; 58
 680:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	lcdStatusRead();
 684:	0e 94 f6 01 	call	0x3ec	; 0x3ec <lcdStatusRead>
 688:	08 95       	ret

0000068a <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART('B');	transmitUART('l'); 	transmitUART('i'); 	transmitUART('t'); 	transmitUART('t');
 68a:	82 e4       	ldi	r24, 0x42	; 66
 68c:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 690:	8c e6       	ldi	r24, 0x6C	; 108
 692:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 696:	89 e6       	ldi	r24, 0x69	; 105
 698:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 69c:	84 e7       	ldi	r24, 0x74	; 116
 69e:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6a2:	84 e7       	ldi	r24, 0x74	; 116
 6a4:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('e');	transmitUART('r'); 	transmitUART(' '); 	transmitUART('r'); 	transmitUART('e');
 6a8:	85 e6       	ldi	r24, 0x65	; 101
 6aa:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6ae:	82 e7       	ldi	r24, 0x72	; 114
 6b0:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6b4:	80 e2       	ldi	r24, 0x20	; 32
 6b6:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6ba:	82 e7       	ldi	r24, 0x72	; 114
 6bc:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6c0:	85 e6       	ldi	r24, 0x65	; 101
 6c2:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART('a');	transmitUART('d'); 	transmitUART('y');
 6c6:	81 e6       	ldi	r24, 0x61	; 97
 6c8:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6cc:	84 e6       	ldi	r24, 0x64	; 100
 6ce:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6d2:	89 e7       	ldi	r24, 0x79	; 121
 6d4:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
	transmitUART(CR);
 6d8:	8d e0       	ldi	r24, 0x0D	; 13
 6da:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <transmitUART>
 6de:	08 95       	ret

000006e0 <_exit>:
 6e0:	f8 94       	cli

000006e2 <__stop_program>:
 6e2:	ff cf       	rjmp	.-2      	; 0x6e2 <__stop_program>
