
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000096a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008f6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  0000096a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000096a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000099c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  000009dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001e1e  00000000  00000000  00000b44  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c6e  00000000  00000000  00002962  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ed7  00000000  00000000  000035d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000032c  00000000  00000000  000044a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006d7  00000000  00000000  000047d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bb9  00000000  00000000  00004eab  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  00005a64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 3b 03 	call	0x676	; 0x676 <main>
  7c:	0c 94 79 04 	jmp	0x8f2	; 0x8f2 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DC_HIGH;
	WR_BLT_CLK_HIGH;
	data = readDataLines();
	transmitUART((char)data);
	return data;
}
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <setIOtoOutput>:
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	81 b9       	out	0x01, r24	; 1
  e8:	87 b9       	out	0x07, r24	; 7
  ea:	08 95       	ret

000000ec <setIOtoInput>:
  ec:	11 b8       	out	0x01, r1	; 1
  ee:	17 b8       	out	0x07, r1	; 7
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	8f e3       	ldi	r24, 0x3F	; 63
  f4:	92 e0       	ldi	r25, 0x02	; 2
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <setIOtoInput+0xa>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <setIOtoInput+0x14>
 100:	00 00       	nop
 102:	08 95       	ret

00000104 <fillScreen>:
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ef 92       	push	r14
 10a:	ff 92       	push	r15
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	ec 01       	movw	r28, r24
 112:	85 b1       	in	r24, 0x05	; 5
 114:	8f 7b       	andi	r24, 0xBF	; 191
 116:	85 b9       	out	0x05, r24	; 5
 118:	82 e2       	ldi	r24, 0x22	; 34
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	c1 2c       	mov	r12, r1
 122:	d1 2c       	mov	r13, r1
 124:	76 01       	movw	r14, r12
 126:	08 c0       	rjmp	.+16     	; 0x138 <fillScreen+0x34>
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 12e:	8f ef       	ldi	r24, 0xFF	; 255
 130:	c8 1a       	sub	r12, r24
 132:	d8 0a       	sbc	r13, r24
 134:	e8 0a       	sbc	r14, r24
 136:	f8 0a       	sbc	r15, r24
 138:	c1 14       	cp	r12, r1
 13a:	8c e2       	ldi	r24, 0x2C	; 44
 13c:	d8 06       	cpc	r13, r24
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	e8 06       	cpc	r14, r24
 142:	f1 04       	cpc	r15, r1
 144:	88 f3       	brcs	.-30     	; 0x128 <fillScreen+0x24>
 146:	85 b1       	in	r24, 0x05	; 5
 148:	80 64       	ori	r24, 0x40	; 64
 14a:	85 b9       	out	0x05, r24	; 5
 14c:	df 91       	pop	r29
 14e:	cf 91       	pop	r28
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

0000015a <colorTest>:
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	85 b1       	in	r24, 0x05	; 5
 160:	8f 7b       	andi	r24, 0xBF	; 191
 162:	85 b9       	out	0x05, r24	; 5
 164:	82 e2       	ldi	r24, 0x22	; 34
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 16c:	c0 e0       	ldi	r28, 0x00	; 0
 16e:	d0 e0       	ldi	r29, 0x00	; 0
 170:	05 c0       	rjmp	.+10     	; 0x17c <colorTest+0x22>
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	9f ef       	ldi	r25, 0xFF	; 255
 176:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 17a:	21 96       	adiw	r28, 0x01	; 1
 17c:	c1 15       	cp	r28, r1
 17e:	8e e1       	ldi	r24, 0x1E	; 30
 180:	d8 07       	cpc	r29, r24
 182:	bc f3       	brlt	.-18     	; 0x172 <colorTest+0x18>
 184:	c0 e0       	ldi	r28, 0x00	; 0
 186:	d0 e0       	ldi	r29, 0x00	; 0
 188:	05 c0       	rjmp	.+10     	; 0x194 <colorTest+0x3a>
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 192:	21 96       	adiw	r28, 0x01	; 1
 194:	c1 15       	cp	r28, r1
 196:	8e e1       	ldi	r24, 0x1E	; 30
 198:	d8 07       	cpc	r29, r24
 19a:	bc f3       	brlt	.-18     	; 0x18a <colorTest+0x30>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <colorTest+0x52>
 1a2:	8e ed       	ldi	r24, 0xDE	; 222
 1a4:	97 ef       	ldi	r25, 0xF7	; 247
 1a6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1aa:	21 96       	adiw	r28, 0x01	; 1
 1ac:	c1 15       	cp	r28, r1
 1ae:	8e e1       	ldi	r24, 0x1E	; 30
 1b0:	d8 07       	cpc	r29, r24
 1b2:	bc f3       	brlt	.-18     	; 0x1a2 <colorTest+0x48>
 1b4:	c0 e0       	ldi	r28, 0x00	; 0
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <colorTest+0x6a>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	98 ef       	ldi	r25, 0xF8	; 248
 1be:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1c2:	21 96       	adiw	r28, 0x01	; 1
 1c4:	c1 15       	cp	r28, r1
 1c6:	8e e1       	ldi	r24, 0x1E	; 30
 1c8:	d8 07       	cpc	r29, r24
 1ca:	bc f3       	brlt	.-18     	; 0x1ba <colorTest+0x60>
 1cc:	c0 e0       	ldi	r28, 0x00	; 0
 1ce:	d0 e0       	ldi	r29, 0x00	; 0
 1d0:	05 c0       	rjmp	.+10     	; 0x1dc <colorTest+0x82>
 1d2:	87 ee       	ldi	r24, 0xE7	; 231
 1d4:	9c ef       	ldi	r25, 0xFC	; 252
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	c1 15       	cp	r28, r1
 1de:	8e e1       	ldi	r24, 0x1E	; 30
 1e0:	d8 07       	cpc	r29, r24
 1e2:	bc f3       	brlt	.-18     	; 0x1d2 <colorTest+0x78>
 1e4:	c0 e0       	ldi	r28, 0x00	; 0
 1e6:	d0 e0       	ldi	r29, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <colorTest+0x9a>
 1ea:	8f e1       	ldi	r24, 0x1F	; 31
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1f2:	21 96       	adiw	r28, 0x01	; 1
 1f4:	c1 15       	cp	r28, r1
 1f6:	8e e1       	ldi	r24, 0x1E	; 30
 1f8:	d8 07       	cpc	r29, r24
 1fa:	bc f3       	brlt	.-18     	; 0x1ea <colorTest+0x90>
 1fc:	c0 e0       	ldi	r28, 0x00	; 0
 1fe:	d0 e0       	ldi	r29, 0x00	; 0
 200:	05 c0       	rjmp	.+10     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
 202:	8f e1       	ldi	r24, 0x1F	; 31
 204:	98 ef       	ldi	r25, 0xF8	; 248
 206:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	c1 15       	cp	r28, r1
 20e:	8e e1       	ldi	r24, 0x1E	; 30
 210:	d8 07       	cpc	r29, r24
 212:	bc f3       	brlt	.-18     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
 214:	c0 e0       	ldi	r28, 0x00	; 0
 216:	d0 e0       	ldi	r29, 0x00	; 0
 218:	05 c0       	rjmp	.+10     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	97 e0       	ldi	r25, 0x07	; 7
 21e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 222:	21 96       	adiw	r28, 0x01	; 1
 224:	c1 15       	cp	r28, r1
 226:	8e e1       	ldi	r24, 0x1E	; 30
 228:	d8 07       	cpc	r29, r24
 22a:	bc f3       	brlt	.-18     	; 0x21a <__EEPROM_REGION_LENGTH__+0x1a>
 22c:	c0 e0       	ldi	r28, 0x00	; 0
 22e:	d0 e0       	ldi	r29, 0x00	; 0
 230:	05 c0       	rjmp	.+10     	; 0x23c <__EEPROM_REGION_LENGTH__+0x3c>
 232:	80 ee       	ldi	r24, 0xE0	; 224
 234:	9f ef       	ldi	r25, 0xFF	; 255
 236:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 23a:	21 96       	adiw	r28, 0x01	; 1
 23c:	c1 15       	cp	r28, r1
 23e:	8e e1       	ldi	r24, 0x1E	; 30
 240:	d8 07       	cpc	r29, r24
 242:	bc f3       	brlt	.-18     	; 0x232 <__EEPROM_REGION_LENGTH__+0x32>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 24a:	8f e1       	ldi	r24, 0x1F	; 31
 24c:	95 e0       	ldi	r25, 0x05	; 5
 24e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 252:	21 96       	adiw	r28, 0x01	; 1
 254:	c1 15       	cp	r28, r1
 256:	8e e1       	ldi	r24, 0x1E	; 30
 258:	d8 07       	cpc	r29, r24
 25a:	bc f3       	brlt	.-18     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 25c:	85 b1       	in	r24, 0x05	; 5
 25e:	80 64       	ori	r24, 0x40	; 64
 260:	85 b9       	out	0x05, r24	; 5
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <initHY32D>:
 268:	2f ef       	ldi	r18, 0xFF	; 255
 26a:	8f e3       	ldi	r24, 0x3F	; 63
 26c:	92 e0       	ldi	r25, 0x02	; 2
 26e:	21 50       	subi	r18, 0x01	; 1
 270:	80 40       	sbci	r24, 0x00	; 0
 272:	90 40       	sbci	r25, 0x00	; 0
 274:	e1 f7       	brne	.-8      	; 0x26e <initHY32D+0x6>
 276:	00 c0       	rjmp	.+0      	; 0x278 <initHY32D+0x10>
 278:	00 00       	nop
 27a:	85 b1       	in	r24, 0x05	; 5
 27c:	81 60       	ori	r24, 0x01	; 1
 27e:	85 b9       	out	0x05, r24	; 5
 280:	8f ef       	ldi	r24, 0xFF	; 255
 282:	93 e2       	ldi	r25, 0x23	; 35
 284:	01 97       	sbiw	r24, 0x01	; 1
 286:	f1 f7       	brne	.-4      	; 0x284 <initHY32D+0x1c>
 288:	00 c0       	rjmp	.+0      	; 0x28a <initHY32D+0x22>
 28a:	00 00       	nop
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	8e 7f       	andi	r24, 0xFE	; 254
 290:	85 b9       	out	0x05, r24	; 5
 292:	8f ef       	ldi	r24, 0xFF	; 255
 294:	9b e6       	ldi	r25, 0x6B	; 107
 296:	01 97       	sbiw	r24, 0x01	; 1
 298:	f1 f7       	brne	.-4      	; 0x296 <initHY32D+0x2e>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <initHY32D+0x34>
 29c:	00 00       	nop
 29e:	85 b1       	in	r24, 0x05	; 5
 2a0:	81 60       	ori	r24, 0x01	; 1
 2a2:	85 b9       	out	0x05, r24	; 5
 2a4:	8f ef       	ldi	r24, 0xFF	; 255
 2a6:	9b e6       	ldi	r25, 0x6B	; 107
 2a8:	01 97       	sbiw	r24, 0x01	; 1
 2aa:	f1 f7       	brne	.-4      	; 0x2a8 <initHY32D+0x40>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <initHY32D+0x46>
 2ae:	00 00       	nop
 2b0:	61 e2       	ldi	r22, 0x21	; 33
 2b2:	70 e0       	ldi	r23, 0x00	; 0
 2b4:	87 e0       	ldi	r24, 0x07	; 7
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2bc:	61 e0       	ldi	r22, 0x01	; 1
 2be:	70 e0       	ldi	r23, 0x00	; 0
 2c0:	80 e0       	ldi	r24, 0x00	; 0
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2c8:	63 e2       	ldi	r22, 0x23	; 35
 2ca:	70 e0       	ldi	r23, 0x00	; 0
 2cc:	87 e0       	ldi	r24, 0x07	; 7
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2d4:	60 e0       	ldi	r22, 0x00	; 0
 2d6:	70 e0       	ldi	r23, 0x00	; 0
 2d8:	80 e1       	ldi	r24, 0x10	; 16
 2da:	90 e0       	ldi	r25, 0x00	; 0
 2dc:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	97 ed       	ldi	r25, 0xD7	; 215
 2e4:	01 97       	sbiw	r24, 0x01	; 1
 2e6:	f1 f7       	brne	.-4      	; 0x2e4 <initHY32D+0x7c>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <initHY32D+0x82>
 2ea:	00 00       	nop
 2ec:	63 e3       	ldi	r22, 0x33	; 51
 2ee:	70 e0       	ldi	r23, 0x00	; 0
 2f0:	87 e0       	ldi	r24, 0x07	; 7
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2f8:	60 e3       	ldi	r22, 0x30	; 48
 2fa:	78 e6       	ldi	r23, 0x68	; 104
 2fc:	81 e1       	ldi	r24, 0x11	; 17
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 304:	60 e0       	ldi	r22, 0x00	; 0
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	82 e0       	ldi	r24, 0x02	; 2
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 310:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 314:	08 95       	ret

00000316 <screenTest>:
 316:	85 b1       	in	r24, 0x05	; 5
 318:	8f 7b       	andi	r24, 0xBF	; 191
 31a:	85 b9       	out	0x05, r24	; 5
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	9f ef       	ldi	r25, 0xFF	; 255
 320:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 32c:	8e ed       	ldi	r24, 0xDE	; 222
 32e:	97 ef       	ldi	r25, 0xF7	; 247
 330:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 334:	8f e1       	ldi	r24, 0x1F	; 31
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 33c:	8f e1       	ldi	r24, 0x1F	; 31
 33e:	95 e0       	ldi	r25, 0x05	; 5
 340:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 344:	80 e0       	ldi	r24, 0x00	; 0
 346:	98 ef       	ldi	r25, 0xF8	; 248
 348:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 34c:	8f e1       	ldi	r24, 0x1F	; 31
 34e:	98 ef       	ldi	r25, 0xF8	; 248
 350:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 354:	80 ee       	ldi	r24, 0xE0	; 224
 356:	97 e0       	ldi	r25, 0x07	; 7
 358:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 35c:	80 ee       	ldi	r24, 0xE0	; 224
 35e:	9f ef       	ldi	r25, 0xFF	; 255
 360:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 364:	8f ef       	ldi	r24, 0xFF	; 255
 366:	9f e7       	ldi	r25, 0x7F	; 127
 368:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 36c:	87 ee       	ldi	r24, 0xE7	; 231
 36e:	9c ef       	ldi	r25, 0xFC	; 252
 370:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 374:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 378:	85 b1       	in	r24, 0x05	; 5
 37a:	80 64       	ori	r24, 0x40	; 64
 37c:	85 b9       	out	0x05, r24	; 5
 37e:	08 95       	ret

00000380 <readDataLines>:
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
 388:	8e b1       	in	r24, 0x0e	; 14
 38a:	8f 7b       	andi	r24, 0xBF	; 191
 38c:	8e b9       	out	0x0e, r24	; 14
 38e:	86 b1       	in	r24, 0x06	; 6
 390:	80 b1       	in	r24, 0x00	; 0
 392:	c6 b1       	in	r28, 0x06	; 6
 394:	d0 e0       	ldi	r29, 0x00	; 0
 396:	dc 2f       	mov	r29, r28
 398:	cc 27       	eor	r28, r28
 39a:	80 b1       	in	r24, 0x00	; 0
 39c:	c8 2b       	or	r28, r24
 39e:	8e b1       	in	r24, 0x0e	; 14
 3a0:	80 64       	ori	r24, 0x40	; 64
 3a2:	8e b9       	out	0x0e, r24	; 14
 3a4:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
 3a8:	ce 01       	movw	r24, r28
 3aa:	df 91       	pop	r29
 3ac:	cf 91       	pop	r28
 3ae:	08 95       	ret

000003b0 <lcdStatusRead>:

void lcdStatusRead(void){ // reads SR register
 3b0:	1f 93       	push	r17
 3b2:	cf 93       	push	r28
 3b4:	df 93       	push	r29
	unsigned short data;
	CS_LOW;
 3b6:	85 b1       	in	r24, 0x05	; 5
 3b8:	8f 7b       	andi	r24, 0xBF	; 191
 3ba:	85 b9       	out	0x05, r24	; 5
	DC_LOW;
 3bc:	8e b1       	in	r24, 0x0e	; 14
 3be:	8f 77       	andi	r24, 0x7F	; 127
 3c0:	8e b9       	out	0x0e, r24	; 14
	data = readDataLines();// read data coming through IO lines
 3c2:	0e 94 c0 01 	call	0x380	; 0x380 <readDataLines>
 3c6:	c8 2f       	mov	r28, r24
 3c8:	d9 2f       	mov	r29, r25
	uint8_t udata = ((data >> 8) & 0xFF);
	uint8_t ldata = (data & 0xFF);
	transmitUART(CR);
 3ca:	8d e0       	ldi	r24, 0x0D	; 13
 3cc:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('S'); 	transmitUART('C'); 	transmitUART('R'); transmitUART('E'); 	transmitUART('E');
 3d0:	83 e5       	ldi	r24, 0x53	; 83
 3d2:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3d6:	83 e4       	ldi	r24, 0x43	; 67
 3d8:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3dc:	82 e5       	ldi	r24, 0x52	; 82
 3de:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3e2:	85 e4       	ldi	r24, 0x45	; 69
 3e4:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3e8:	85 e4       	ldi	r24, 0x45	; 69
 3ea:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('N'); 	transmitUART(' '); transmitUART('S'); 	transmitUART('T'); transmitUART('A');
 3ee:	8e e4       	ldi	r24, 0x4E	; 78
 3f0:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3f4:	80 e2       	ldi	r24, 0x20	; 32
 3f6:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 3fa:	83 e5       	ldi	r24, 0x53	; 83
 3fc:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 400:	84 e5       	ldi	r24, 0x54	; 84
 402:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 406:	81 e4       	ldi	r24, 0x41	; 65
 408:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('T'); 	transmitUART('U'); transmitUART('S'); 	transmitUART(':'); transmitUART(' ');
 40c:	84 e5       	ldi	r24, 0x54	; 84
 40e:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 412:	85 e5       	ldi	r24, 0x55	; 85
 414:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 418:	83 e5       	ldi	r24, 0x53	; 83
 41a:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 41e:	8a e3       	ldi	r24, 0x3A	; 58
 420:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 424:	80 e2       	ldi	r24, 0x20	; 32
 426:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('0');
 42a:	80 e3       	ldi	r24, 0x30	; 48
 42c:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('x');
 430:	88 e7       	ldi	r24, 0x78	; 120
 432:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	uint8_t udatauhex = ((udata >> 4) & 0x0F);
	uint8_t udatalhex = (udata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 436:	1d 2f       	mov	r17, r29
 438:	1f 70       	andi	r17, 0x0F	; 15
	transmitUART(toHex(udatauhex));
 43a:	8d 2f       	mov	r24, r29
 43c:	82 95       	swap	r24
 43e:	8f 70       	andi	r24, 0x0F	; 15
 440:	0e 94 cf 03 	call	0x79e	; 0x79e <toHex>
 444:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART(toHex(udatalhex));
 448:	81 2f       	mov	r24, r17
 44a:	0e 94 cf 03 	call	0x79e	; 0x79e <toHex>
 44e:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	uint8_t ldatauhex = ((ldata >> 4) & 0x0F);
	uint8_t ldatalhex = (ldata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 452:	dc 2f       	mov	r29, r28
 454:	df 70       	andi	r29, 0x0F	; 15
	transmitUART(toHex(ldatauhex));
 456:	8c 2f       	mov	r24, r28
 458:	82 95       	swap	r24
 45a:	8f 70       	andi	r24, 0x0F	; 15
 45c:	0e 94 cf 03 	call	0x79e	; 0x79e <toHex>
 460:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART(toHex(ldatalhex));
 464:	8d 2f       	mov	r24, r29
 466:	0e 94 cf 03 	call	0x79e	; 0x79e <toHex>
 46a:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART(CR);
 46e:	8d e0       	ldi	r24, 0x0D	; 13
 470:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	CS_HIGH;
 474:	85 b1       	in	r24, 0x05	; 5
 476:	80 64       	ori	r24, 0x40	; 64
 478:	85 b9       	out	0x05, r24	; 5
 47a:	df 91       	pop	r29
 47c:	cf 91       	pop	r28
 47e:	1f 91       	pop	r17
 480:	08 95       	ret

00000482 <loadDataToOutputLines>:
uint8_t remoteEcho = 0;
unsigned char lData; // not redeclaring these variables increases performance a lot
unsigned char hData;

void loadDataToOutputLines(unsigned short data){
	lData = (data & 0xFF);
 482:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
	hData = ((data >> 8) & 0xFF);
 486:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
	D0_D7 = lData; // Write data to GPIO lines (lines should by default be output)
 48a:	82 b9       	out	0x02, r24	; 2
	D8_D15 = hData;
 48c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
 490:	88 b9       	out	0x08, r24	; 8
 492:	08 95       	ret

00000494 <setExtraBlitIOToOutput>:
}

void setExtraBlitIOToOutput(void) {
	// This can probably be done at startup/initialization
	DDRE |= (1 << PE4); // Port 4 to output (/SRAM OE)	(D16)
 494:	8d b1       	in	r24, 0x0d	; 13
 496:	80 61       	ori	r24, 0x10	; 16
 498:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE5); // Port 5 to output (/SRAM WE)	(D17)
 49a:	8d b1       	in	r24, 0x0d	; 13
 49c:	80 62       	ori	r24, 0x20	; 32
 49e:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE6); // Port 6 to output (RD)			(D18)
 4a0:	8d b1       	in	r24, 0x0d	; 13
 4a2:	80 64       	ori	r24, 0x40	; 64
 4a4:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE7); // Port 7 to output (DC)			(D19)
 4a6:	8d b1       	in	r24, 0x0d	; 13
 4a8:	80 68       	ori	r24, 0x80	; 128
 4aa:	8d b9       	out	0x0d, r24	; 13
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4ac:	2f ef       	ldi	r18, 0xFF	; 255
 4ae:	8f e3       	ldi	r24, 0x3F	; 63
 4b0:	92 e0       	ldi	r25, 0x02	; 2
 4b2:	21 50       	subi	r18, 0x01	; 1
 4b4:	80 40       	sbci	r24, 0x00	; 0
 4b6:	90 40       	sbci	r25, 0x00	; 0
 4b8:	e1 f7       	brne	.-8      	; 0x4b2 <setExtraBlitIOToOutput+0x1e>
 4ba:	00 c0       	rjmp	.+0      	; 0x4bc <setExtraBlitIOToOutput+0x28>
 4bc:	00 00       	nop
 4be:	08 95       	ret

000004c0 <presetCountersToZero>:
	_delay_ms(100); // Not sure if this is necessary, check later
}

// BLT_RST (to reset counter values is also an option. See counter datasheet.
void presetCountersToZero(void){
	CS_HIGH; // Deselect LCD and SRAM
 4c0:	85 b1       	in	r24, 0x05	; 5
 4c2:	80 64       	ori	r24, 0x40	; 64
 4c4:	85 b9       	out	0x05, r24	; 5
	setIOtoOutput(); // Set all lines to output
 4c6:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
	setExtraBlitIOToOutput();
 4ca:	0e 94 4a 02 	call	0x494	; 0x494 <setExtraBlitIOToOutput>
	// Give all outlines a value of 0
	D0_D7 = 0x00;
 4ce:	12 b8       	out	0x02, r1	; 2
	D8_D15 = 0x00;
 4d0:	18 b8       	out	0x08, r1	; 8
	PORTE &= ~(1 << PE4);
 4d2:	8e b1       	in	r24, 0x0e	; 14
 4d4:	8f 7e       	andi	r24, 0xEF	; 239
 4d6:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE5);
 4d8:	8e b1       	in	r24, 0x0e	; 14
 4da:	8f 7d       	andi	r24, 0xDF	; 223
 4dc:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE6);
 4de:	8e b1       	in	r24, 0x0e	; 14
 4e0:	8f 7b       	andi	r24, 0xBF	; 191
 4e2:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE7);
 4e4:	8e b1       	in	r24, 0x0e	; 14
 4e6:	8f 77       	andi	r24, 0x7F	; 127
 4e8:	8e b9       	out	0x0e, r24	; 14
 4ea:	83 e3       	ldi	r24, 0x33	; 51
 4ec:	97 e0       	ldi	r25, 0x07	; 7
 4ee:	01 97       	sbiw	r24, 0x01	; 1
 4f0:	f1 f7       	brne	.-4      	; 0x4ee <presetCountersToZero+0x2e>
	_delay_ms(1);
	// Counter signal lines
	RESET_HIGH; // Set CLR(BLT_RST)(PB0)(RESET) to HIGH
 4f2:	85 b1       	in	r24, 0x05	; 5
 4f4:	81 60       	ori	r24, 0x01	; 1
 4f6:	85 b9       	out	0x05, r24	; 5
	LOAD_LOW; // Set LOAD(PE3) to LOW
 4f8:	8e b1       	in	r24, 0x0e	; 14
 4fa:	87 7f       	andi	r24, 0xF7	; 247
 4fc:	8e b9       	out	0x0e, r24	; 14
	wrSignal();// Send blitsignal (aka a clk)
 4fe:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
	LOAD_HIGH;
 502:	8e b1       	in	r24, 0x0e	; 14
 504:	88 60       	ori	r24, 0x08	; 8
 506:	8e b9       	out	0x0e, r24	; 14
	SRAM_OE_HIGH;
 508:	8e b1       	in	r24, 0x0e	; 14
 50a:	80 61       	ori	r24, 0x10	; 16
 50c:	8e b9       	out	0x0e, r24	; 14
	SRAM_WE_HIGH;
 50e:	8e b1       	in	r24, 0x0e	; 14
 510:	80 62       	ori	r24, 0x20	; 32
 512:	8e b9       	out	0x0e, r24	; 14
 514:	08 95       	ret

00000516 <wrSignalSRAM>:
}

void wrSignalSRAM(){
	SRAM_WE_LOW;
 516:	8e b1       	in	r24, 0x0e	; 14
 518:	8f 7d       	andi	r24, 0xDF	; 223
 51a:	8e b9       	out	0x0e, r24	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 51c:	82 e0       	ldi	r24, 0x02	; 2
 51e:	8a 95       	dec	r24
 520:	f1 f7       	brne	.-4      	; 0x51e <wrSignalSRAM+0x8>
 522:	00 c0       	rjmp	.+0      	; 0x524 <wrSignalSRAM+0xe>
	_delay_us(1);
	SRAM_WE_HIGH;
 524:	8e b1       	in	r24, 0x0e	; 14
 526:	80 62       	ori	r24, 0x20	; 32
 528:	8e b9       	out	0x0e, r24	; 14
 52a:	08 95       	ret

0000052c <rdSignalSRAM>:
}

void rdSignalSRAM(){
	SRAM_OE_LOW;
 52c:	8e b1       	in	r24, 0x0e	; 14
 52e:	8f 7e       	andi	r24, 0xEF	; 239
 530:	8e b9       	out	0x0e, r24	; 14
 532:	82 e0       	ldi	r24, 0x02	; 2
 534:	8a 95       	dec	r24
 536:	f1 f7       	brne	.-4      	; 0x534 <rdSignalSRAM+0x8>
 538:	00 c0       	rjmp	.+0      	; 0x53a <rdSignalSRAM+0xe>
	_delay_us(1);
	SRAM_OE_HIGH;
 53a:	8e b1       	in	r24, 0x0e	; 14
 53c:	80 61       	ori	r24, 0x10	; 16
 53e:	8e b9       	out	0x0e, r24	; 14
 540:	08 95       	ret

00000542 <readSRAM>:
}

// It looks like a write signal to the CLK ruins something ..
void readSRAM(void){
 542:	cf 92       	push	r12
 544:	df 92       	push	r13
 546:	ef 92       	push	r14
 548:	ff 92       	push	r15
	SRAM_WE_HIGH; // SRAM Write high (disabled)
 54a:	8e b1       	in	r24, 0x0e	; 14
 54c:	80 62       	ori	r24, 0x20	; 32
 54e:	8e b9       	out	0x0e, r24	; 14
	presetCountersToZero(); // set counters to 0
 550:	0e 94 60 02 	call	0x4c0	; 0x4c0 <presetCountersToZero>
	CS_LOW; // Select screen and SRAM
 554:	85 b1       	in	r24, 0x05	; 5
 556:	8f 7b       	andi	r24, 0xBF	; 191
 558:	85 b9       	out	0x05, r24	; 5
	BLT_EN_HIGH; // counters enabled
 55a:	85 b1       	in	r24, 0x05	; 5
 55c:	80 68       	ori	r24, 0x80	; 128
 55e:	85 b9       	out	0x05, r24	; 5
	
	DC_HIGH;
 560:	8e b1       	in	r24, 0x0e	; 14
 562:	80 68       	ori	r24, 0x80	; 128
 564:	8e b9       	out	0x0e, r24	; 14
	writeIndex(0x22); // ensure writing to screenbuffer
 566:	82 e2       	ldi	r24, 0x22	; 34
 568:	90 e0       	ldi	r25, 0x00	; 0
 56a:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	setIOtoInput(); // Set D0-D15 to input so it doesn't interfere with SRAM to Screen lines
 56e:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
	
	for(unsigned long int i = 0; i < (pixels); i++){
 572:	c1 2c       	mov	r12, r1
 574:	d1 2c       	mov	r13, r1
 576:	76 01       	movw	r14, r12
 578:	09 c0       	rjmp	.+18     	; 0x58c <readSRAM+0x4a>
		rdSignalSRAM(); // SRAM OE goes LOW-HIGH reading the SRAM values on the address specified by the counters to the screen.
 57a:	0e 94 96 02 	call	0x52c	; 0x52c <rdSignalSRAM>
		wrSignal(); // counters increment by one and screen updates.
 57e:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
	
	DC_HIGH;
	writeIndex(0x22); // ensure writing to screenbuffer
	setIOtoInput(); // Set D0-D15 to input so it doesn't interfere with SRAM to Screen lines
	
	for(unsigned long int i = 0; i < (pixels); i++){
 582:	8f ef       	ldi	r24, 0xFF	; 255
 584:	c8 1a       	sub	r12, r24
 586:	d8 0a       	sbc	r13, r24
 588:	e8 0a       	sbc	r14, r24
 58a:	f8 0a       	sbc	r15, r24
 58c:	c1 14       	cp	r12, r1
 58e:	8c e2       	ldi	r24, 0x2C	; 44
 590:	d8 06       	cpc	r13, r24
 592:	81 e0       	ldi	r24, 0x01	; 1
 594:	e8 06       	cpc	r14, r24
 596:	f1 04       	cpc	r15, r1
 598:	80 f3       	brcs	.-32     	; 0x57a <readSRAM+0x38>
		rdSignalSRAM(); // SRAM OE goes LOW-HIGH reading the SRAM values on the address specified by the counters to the screen.
		wrSignal(); // counters increment by one and screen updates.
	}
	
	CS_HIGH; // deselect screen and ram
 59a:	85 b1       	in	r24, 0x05	; 5
 59c:	80 64       	ori	r24, 0x40	; 64
 59e:	85 b9       	out	0x05, r24	; 5
	BLT_EN_LOW; // counters disabled
 5a0:	85 b1       	in	r24, 0x05	; 5
 5a2:	8f 77       	andi	r24, 0x7F	; 127
 5a4:	85 b9       	out	0x05, r24	; 5
}
 5a6:	ff 90       	pop	r15
 5a8:	ef 90       	pop	r14
 5aa:	df 90       	pop	r13
 5ac:	cf 90       	pop	r12
 5ae:	08 95       	ret

000005b0 <writeSRAM>:

void writeSRAM(void){
 5b0:	cf 92       	push	r12
 5b2:	df 92       	push	r13
 5b4:	ef 92       	push	r14
 5b6:	ff 92       	push	r15
	presetCountersToZero(); // Set counters to your desired value (up to 2^20, or about 1 million)
 5b8:	0e 94 60 02 	call	0x4c0	; 0x4c0 <presetCountersToZero>
	CS_LOW; // Select SRAM (and display)
 5bc:	85 b1       	in	r24, 0x05	; 5
 5be:	8f 7b       	andi	r24, 0xBF	; 191
 5c0:	85 b9       	out	0x05, r24	; 5
	BLT_EN_HIGH; // BLT_EN HIGH so the address gets incremented by each write.
 5c2:	85 b1       	in	r24, 0x05	; 5
 5c4:	80 68       	ori	r24, 0x80	; 128
 5c6:	85 b9       	out	0x05, r24	; 5
	writeIndex(0x22); // Set display to write to video ram to avoid it writing to any other register.
 5c8:	82 e2       	ldi	r24, 0x22	; 34
 5ca:	90 e0       	ldi	r25, 0x00	; 0
 5cc:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	// Loops with data to transfer. This is hardcoded for now
	
	DC_HIGH;
 5d0:	8e b1       	in	r24, 0x0e	; 14
 5d2:	80 68       	ori	r24, 0x80	; 128
 5d4:	8e b9       	out	0x0e, r24	; 14
	for(unsigned long int i = 0; i < (pixels/3); i++){
 5d6:	c1 2c       	mov	r12, r1
 5d8:	d1 2c       	mov	r13, r1
 5da:	76 01       	movw	r14, r12
 5dc:	0d c0       	rjmp	.+26     	; 0x5f8 <writeSRAM+0x48>
		loadDataToOutputLines(Red);
 5de:	8f e1       	ldi	r24, 0x1F	; 31
 5e0:	90 e0       	ldi	r25, 0x00	; 0
 5e2:	0e 94 41 02 	call	0x482	; 0x482 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM
 5e6:	0e 94 8b 02 	call	0x516	; 0x516 <wrSignalSRAM>
		wrSignal(); // counters increment by one.
 5ea:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
	BLT_EN_HIGH; // BLT_EN HIGH so the address gets incremented by each write.
	writeIndex(0x22); // Set display to write to video ram to avoid it writing to any other register.
	// Loops with data to transfer. This is hardcoded for now
	
	DC_HIGH;
	for(unsigned long int i = 0; i < (pixels/3); i++){
 5ee:	8f ef       	ldi	r24, 0xFF	; 255
 5f0:	c8 1a       	sub	r12, r24
 5f2:	d8 0a       	sbc	r13, r24
 5f4:	e8 0a       	sbc	r14, r24
 5f6:	f8 0a       	sbc	r15, r24
 5f8:	c1 14       	cp	r12, r1
 5fa:	84 e6       	ldi	r24, 0x64	; 100
 5fc:	d8 06       	cpc	r13, r24
 5fe:	e1 04       	cpc	r14, r1
 600:	f1 04       	cpc	r15, r1
 602:	68 f3       	brcs	.-38     	; 0x5de <writeSRAM+0x2e>
 604:	c1 2c       	mov	r12, r1
 606:	d1 2c       	mov	r13, r1
 608:	76 01       	movw	r14, r12
 60a:	0d c0       	rjmp	.+26     	; 0x626 <writeSRAM+0x76>
		loadDataToOutputLines(Red);
		wrSignalSRAM(); // WriteEnable to SRAM
		wrSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Green);
 60c:	80 ee       	ldi	r24, 0xE0	; 224
 60e:	97 e0       	ldi	r25, 0x07	; 7
 610:	0e 94 41 02 	call	0x482	; 0x482 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM
 614:	0e 94 8b 02 	call	0x516	; 0x516 <wrSignalSRAM>
		wrSignal(); // counters increment by one.
 618:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Red);
		wrSignalSRAM(); // WriteEnable to SRAM
		wrSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
 61c:	8f ef       	ldi	r24, 0xFF	; 255
 61e:	c8 1a       	sub	r12, r24
 620:	d8 0a       	sbc	r13, r24
 622:	e8 0a       	sbc	r14, r24
 624:	f8 0a       	sbc	r15, r24
 626:	c1 14       	cp	r12, r1
 628:	84 e6       	ldi	r24, 0x64	; 100
 62a:	d8 06       	cpc	r13, r24
 62c:	e1 04       	cpc	r14, r1
 62e:	f1 04       	cpc	r15, r1
 630:	68 f3       	brcs	.-38     	; 0x60c <writeSRAM+0x5c>
 632:	c1 2c       	mov	r12, r1
 634:	d1 2c       	mov	r13, r1
 636:	76 01       	movw	r14, r12
 638:	0d c0       	rjmp	.+26     	; 0x654 <writeSRAM+0xa4>
		loadDataToOutputLines(Green);
		wrSignalSRAM(); // WriteEnable to SRAM
		wrSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Blue);
 63a:	80 e0       	ldi	r24, 0x00	; 0
 63c:	98 ef       	ldi	r25, 0xF8	; 248
 63e:	0e 94 41 02 	call	0x482	; 0x482 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM
 642:	0e 94 8b 02 	call	0x516	; 0x516 <wrSignalSRAM>
		wrSignal(); // counters increment by one.
 646:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Green);
		wrSignalSRAM(); // WriteEnable to SRAM
		wrSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
 64a:	8f ef       	ldi	r24, 0xFF	; 255
 64c:	c8 1a       	sub	r12, r24
 64e:	d8 0a       	sbc	r13, r24
 650:	e8 0a       	sbc	r14, r24
 652:	f8 0a       	sbc	r15, r24
 654:	c1 14       	cp	r12, r1
 656:	84 e6       	ldi	r24, 0x64	; 100
 658:	d8 06       	cpc	r13, r24
 65a:	e1 04       	cpc	r14, r1
 65c:	f1 04       	cpc	r15, r1
 65e:	68 f3       	brcs	.-38     	; 0x63a <writeSRAM+0x8a>
		loadDataToOutputLines(Blue);
		wrSignalSRAM(); // WriteEnable to SRAM
		wrSignal(); // counters increment by one.
	}
	
	CS_HIGH; // deselect LCD and SRAM
 660:	85 b1       	in	r24, 0x05	; 5
 662:	80 64       	ori	r24, 0x40	; 64
 664:	85 b9       	out	0x05, r24	; 5
	BLT_EN_LOW;
 666:	85 b1       	in	r24, 0x05	; 5
 668:	8f 77       	andi	r24, 0x7F	; 127
 66a:	85 b9       	out	0x05, r24	; 5
}
 66c:	ff 90       	pop	r15
 66e:	ef 90       	pop	r14
 670:	df 90       	pop	r13
 672:	cf 90       	pop	r12
 674:	08 95       	ret

00000676 <main>:
int main(void)
{	
	// Startup sequence
	
	// Init counters:
	DDRE |= (1 << LOAD); // Setting LOAD to output;
 676:	8d b1       	in	r24, 0x0d	; 13
 678:	88 60       	ori	r24, 0x08	; 8
 67a:	8d b9       	out	0x0d, r24	; 13
	LOAD_HIGH; // Setting LOAD to high (disabled)
 67c:	8e b1       	in	r24, 0x0e	; 14
 67e:	88 60       	ori	r24, 0x08	; 8
 680:	8e b9       	out	0x0e, r24	; 14
	
	DDRB |= (1 << PB7); // Setting BLT_EN to output;
 682:	84 b1       	in	r24, 0x04	; 4
 684:	80 68       	ori	r24, 0x80	; 128
 686:	84 b9       	out	0x04, r24	; 4
	BLT_EN_LOW; // Setting BLT_EN to low.
 688:	85 b1       	in	r24, 0x05	; 5
 68a:	8f 77       	andi	r24, 0x7F	; 127
 68c:	85 b9       	out	0x05, r24	; 5
	
	// Init IO and LCD:
	// Setting CS, DC, RD, WR to output.
	DDRB |= (1 << CS);
 68e:	84 b1       	in	r24, 0x04	; 4
 690:	80 64       	ori	r24, 0x40	; 64
 692:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << BL_PWM);
 694:	84 b1       	in	r24, 0x04	; 4
 696:	80 62       	ori	r24, 0x20	; 32
 698:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << WR_BLT_CLK);
 69a:	84 b1       	in	r24, 0x04	; 4
 69c:	80 61       	ori	r24, 0x10	; 16
 69e:	84 b9       	out	0x04, r24	; 4
	DDRE |= (1 << RD);
 6a0:	8d b1       	in	r24, 0x0d	; 13
 6a2:	80 64       	ori	r24, 0x40	; 64
 6a4:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << DC);
 6a6:	8d b1       	in	r24, 0x0d	; 13
 6a8:	80 68       	ori	r24, 0x80	; 128
 6aa:	8d b9       	out	0x0d, r24	; 13
	// All are set to High (disabled). DC doesn't matter.
	PORTB |= (1 << CS);
 6ac:	85 b1       	in	r24, 0x05	; 5
 6ae:	80 64       	ori	r24, 0x40	; 64
 6b0:	85 b9       	out	0x05, r24	; 5
	//PORTB |= (1 << BL_PWM); // Not enabled rn as it turns off display. Fix this later.
	PORTB |= (1 << WR_BLT_CLK);
 6b2:	85 b1       	in	r24, 0x05	; 5
 6b4:	80 61       	ori	r24, 0x10	; 16
 6b6:	85 b9       	out	0x05, r24	; 5
	PORTE |= (1 << RD);
 6b8:	8e b1       	in	r24, 0x0e	; 14
 6ba:	80 64       	ori	r24, 0x40	; 64
 6bc:	8e b9       	out	0x0e, r24	; 14
	PORTE |= (1 << DC);
 6be:	8e b1       	in	r24, 0x0e	; 14
 6c0:	80 68       	ori	r24, 0x80	; 128
 6c2:	8e b9       	out	0x0e, r24	; 14
	// Set IO to output
	DDRA = 0xFF; // D0 - D7
 6c4:	8f ef       	ldi	r24, 0xFF	; 255
 6c6:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF; // D8 - D15
 6c8:	87 b9       	out	0x07, r24	; 7
	
    initUART(); // initialize the UART
 6ca:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <initUART>
	initHY32D(); // initialize HY32D screen
 6ce:	0e 94 34 01 	call	0x268	; 0x268 <initHY32D>
	sei(); //Enable global interrupt
 6d2:	78 94       	sei
	systemCheck();
 6d4:	0e 94 1b 04 	call	0x836	; 0x836 <systemCheck>
	startupMessage();
 6d8:	0e 94 4e 04 	call	0x89c	; 0x89c <startupMessage>
 6dc:	ff cf       	rjmp	.-2      	; 0x6dc <main+0x66>

000006de <__vector_13>:
		- INFO:Utviklingen vil skje på egen maskinvareplattform.
		*/
    }
}

ISR(USART0_RX_vect){
 6de:	1f 92       	push	r1
 6e0:	0f 92       	push	r0
 6e2:	0f b6       	in	r0, 0x3f	; 63
 6e4:	0f 92       	push	r0
 6e6:	11 24       	eor	r1, r1
 6e8:	2f 93       	push	r18
 6ea:	3f 93       	push	r19
 6ec:	4f 93       	push	r20
 6ee:	5f 93       	push	r21
 6f0:	6f 93       	push	r22
 6f2:	7f 93       	push	r23
 6f4:	8f 93       	push	r24
 6f6:	9f 93       	push	r25
 6f8:	af 93       	push	r26
 6fa:	bf 93       	push	r27
 6fc:	cf 93       	push	r28
 6fe:	ef 93       	push	r30
 700:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	uint8_t receivedByte = UARTBuffer; // local temporary variable for received byte
 702:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 706:	cc 23       	and	r28, r28
 708:	39 f1       	breq	.+78     	; 0x758 <__vector_13+0x7a>
		if (receivedByte == 45) { // that's the '-' sign.
 70a:	cd 32       	cpi	r28, 0x2D	; 45
 70c:	31 f4       	brne	.+12     	; 0x71a <__vector_13+0x3c>
			remoteEcho = ~remoteEcho;
 70e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 712:	80 95       	com	r24
 714:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 718:	1f c0       	rjmp	.+62     	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 's'){
 71a:	c3 37       	cpi	r28, 0x73	; 115
 71c:	19 f4       	brne	.+6      	; 0x724 <__vector_13+0x46>
			systemCheck();
 71e:	0e 94 1b 04 	call	0x836	; 0x836 <systemCheck>
 722:	1a c0       	rjmp	.+52     	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 'l'){
 724:	cc 36       	cpi	r28, 0x6C	; 108
 726:	19 f4       	brne	.+6      	; 0x72e <__vector_13+0x50>
			lcdStatusRead();
 728:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <lcdStatusRead>
 72c:	15 c0       	rjmp	.+42     	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 'b'){
 72e:	c2 36       	cpi	r28, 0x62	; 98
 730:	29 f4       	brne	.+10     	; 0x73c <__vector_13+0x5e>
			fillScreen(Blue);
 732:	80 e0       	ldi	r24, 0x00	; 0
 734:	98 ef       	ldi	r25, 0xF8	; 248
 736:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 73a:	0e c0       	rjmp	.+28     	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 'w'){
 73c:	c7 37       	cpi	r28, 0x77	; 119
 73e:	19 f4       	brne	.+6      	; 0x746 <__vector_13+0x68>
			writeSRAM();
 740:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <writeSRAM>
 744:	09 c0       	rjmp	.+18     	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 'r'){
 746:	c2 37       	cpi	r28, 0x72	; 114
 748:	19 f4       	brne	.+6      	; 0x750 <__vector_13+0x72>
			readSRAM();
 74a:	0e 94 a1 02 	call	0x542	; 0x542 <readSRAM>
 74e:	04 c0       	rjmp	.+8      	; 0x758 <__vector_13+0x7a>
		}else if(receivedByte == 'T'){
 750:	c4 35       	cpi	r28, 0x54	; 84
 752:	11 f4       	brne	.+4      	; 0x758 <__vector_13+0x7a>
			screenTest();
 754:	0e 94 8b 01 	call	0x316	; 0x316 <screenTest>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 758:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 75c:	88 23       	and	r24, r24
 75e:	69 f0       	breq	.+26     	; 0x77a <__vector_13+0x9c>
 760:	c0 32       	cpi	r28, 0x20	; 32
 762:	40 f4       	brcc	.+16     	; 0x774 <__vector_13+0x96>
 764:	c7 30       	cpi	r28, 0x07	; 7
 766:	31 f0       	breq	.+12     	; 0x774 <__vector_13+0x96>
 768:	cd 30       	cpi	r28, 0x0D	; 13
 76a:	21 f0       	breq	.+8      	; 0x774 <__vector_13+0x96>
 76c:	ca 30       	cpi	r28, 0x0A	; 10
 76e:	11 f0       	breq	.+4      	; 0x774 <__vector_13+0x96>
 770:	c8 30       	cpi	r28, 0x08	; 8
 772:	19 f4       	brne	.+6      	; 0x77a <__vector_13+0x9c>
		transmitUART(receivedByte);
 774:	8c 2f       	mov	r24, r28
 776:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	}
 77a:	ff 91       	pop	r31
 77c:	ef 91       	pop	r30
 77e:	cf 91       	pop	r28
 780:	bf 91       	pop	r27
 782:	af 91       	pop	r26
 784:	9f 91       	pop	r25
 786:	8f 91       	pop	r24
 788:	7f 91       	pop	r23
 78a:	6f 91       	pop	r22
 78c:	5f 91       	pop	r21
 78e:	4f 91       	pop	r20
 790:	3f 91       	pop	r19
 792:	2f 91       	pop	r18
 794:	0f 90       	pop	r0
 796:	0f be       	out	0x3f, r0	; 63
 798:	0f 90       	pop	r0
 79a:	1f 90       	pop	r1
 79c:	18 95       	reti

0000079e <toHex>:
 */ 

#include "stdint.h"

uint8_t toHex(uint8_t number) {
	uint8_t num = '0'+number;
 79e:	80 5d       	subi	r24, 0xD0	; 208
	if(num < 58){
 7a0:	8a 33       	cpi	r24, 0x3A	; 58
 7a2:	c0 f0       	brcs	.+48     	; 0x7d4 <toHex+0x36>
		return num;
	}
	else if(num == 58){
 7a4:	8a 33       	cpi	r24, 0x3A	; 58
 7a6:	59 f0       	breq	.+22     	; 0x7be <toHex+0x20>
		return 'A';
	}
	else if(num == 59){
 7a8:	8b 33       	cpi	r24, 0x3B	; 59
 7aa:	59 f0       	breq	.+22     	; 0x7c2 <toHex+0x24>
		return 'B';
	}
	else if(num == 60){
 7ac:	8c 33       	cpi	r24, 0x3C	; 60
 7ae:	59 f0       	breq	.+22     	; 0x7c6 <toHex+0x28>
		return 'C';
	}
	else if(num == 61){
 7b0:	8d 33       	cpi	r24, 0x3D	; 61
 7b2:	59 f0       	breq	.+22     	; 0x7ca <toHex+0x2c>
		return 'D';
	}
	else if(num == 62){
 7b4:	8e 33       	cpi	r24, 0x3E	; 62
 7b6:	59 f0       	breq	.+22     	; 0x7ce <toHex+0x30>
		return 'E';
	}
	else if(num == 63){
 7b8:	8f 33       	cpi	r24, 0x3F	; 63
 7ba:	59 f0       	breq	.+22     	; 0x7d2 <toHex+0x34>
		return 'F';
	}
 7bc:	08 95       	ret
	uint8_t num = '0'+number;
	if(num < 58){
		return num;
	}
	else if(num == 58){
		return 'A';
 7be:	81 e4       	ldi	r24, 0x41	; 65
 7c0:	08 95       	ret
	}
	else if(num == 59){
		return 'B';
 7c2:	82 e4       	ldi	r24, 0x42	; 66
 7c4:	08 95       	ret
	}
	else if(num == 60){
		return 'C';
 7c6:	83 e4       	ldi	r24, 0x43	; 67
 7c8:	08 95       	ret
	}
	else if(num == 61){
		return 'D';
 7ca:	84 e4       	ldi	r24, 0x44	; 68
 7cc:	08 95       	ret
	}
	else if(num == 62){
		return 'E';
 7ce:	85 e4       	ldi	r24, 0x45	; 69
 7d0:	08 95       	ret
	}
	else if(num == 63){
		return 'F';
 7d2:	86 e4       	ldi	r24, 0x46	; 70
	}
 7d4:	08 95       	ret

000007d6 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 7d6:	8f e2       	ldi	r24, 0x2F	; 47
 7d8:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 7dc:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 7e0:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 7e4:	88 e9       	ldi	r24, 0x98	; 152
 7e6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 7ea:	86 e0       	ldi	r24, 0x06	; 6
 7ec:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 7f0:	08 95       	ret

000007f2 <puttyCompatibleCheck>:
}

uint8_t puttyCompatibleCheck(uint8_t byte){
	if((byte > 31) || (byte == Bell) || (byte == CR) || (byte == LF) || (byte == backspace)){
 7f2:	80 32       	cpi	r24, 0x20	; 32
 7f4:	48 f4       	brcc	.+18     	; 0x808 <puttyCompatibleCheck+0x16>
 7f6:	87 30       	cpi	r24, 0x07	; 7
 7f8:	39 f0       	breq	.+14     	; 0x808 <puttyCompatibleCheck+0x16>
 7fa:	8d 30       	cpi	r24, 0x0D	; 13
 7fc:	29 f0       	breq	.+10     	; 0x808 <puttyCompatibleCheck+0x16>
 7fe:	8a 30       	cpi	r24, 0x0A	; 10
 800:	19 f0       	breq	.+6      	; 0x808 <puttyCompatibleCheck+0x16>
 802:	88 30       	cpi	r24, 0x08	; 8
 804:	09 f0       	breq	.+2      	; 0x808 <puttyCompatibleCheck+0x16>
		return byte;
		}else{
		return (uint8_t)64;
 806:	80 e4       	ldi	r24, 0x40	; 64
	}
}
 808:	08 95       	ret

0000080a <transmitUART>:

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 80a:	20 e0       	ldi	r18, 0x00	; 0
 80c:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 80e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 812:	95 ff       	sbrs	r25, 5
 814:	07 c0       	rjmp	.+14     	; 0x824 <transmitUART+0x1a>
			UARTBuffer = puttyCompatibleCheck(data);
 816:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <puttyCompatibleCheck>
 81a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	90 e0       	ldi	r25, 0x00	; 0
 822:	08 95       	ret
			}else{
			timeout++;
 824:	2f 5f       	subi	r18, 0xFF	; 255
 826:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 828:	29 3e       	cpi	r18, 0xE9	; 233
 82a:	93 e0       	ldi	r25, 0x03	; 3
 82c:	39 07       	cpc	r19, r25
 82e:	7c f3       	brlt	.-34     	; 0x80e <transmitUART+0x4>
				return 0;
 830:	80 e0       	ldi	r24, 0x00	; 0
 832:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 834:	08 95       	ret

00000836 <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 836:	8d e0       	ldi	r24, 0x0D	; 13
 838:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('-');
 83c:	8d e2       	ldi	r24, 0x2D	; 45
 83e:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART(CR);
 842:	8d e0       	ldi	r24, 0x0D	; 13
 844:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('S');	transmitUART('y'); 	transmitUART('s'); 	transmitUART('t'); 	transmitUART('e');
 848:	83 e5       	ldi	r24, 0x53	; 83
 84a:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 84e:	89 e7       	ldi	r24, 0x79	; 121
 850:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 854:	83 e7       	ldi	r24, 0x73	; 115
 856:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 85a:	84 e7       	ldi	r24, 0x74	; 116
 85c:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 860:	85 e6       	ldi	r24, 0x65	; 101
 862:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('m');	transmitUART(' '); 	transmitUART('c'); 	transmitUART('h'); 	transmitUART('e');
 866:	8d e6       	ldi	r24, 0x6D	; 109
 868:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 86c:	80 e2       	ldi	r24, 0x20	; 32
 86e:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 872:	83 e6       	ldi	r24, 0x63	; 99
 874:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 878:	88 e6       	ldi	r24, 0x68	; 104
 87a:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 87e:	85 e6       	ldi	r24, 0x65	; 101
 880:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('c');	transmitUART('k'); 	transmitUART(':');
 884:	83 e6       	ldi	r24, 0x63	; 99
 886:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 88a:	8b e6       	ldi	r24, 0x6B	; 107
 88c:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 890:	8a e3       	ldi	r24, 0x3A	; 58
 892:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	lcdStatusRead();
 896:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <lcdStatusRead>
 89a:	08 95       	ret

0000089c <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART('B');	transmitUART('l'); 	transmitUART('i'); 	transmitUART('t'); 	transmitUART('t');
 89c:	82 e4       	ldi	r24, 0x42	; 66
 89e:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8a2:	8c e6       	ldi	r24, 0x6C	; 108
 8a4:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8a8:	89 e6       	ldi	r24, 0x69	; 105
 8aa:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8ae:	84 e7       	ldi	r24, 0x74	; 116
 8b0:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8b4:	84 e7       	ldi	r24, 0x74	; 116
 8b6:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('e');	transmitUART('r'); 	transmitUART(' '); 	transmitUART('r'); 	transmitUART('e');
 8ba:	85 e6       	ldi	r24, 0x65	; 101
 8bc:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8c0:	82 e7       	ldi	r24, 0x72	; 114
 8c2:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8c6:	80 e2       	ldi	r24, 0x20	; 32
 8c8:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8cc:	82 e7       	ldi	r24, 0x72	; 114
 8ce:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8d2:	85 e6       	ldi	r24, 0x65	; 101
 8d4:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART('a');	transmitUART('d'); 	transmitUART('y');
 8d8:	81 e6       	ldi	r24, 0x61	; 97
 8da:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8de:	84 e6       	ldi	r24, 0x64	; 100
 8e0:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8e4:	89 e7       	ldi	r24, 0x79	; 121
 8e6:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
	transmitUART(CR);
 8ea:	8d e0       	ldi	r24, 0x0D	; 13
 8ec:	0e 94 05 04 	call	0x80a	; 0x80a <transmitUART>
 8f0:	08 95       	ret

000008f2 <_exit>:
 8f2:	f8 94       	cli

000008f4 <__stop_program>:
 8f4:	ff cf       	rjmp	.-2      	; 0x8f4 <__stop_program>
