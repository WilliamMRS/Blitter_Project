
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000071a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006a6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  0000071a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000071a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000074c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000128  00000000  00000000  0000078c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000018bf  00000000  00000000  000008b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b54  00000000  00000000  00002173  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bf2  00000000  00000000  00002cc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000270  00000000  00000000  000038bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000064f  00000000  00000000  00003b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008b9  00000000  00000000  0000417b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00004a34  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 4c 02 	jmp	0x498	; 0x498 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 44 02 	call	0x488	; 0x488 <main>
  7c:	0c 94 51 03 	jmp	0x6a2	; 0x6a2 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DC_HIGH;
	WR_HIGH;
	data = readDataLines();
	transmitUART((char)data);
	return data;
}
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <setIOtoOutput>:
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	81 b9       	out	0x01, r24	; 1
  e8:	87 b9       	out	0x07, r24	; 7
  ea:	08 95       	ret

000000ec <setIOtoInput>:
  ec:	11 b8       	out	0x01, r1	; 1
  ee:	17 b8       	out	0x07, r1	; 7
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	8f e3       	ldi	r24, 0x3F	; 63
  f4:	92 e0       	ldi	r25, 0x02	; 2
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <setIOtoInput+0xa>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <setIOtoInput+0x14>
 100:	00 00       	nop
 102:	08 95       	ret

00000104 <fillScreen>:
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ef 92       	push	r14
 10a:	ff 92       	push	r15
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	ec 01       	movw	r28, r24
 112:	85 b1       	in	r24, 0x05	; 5
 114:	8f 7b       	andi	r24, 0xBF	; 191
 116:	85 b9       	out	0x05, r24	; 5
 118:	82 e2       	ldi	r24, 0x22	; 34
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	c1 2c       	mov	r12, r1
 122:	d1 2c       	mov	r13, r1
 124:	76 01       	movw	r14, r12
 126:	08 c0       	rjmp	.+16     	; 0x138 <fillScreen+0x34>
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 12e:	8f ef       	ldi	r24, 0xFF	; 255
 130:	c8 1a       	sub	r12, r24
 132:	d8 0a       	sbc	r13, r24
 134:	e8 0a       	sbc	r14, r24
 136:	f8 0a       	sbc	r15, r24
 138:	c1 14       	cp	r12, r1
 13a:	8c e2       	ldi	r24, 0x2C	; 44
 13c:	d8 06       	cpc	r13, r24
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	e8 06       	cpc	r14, r24
 142:	f1 04       	cpc	r15, r1
 144:	88 f3       	brcs	.-30     	; 0x128 <fillScreen+0x24>
 146:	85 b1       	in	r24, 0x05	; 5
 148:	80 64       	ori	r24, 0x40	; 64
 14a:	85 b9       	out	0x05, r24	; 5
 14c:	df 91       	pop	r29
 14e:	cf 91       	pop	r28
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

0000015a <colorTest>:
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	85 b1       	in	r24, 0x05	; 5
 160:	8f 7b       	andi	r24, 0xBF	; 191
 162:	85 b9       	out	0x05, r24	; 5
 164:	82 e2       	ldi	r24, 0x22	; 34
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 16c:	c0 e0       	ldi	r28, 0x00	; 0
 16e:	d0 e0       	ldi	r29, 0x00	; 0
 170:	05 c0       	rjmp	.+10     	; 0x17c <colorTest+0x22>
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	9f ef       	ldi	r25, 0xFF	; 255
 176:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 17a:	21 96       	adiw	r28, 0x01	; 1
 17c:	c1 15       	cp	r28, r1
 17e:	8e e1       	ldi	r24, 0x1E	; 30
 180:	d8 07       	cpc	r29, r24
 182:	bc f3       	brlt	.-18     	; 0x172 <colorTest+0x18>
 184:	c0 e0       	ldi	r28, 0x00	; 0
 186:	d0 e0       	ldi	r29, 0x00	; 0
 188:	05 c0       	rjmp	.+10     	; 0x194 <colorTest+0x3a>
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 192:	21 96       	adiw	r28, 0x01	; 1
 194:	c1 15       	cp	r28, r1
 196:	8e e1       	ldi	r24, 0x1E	; 30
 198:	d8 07       	cpc	r29, r24
 19a:	bc f3       	brlt	.-18     	; 0x18a <colorTest+0x30>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <colorTest+0x52>
 1a2:	8e ed       	ldi	r24, 0xDE	; 222
 1a4:	97 ef       	ldi	r25, 0xF7	; 247
 1a6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1aa:	21 96       	adiw	r28, 0x01	; 1
 1ac:	c1 15       	cp	r28, r1
 1ae:	8e e1       	ldi	r24, 0x1E	; 30
 1b0:	d8 07       	cpc	r29, r24
 1b2:	bc f3       	brlt	.-18     	; 0x1a2 <colorTest+0x48>
 1b4:	c0 e0       	ldi	r28, 0x00	; 0
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <colorTest+0x6a>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	98 ef       	ldi	r25, 0xF8	; 248
 1be:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1c2:	21 96       	adiw	r28, 0x01	; 1
 1c4:	c1 15       	cp	r28, r1
 1c6:	8e e1       	ldi	r24, 0x1E	; 30
 1c8:	d8 07       	cpc	r29, r24
 1ca:	bc f3       	brlt	.-18     	; 0x1ba <colorTest+0x60>
 1cc:	c0 e0       	ldi	r28, 0x00	; 0
 1ce:	d0 e0       	ldi	r29, 0x00	; 0
 1d0:	05 c0       	rjmp	.+10     	; 0x1dc <colorTest+0x82>
 1d2:	87 ee       	ldi	r24, 0xE7	; 231
 1d4:	9c ef       	ldi	r25, 0xFC	; 252
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	c1 15       	cp	r28, r1
 1de:	8e e1       	ldi	r24, 0x1E	; 30
 1e0:	d8 07       	cpc	r29, r24
 1e2:	bc f3       	brlt	.-18     	; 0x1d2 <colorTest+0x78>
 1e4:	c0 e0       	ldi	r28, 0x00	; 0
 1e6:	d0 e0       	ldi	r29, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <colorTest+0x9a>
 1ea:	8f e1       	ldi	r24, 0x1F	; 31
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1f2:	21 96       	adiw	r28, 0x01	; 1
 1f4:	c1 15       	cp	r28, r1
 1f6:	8e e1       	ldi	r24, 0x1E	; 30
 1f8:	d8 07       	cpc	r29, r24
 1fa:	bc f3       	brlt	.-18     	; 0x1ea <colorTest+0x90>
 1fc:	c0 e0       	ldi	r28, 0x00	; 0
 1fe:	d0 e0       	ldi	r29, 0x00	; 0
 200:	05 c0       	rjmp	.+10     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
 202:	8f e1       	ldi	r24, 0x1F	; 31
 204:	98 ef       	ldi	r25, 0xF8	; 248
 206:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	c1 15       	cp	r28, r1
 20e:	8e e1       	ldi	r24, 0x1E	; 30
 210:	d8 07       	cpc	r29, r24
 212:	bc f3       	brlt	.-18     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
 214:	c0 e0       	ldi	r28, 0x00	; 0
 216:	d0 e0       	ldi	r29, 0x00	; 0
 218:	05 c0       	rjmp	.+10     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	97 e0       	ldi	r25, 0x07	; 7
 21e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 222:	21 96       	adiw	r28, 0x01	; 1
 224:	c1 15       	cp	r28, r1
 226:	8e e1       	ldi	r24, 0x1E	; 30
 228:	d8 07       	cpc	r29, r24
 22a:	bc f3       	brlt	.-18     	; 0x21a <__EEPROM_REGION_LENGTH__+0x1a>
 22c:	c0 e0       	ldi	r28, 0x00	; 0
 22e:	d0 e0       	ldi	r29, 0x00	; 0
 230:	05 c0       	rjmp	.+10     	; 0x23c <__EEPROM_REGION_LENGTH__+0x3c>
 232:	80 ee       	ldi	r24, 0xE0	; 224
 234:	9f ef       	ldi	r25, 0xFF	; 255
 236:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 23a:	21 96       	adiw	r28, 0x01	; 1
 23c:	c1 15       	cp	r28, r1
 23e:	8e e1       	ldi	r24, 0x1E	; 30
 240:	d8 07       	cpc	r29, r24
 242:	bc f3       	brlt	.-18     	; 0x232 <__EEPROM_REGION_LENGTH__+0x32>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 24a:	8f e1       	ldi	r24, 0x1F	; 31
 24c:	95 e0       	ldi	r25, 0x05	; 5
 24e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 252:	21 96       	adiw	r28, 0x01	; 1
 254:	c1 15       	cp	r28, r1
 256:	8e e1       	ldi	r24, 0x1E	; 30
 258:	d8 07       	cpc	r29, r24
 25a:	bc f3       	brlt	.-18     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 25c:	85 b1       	in	r24, 0x05	; 5
 25e:	80 64       	ori	r24, 0x40	; 64
 260:	85 b9       	out	0x05, r24	; 5
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <initHY32D>:
 268:	84 b1       	in	r24, 0x04	; 4
 26a:	80 64       	ori	r24, 0x40	; 64
 26c:	84 b9       	out	0x04, r24	; 4
 26e:	84 b1       	in	r24, 0x04	; 4
 270:	80 62       	ori	r24, 0x20	; 32
 272:	84 b9       	out	0x04, r24	; 4
 274:	84 b1       	in	r24, 0x04	; 4
 276:	80 61       	ori	r24, 0x10	; 16
 278:	84 b9       	out	0x04, r24	; 4
 27a:	8d b1       	in	r24, 0x0d	; 13
 27c:	80 64       	ori	r24, 0x40	; 64
 27e:	8d b9       	out	0x0d, r24	; 13
 280:	8d b1       	in	r24, 0x0d	; 13
 282:	80 68       	ori	r24, 0x80	; 128
 284:	8d b9       	out	0x0d, r24	; 13
 286:	85 b1       	in	r24, 0x05	; 5
 288:	80 64       	ori	r24, 0x40	; 64
 28a:	85 b9       	out	0x05, r24	; 5
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	80 61       	ori	r24, 0x10	; 16
 290:	85 b9       	out	0x05, r24	; 5
 292:	8e b1       	in	r24, 0x0e	; 14
 294:	80 64       	ori	r24, 0x40	; 64
 296:	8e b9       	out	0x0e, r24	; 14
 298:	8e b1       	in	r24, 0x0e	; 14
 29a:	80 68       	ori	r24, 0x80	; 128
 29c:	8e b9       	out	0x0e, r24	; 14
 29e:	8f ef       	ldi	r24, 0xFF	; 255
 2a0:	81 b9       	out	0x01, r24	; 1
 2a2:	87 b9       	out	0x07, r24	; 7
 2a4:	2f ef       	ldi	r18, 0xFF	; 255
 2a6:	8f e3       	ldi	r24, 0x3F	; 63
 2a8:	92 e0       	ldi	r25, 0x02	; 2
 2aa:	21 50       	subi	r18, 0x01	; 1
 2ac:	80 40       	sbci	r24, 0x00	; 0
 2ae:	90 40       	sbci	r25, 0x00	; 0
 2b0:	e1 f7       	brne	.-8      	; 0x2aa <initHY32D+0x42>
 2b2:	00 c0       	rjmp	.+0      	; 0x2b4 <initHY32D+0x4c>
 2b4:	00 00       	nop
 2b6:	85 b1       	in	r24, 0x05	; 5
 2b8:	81 60       	ori	r24, 0x01	; 1
 2ba:	85 b9       	out	0x05, r24	; 5
 2bc:	8f ef       	ldi	r24, 0xFF	; 255
 2be:	93 e2       	ldi	r25, 0x23	; 35
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <initHY32D+0x58>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <initHY32D+0x5e>
 2c6:	00 00       	nop
 2c8:	85 b1       	in	r24, 0x05	; 5
 2ca:	8e 7f       	andi	r24, 0xFE	; 254
 2cc:	85 b9       	out	0x05, r24	; 5
 2ce:	8f ef       	ldi	r24, 0xFF	; 255
 2d0:	9b e6       	ldi	r25, 0x6B	; 107
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <initHY32D+0x6a>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <initHY32D+0x70>
 2d8:	00 00       	nop
 2da:	85 b1       	in	r24, 0x05	; 5
 2dc:	81 60       	ori	r24, 0x01	; 1
 2de:	85 b9       	out	0x05, r24	; 5
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	9b e6       	ldi	r25, 0x6B	; 107
 2e4:	01 97       	sbiw	r24, 0x01	; 1
 2e6:	f1 f7       	brne	.-4      	; 0x2e4 <initHY32D+0x7c>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <initHY32D+0x82>
 2ea:	00 00       	nop
 2ec:	61 e2       	ldi	r22, 0x21	; 33
 2ee:	70 e0       	ldi	r23, 0x00	; 0
 2f0:	87 e0       	ldi	r24, 0x07	; 7
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	70 e0       	ldi	r23, 0x00	; 0
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 304:	63 e2       	ldi	r22, 0x23	; 35
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	87 e0       	ldi	r24, 0x07	; 7
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	70 e0       	ldi	r23, 0x00	; 0
 314:	80 e1       	ldi	r24, 0x10	; 16
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	97 ed       	ldi	r25, 0xD7	; 215
 320:	01 97       	sbiw	r24, 0x01	; 1
 322:	f1 f7       	brne	.-4      	; 0x320 <initHY32D+0xb8>
 324:	00 c0       	rjmp	.+0      	; 0x326 <initHY32D+0xbe>
 326:	00 00       	nop
 328:	63 e3       	ldi	r22, 0x33	; 51
 32a:	70 e0       	ldi	r23, 0x00	; 0
 32c:	87 e0       	ldi	r24, 0x07	; 7
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 334:	60 e3       	ldi	r22, 0x30	; 48
 336:	78 e6       	ldi	r23, 0x68	; 104
 338:	81 e1       	ldi	r24, 0x11	; 17
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	82 e0       	ldi	r24, 0x02	; 2
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 34c:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 350:	08 95       	ret

00000352 <screenTest>:
 352:	85 b1       	in	r24, 0x05	; 5
 354:	8f 7b       	andi	r24, 0xBF	; 191
 356:	85 b9       	out	0x05, r24	; 5
 358:	8f ef       	ldi	r24, 0xFF	; 255
 35a:	9f ef       	ldi	r25, 0xFF	; 255
 35c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 360:	80 e0       	ldi	r24, 0x00	; 0
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 368:	8e ed       	ldi	r24, 0xDE	; 222
 36a:	97 ef       	ldi	r25, 0xF7	; 247
 36c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 370:	8f e1       	ldi	r24, 0x1F	; 31
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 378:	8f e1       	ldi	r24, 0x1F	; 31
 37a:	95 e0       	ldi	r25, 0x05	; 5
 37c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 380:	80 e0       	ldi	r24, 0x00	; 0
 382:	98 ef       	ldi	r25, 0xF8	; 248
 384:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 388:	8f e1       	ldi	r24, 0x1F	; 31
 38a:	98 ef       	ldi	r25, 0xF8	; 248
 38c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 390:	80 ee       	ldi	r24, 0xE0	; 224
 392:	97 e0       	ldi	r25, 0x07	; 7
 394:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 398:	80 ee       	ldi	r24, 0xE0	; 224
 39a:	9f ef       	ldi	r25, 0xFF	; 255
 39c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a0:	8f ef       	ldi	r24, 0xFF	; 255
 3a2:	9f e7       	ldi	r25, 0x7F	; 127
 3a4:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a8:	87 ee       	ldi	r24, 0xE7	; 231
 3aa:	9c ef       	ldi	r25, 0xFC	; 252
 3ac:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3b0:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 3b4:	85 b1       	in	r24, 0x05	; 5
 3b6:	80 64       	ori	r24, 0x40	; 64
 3b8:	85 b9       	out	0x05, r24	; 5
 3ba:	08 95       	ret

000003bc <readDataLines>:
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
 3c0:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
 3c4:	8e b1       	in	r24, 0x0e	; 14
 3c6:	8f 7b       	andi	r24, 0xBF	; 191
 3c8:	8e b9       	out	0x0e, r24	; 14
 3ca:	86 b1       	in	r24, 0x06	; 6
 3cc:	80 b1       	in	r24, 0x00	; 0
 3ce:	c6 b1       	in	r28, 0x06	; 6
 3d0:	d0 e0       	ldi	r29, 0x00	; 0
 3d2:	dc 2f       	mov	r29, r28
 3d4:	cc 27       	eor	r28, r28
 3d6:	80 b1       	in	r24, 0x00	; 0
 3d8:	c8 2b       	or	r28, r24
 3da:	8e b1       	in	r24, 0x0e	; 14
 3dc:	80 64       	ori	r24, 0x40	; 64
 3de:	8e b9       	out	0x0e, r24	; 14
 3e0:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
 3e4:	ce 01       	movw	r24, r28
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	08 95       	ret

000003ec <statusRead>:

void statusRead(void){ // reads SR register
 3ec:	1f 93       	push	r17
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
	unsigned short data;
	CS_LOW;
 3f2:	85 b1       	in	r24, 0x05	; 5
 3f4:	8f 7b       	andi	r24, 0xBF	; 191
 3f6:	85 b9       	out	0x05, r24	; 5
	DC_LOW;
 3f8:	8e b1       	in	r24, 0x0e	; 14
 3fa:	8f 77       	andi	r24, 0x7F	; 127
 3fc:	8e b9       	out	0x0e, r24	; 14
	data = readDataLines();// read data coming through IO lines
 3fe:	0e 94 de 01 	call	0x3bc	; 0x3bc <readDataLines>
 402:	c8 2f       	mov	r28, r24
 404:	d9 2f       	mov	r29, r25
	uint8_t udata = ((data >> 8) & 0xFF);
	uint8_t ldata = (data & 0xFF);
	transmitUART(CR);
 406:	8d e0       	ldi	r24, 0x0D	; 13
 408:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(D);
 40c:	84 e4       	ldi	r24, 0x44	; 68
 40e:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(A);
 412:	81 e4       	ldi	r24, 0x41	; 65
 414:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(T);
 418:	84 e5       	ldi	r24, 0x54	; 84
 41a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(A);
 41e:	81 e4       	ldi	r24, 0x41	; 65
 420:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(_colon);
 424:	8a e3       	ldi	r24, 0x3A	; 58
 426:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(_space);
 42a:	80 e2       	ldi	r24, 0x20	; 32
 42c:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART('0');
 430:	80 e3       	ldi	r24, 0x30	; 48
 432:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(x);
 436:	88 e7       	ldi	r24, 0x78	; 120
 438:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	uint8_t udatauhex = ((udata >> 4) & 0x0F);
	uint8_t udatalhex = (udata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 43c:	1d 2f       	mov	r17, r29
 43e:	1f 70       	andi	r17, 0x0F	; 15
	transmitUART(toHex(udatauhex));
 440:	8d 2f       	mov	r24, r29
 442:	82 95       	swap	r24
 444:	8f 70       	andi	r24, 0x0F	; 15
 446:	0e 94 a9 02 	call	0x552	; 0x552 <toHex>
 44a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(toHex(udatalhex));
 44e:	81 2f       	mov	r24, r17
 450:	0e 94 a9 02 	call	0x552	; 0x552 <toHex>
 454:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	uint8_t ldatauhex = ((ldata >> 4) & 0x0F);
	uint8_t ldatalhex = (ldata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 458:	dc 2f       	mov	r29, r28
 45a:	df 70       	andi	r29, 0x0F	; 15
	transmitUART(toHex(ldatauhex));
 45c:	8c 2f       	mov	r24, r28
 45e:	82 95       	swap	r24
 460:	8f 70       	andi	r24, 0x0F	; 15
 462:	0e 94 a9 02 	call	0x552	; 0x552 <toHex>
 466:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(toHex(ldatalhex));
 46a:	8d 2f       	mov	r24, r29
 46c:	0e 94 a9 02 	call	0x552	; 0x552 <toHex>
 470:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(CR);
 474:	8d e0       	ldi	r24, 0x0D	; 13
 476:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	CS_HIGH;
 47a:	85 b1       	in	r24, 0x05	; 5
 47c:	80 64       	ori	r24, 0x40	; 64
 47e:	85 b9       	out	0x05, r24	; 5
 480:	df 91       	pop	r29
 482:	cf 91       	pop	r28
 484:	1f 91       	pop	r17
 486:	08 95       	ret

00000488 <main>:
uint8_t remoteEcho = 0;

int main(void)
{	
	// Startup sequence
    initUART(); // initialize the UART
 488:	0e 94 c5 02 	call	0x58a	; 0x58a <initUART>
	initHY32D(); // initialize HY32D screen
 48c:	0e 94 34 01 	call	0x268	; 0x268 <initHY32D>
	sei(); //Enable global interrupt
 490:	78 94       	sei
	startupMessage();
 492:	0e 94 23 03 	call	0x646	; 0x646 <startupMessage>
 496:	ff cf       	rjmp	.-2      	; 0x496 <main+0xe>

00000498 <__vector_13>:
		- INFO:Utviklingen vil skje på egen maskinvareplattform.
		*/
    }
}

ISR(USART0_RX_vect){
 498:	1f 92       	push	r1
 49a:	0f 92       	push	r0
 49c:	0f b6       	in	r0, 0x3f	; 63
 49e:	0f 92       	push	r0
 4a0:	11 24       	eor	r1, r1
 4a2:	2f 93       	push	r18
 4a4:	3f 93       	push	r19
 4a6:	4f 93       	push	r20
 4a8:	5f 93       	push	r21
 4aa:	6f 93       	push	r22
 4ac:	7f 93       	push	r23
 4ae:	8f 93       	push	r24
 4b0:	9f 93       	push	r25
 4b2:	af 93       	push	r26
 4b4:	bf 93       	push	r27
 4b6:	cf 93       	push	r28
 4b8:	ef 93       	push	r30
 4ba:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	uint8_t receivedByte = UARTBuffer; // local temporary variable for received byte
 4bc:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 4c0:	cc 23       	and	r28, r28
 4c2:	21 f1       	breq	.+72     	; 0x50c <__stack+0xd>
		if (receivedByte == 45) { // that's the '-' sign.
 4c4:	cd 32       	cpi	r28, 0x2D	; 45
 4c6:	31 f4       	brne	.+12     	; 0x4d4 <__vector_13+0x3c>
			remoteEcho = ~remoteEcho;
 4c8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 4cc:	80 95       	com	r24
 4ce:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 4d2:	1c c0       	rjmp	.+56     	; 0x50c <__stack+0xd>
		}else if(receivedByte == s){
 4d4:	c3 37       	cpi	r28, 0x73	; 115
 4d6:	19 f4       	brne	.+6      	; 0x4de <__vector_13+0x46>
			systemCheck();
 4d8:	0e 94 f5 02 	call	0x5ea	; 0x5ea <systemCheck>
 4dc:	17 c0       	rjmp	.+46     	; 0x50c <__stack+0xd>
		}else if(receivedByte == l){
 4de:	cc 36       	cpi	r28, 0x6C	; 108
 4e0:	19 f4       	brne	.+6      	; 0x4e8 <__vector_13+0x50>
			statusRead();
 4e2:	0e 94 f6 01 	call	0x3ec	; 0x3ec <statusRead>
 4e6:	12 c0       	rjmp	.+36     	; 0x50c <__stack+0xd>
		}else if(receivedByte == b){
 4e8:	c2 36       	cpi	r28, 0x62	; 98
 4ea:	29 f4       	brne	.+10     	; 0x4f6 <__vector_13+0x5e>
			fillScreen(Blue);
 4ec:	80 e0       	ldi	r24, 0x00	; 0
 4ee:	98 ef       	ldi	r25, 0xF8	; 248
 4f0:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 4f4:	0b c0       	rjmp	.+22     	; 0x50c <__stack+0xd>
		}else if(receivedByte == r){
 4f6:	c2 37       	cpi	r28, 0x72	; 114
 4f8:	29 f4       	brne	.+10     	; 0x504 <__stack+0x5>
			fillScreen(Red);
 4fa:	8f e1       	ldi	r24, 0x1F	; 31
 4fc:	90 e0       	ldi	r25, 0x00	; 0
 4fe:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 502:	04 c0       	rjmp	.+8      	; 0x50c <__stack+0xd>
		}else if(receivedByte == T){
 504:	c4 35       	cpi	r28, 0x54	; 84
 506:	11 f4       	brne	.+4      	; 0x50c <__stack+0xd>
			screenTest();
 508:	0e 94 a9 01 	call	0x352	; 0x352 <screenTest>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 50c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 510:	88 23       	and	r24, r24
 512:	69 f0       	breq	.+26     	; 0x52e <__stack+0x2f>
 514:	c0 32       	cpi	r28, 0x20	; 32
 516:	40 f4       	brcc	.+16     	; 0x528 <__stack+0x29>
 518:	c7 30       	cpi	r28, 0x07	; 7
 51a:	31 f0       	breq	.+12     	; 0x528 <__stack+0x29>
 51c:	cd 30       	cpi	r28, 0x0D	; 13
 51e:	21 f0       	breq	.+8      	; 0x528 <__stack+0x29>
 520:	ca 30       	cpi	r28, 0x0A	; 10
 522:	11 f0       	breq	.+4      	; 0x528 <__stack+0x29>
 524:	c8 30       	cpi	r28, 0x08	; 8
 526:	19 f4       	brne	.+6      	; 0x52e <__stack+0x2f>
		transmitUART(receivedByte);
 528:	8c 2f       	mov	r24, r28
 52a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	}
 52e:	ff 91       	pop	r31
 530:	ef 91       	pop	r30
 532:	cf 91       	pop	r28
 534:	bf 91       	pop	r27
 536:	af 91       	pop	r26
 538:	9f 91       	pop	r25
 53a:	8f 91       	pop	r24
 53c:	7f 91       	pop	r23
 53e:	6f 91       	pop	r22
 540:	5f 91       	pop	r21
 542:	4f 91       	pop	r20
 544:	3f 91       	pop	r19
 546:	2f 91       	pop	r18
 548:	0f 90       	pop	r0
 54a:	0f be       	out	0x3f, r0	; 63
 54c:	0f 90       	pop	r0
 54e:	1f 90       	pop	r1
 550:	18 95       	reti

00000552 <toHex>:
 */ 

#include "stdint.h"

uint8_t toHex(uint8_t number) {
	uint8_t num = '0'+number;
 552:	80 5d       	subi	r24, 0xD0	; 208
	if(num < 58){
 554:	8a 33       	cpi	r24, 0x3A	; 58
 556:	c0 f0       	brcs	.+48     	; 0x588 <toHex+0x36>
		return num;
	}
	else if(num == 58){
 558:	8a 33       	cpi	r24, 0x3A	; 58
 55a:	59 f0       	breq	.+22     	; 0x572 <toHex+0x20>
		return 'A';
	}
	else if(num == 59){
 55c:	8b 33       	cpi	r24, 0x3B	; 59
 55e:	59 f0       	breq	.+22     	; 0x576 <toHex+0x24>
		return 'B';
	}
	else if(num == 60){
 560:	8c 33       	cpi	r24, 0x3C	; 60
 562:	59 f0       	breq	.+22     	; 0x57a <toHex+0x28>
		return 'C';
	}
	else if(num == 61){
 564:	8d 33       	cpi	r24, 0x3D	; 61
 566:	59 f0       	breq	.+22     	; 0x57e <toHex+0x2c>
		return 'D';
	}
	else if(num == 62){
 568:	8e 33       	cpi	r24, 0x3E	; 62
 56a:	59 f0       	breq	.+22     	; 0x582 <toHex+0x30>
		return 'E';
	}
	else if(num == 63){
 56c:	8f 33       	cpi	r24, 0x3F	; 63
 56e:	59 f0       	breq	.+22     	; 0x586 <toHex+0x34>
		return 'F';
	}
 570:	08 95       	ret
	uint8_t num = '0'+number;
	if(num < 58){
		return num;
	}
	else if(num == 58){
		return 'A';
 572:	81 e4       	ldi	r24, 0x41	; 65
 574:	08 95       	ret
	}
	else if(num == 59){
		return 'B';
 576:	82 e4       	ldi	r24, 0x42	; 66
 578:	08 95       	ret
	}
	else if(num == 60){
		return 'C';
 57a:	83 e4       	ldi	r24, 0x43	; 67
 57c:	08 95       	ret
	}
	else if(num == 61){
		return 'D';
 57e:	84 e4       	ldi	r24, 0x44	; 68
 580:	08 95       	ret
	}
	else if(num == 62){
		return 'E';
 582:	85 e4       	ldi	r24, 0x45	; 69
 584:	08 95       	ret
	}
	else if(num == 63){
		return 'F';
 586:	86 e4       	ldi	r24, 0x46	; 70
	}
 588:	08 95       	ret

0000058a <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 58a:	8f e2       	ldi	r24, 0x2F	; 47
 58c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 590:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 594:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 598:	88 e9       	ldi	r24, 0x98	; 152
 59a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 59e:	86 e0       	ldi	r24, 0x06	; 6
 5a0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 5a4:	08 95       	ret

000005a6 <puttyCompatibleCheck>:
}

uint8_t puttyCompatibleCheck(uint8_t byte){
	if((byte > 31) || (byte == Bell) || (byte == CR) || (byte == LF) || (byte == backspace)){
 5a6:	80 32       	cpi	r24, 0x20	; 32
 5a8:	48 f4       	brcc	.+18     	; 0x5bc <puttyCompatibleCheck+0x16>
 5aa:	87 30       	cpi	r24, 0x07	; 7
 5ac:	39 f0       	breq	.+14     	; 0x5bc <puttyCompatibleCheck+0x16>
 5ae:	8d 30       	cpi	r24, 0x0D	; 13
 5b0:	29 f0       	breq	.+10     	; 0x5bc <puttyCompatibleCheck+0x16>
 5b2:	8a 30       	cpi	r24, 0x0A	; 10
 5b4:	19 f0       	breq	.+6      	; 0x5bc <puttyCompatibleCheck+0x16>
 5b6:	88 30       	cpi	r24, 0x08	; 8
 5b8:	09 f0       	breq	.+2      	; 0x5bc <puttyCompatibleCheck+0x16>
		return byte;
		}else{
		return (uint8_t)64;
 5ba:	80 e4       	ldi	r24, 0x40	; 64
	}
}
 5bc:	08 95       	ret

000005be <transmitUART>:

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 5be:	20 e0       	ldi	r18, 0x00	; 0
 5c0:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 5c2:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 5c6:	95 ff       	sbrs	r25, 5
 5c8:	07 c0       	rjmp	.+14     	; 0x5d8 <transmitUART+0x1a>
			UARTBuffer = puttyCompatibleCheck(data);
 5ca:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <puttyCompatibleCheck>
 5ce:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 5d2:	81 e0       	ldi	r24, 0x01	; 1
 5d4:	90 e0       	ldi	r25, 0x00	; 0
 5d6:	08 95       	ret
			}else{
			timeout++;
 5d8:	2f 5f       	subi	r18, 0xFF	; 255
 5da:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 5dc:	29 3e       	cpi	r18, 0xE9	; 233
 5de:	93 e0       	ldi	r25, 0x03	; 3
 5e0:	39 07       	cpc	r19, r25
 5e2:	7c f3       	brlt	.-34     	; 0x5c2 <transmitUART+0x4>
				return 0;
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 5e8:	08 95       	ret

000005ea <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 5ea:	8d e0       	ldi	r24, 0x0D	; 13
 5ec:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(S);
 5f0:	83 e5       	ldi	r24, 0x53	; 83
 5f2:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(y);
 5f6:	89 e7       	ldi	r24, 0x79	; 121
 5f8:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(s);
 5fc:	83 e7       	ldi	r24, 0x73	; 115
 5fe:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(t);
 602:	84 e7       	ldi	r24, 0x74	; 116
 604:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(e);
 608:	85 e6       	ldi	r24, 0x65	; 101
 60a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(m);
 60e:	8d e6       	ldi	r24, 0x6D	; 109
 610:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(_space);
 614:	80 e2       	ldi	r24, 0x20	; 32
 616:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(c);
 61a:	83 e6       	ldi	r24, 0x63	; 99
 61c:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(h);
 620:	88 e6       	ldi	r24, 0x68	; 104
 622:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(e);
 626:	85 e6       	ldi	r24, 0x65	; 101
 628:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(c);
 62c:	83 e6       	ldi	r24, 0x63	; 99
 62e:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(k);
 632:	8b e6       	ldi	r24, 0x6B	; 107
 634:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(_colon);
 638:	8a e3       	ldi	r24, 0x3A	; 58
 63a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(CR);
 63e:	8d e0       	ldi	r24, 0x0D	; 13
 640:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
 644:	08 95       	ret

00000646 <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART(CR);
 646:	8d e0       	ldi	r24, 0x0D	; 13
 648:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(B);
 64c:	82 e4       	ldi	r24, 0x42	; 66
 64e:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(l);
 652:	8c e6       	ldi	r24, 0x6C	; 108
 654:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(i);
 658:	89 e6       	ldi	r24, 0x69	; 105
 65a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(t);
 65e:	84 e7       	ldi	r24, 0x74	; 116
 660:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(t);
 664:	84 e7       	ldi	r24, 0x74	; 116
 666:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(e);
 66a:	85 e6       	ldi	r24, 0x65	; 101
 66c:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(r);
 670:	82 e7       	ldi	r24, 0x72	; 114
 672:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(_space);
 676:	80 e2       	ldi	r24, 0x20	; 32
 678:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(r);
 67c:	82 e7       	ldi	r24, 0x72	; 114
 67e:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(e);
 682:	85 e6       	ldi	r24, 0x65	; 101
 684:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(a);
 688:	81 e6       	ldi	r24, 0x61	; 97
 68a:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(d);
 68e:	84 e6       	ldi	r24, 0x64	; 100
 690:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(y);
 694:	89 e7       	ldi	r24, 0x79	; 121
 696:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
	transmitUART(CR);
 69a:	8d e0       	ldi	r24, 0x0D	; 13
 69c:	0e 94 df 02 	call	0x5be	; 0x5be <transmitUART>
 6a0:	08 95       	ret

000006a2 <_exit>:
 6a2:	f8 94       	cli

000006a4 <__stop_program>:
 6a4:	ff cf       	rjmp	.-2      	; 0x6a4 <__stop_program>
