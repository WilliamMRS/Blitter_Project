
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000003aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000336  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000003aa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003aa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e0  00000000  00000000  0000041c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000114b  00000000  00000000  000004fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a63  00000000  00000000  00001647  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007cc  00000000  00000000  000020aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001bc  00000000  00000000  00002878  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005c9  00000000  00000000  00002a34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000345  00000000  00000000  00002ffd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a0  00000000  00000000  00003342  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a1 30       	cpi	r26, 0x01	; 1
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 cc 00 	call	0x198	; 0x198 <main>
  7c:	0c 94 99 01 	jmp	0x332	; 0x332 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	D8_D15 = hData;
	wrSignal();
}

void wrSignal(void){
	WR_LOW;
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
	WR_HIGH;
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
/*
	Usage: Writes to the index register. The index register points to where the next written data should go.
	Prereq: Set CS_LOW first.
*/
void writeIndex(unsigned short index){
	DC_LOW; // DC LOW
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
	RD_HIGH; // RD High (for good measure? can be omitted as RD should always be high)
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
	D0_D7 = index; // IO Write
  9e:	82 b9       	out	0x02, r24	; 2
	wrSignal();
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
/*
	Usage: Writes to the index register. The index register points to where the next written data should go.
	Prereq: Set CS_LOW first.
*/
void writeData(unsigned char lData, unsigned char hData){
	DC_HIGH;
  a6:	9e b1       	in	r25, 0x0e	; 14
  a8:	90 68       	ori	r25, 0x80	; 128
  aa:	9e b9       	out	0x0e, r25	; 14
	D0_D7 = lData; // Write data to GPIO lines (lines should by default be output)
  ac:	82 b9       	out	0x02, r24	; 2
	D8_D15 = hData;
  ae:	68 b9       	out	0x08, r22	; 8
	wrSignal();
  b0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  b4:	08 95       	ret

000000b6 <initHY32D>:
#include <util/delay.h>

// This isn't ready, see datasheet on how to complete start up sequence.
void initHY32D(void){
	// Setting CS, DC, RD, WR to output.
	DDRB |= (1 << CS);
  b6:	84 b1       	in	r24, 0x04	; 4
  b8:	80 64       	ori	r24, 0x40	; 64
  ba:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << BL_PWM);
  bc:	84 b1       	in	r24, 0x04	; 4
  be:	80 62       	ori	r24, 0x20	; 32
  c0:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << WR);
  c2:	84 b1       	in	r24, 0x04	; 4
  c4:	80 61       	ori	r24, 0x10	; 16
  c6:	84 b9       	out	0x04, r24	; 4
	DDRE |= (1 << RD);
  c8:	8d b1       	in	r24, 0x0d	; 13
  ca:	80 64       	ori	r24, 0x40	; 64
  cc:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << DC);
  ce:	8d b1       	in	r24, 0x0d	; 13
  d0:	80 68       	ori	r24, 0x80	; 128
  d2:	8d b9       	out	0x0d, r24	; 13
	// All are set to High (disabled). DC doesn't matter.
	PORTB |= (1 << CS);
  d4:	85 b1       	in	r24, 0x05	; 5
  d6:	80 64       	ori	r24, 0x40	; 64
  d8:	85 b9       	out	0x05, r24	; 5
	PORTB |= (1 << BL_PWM);
  da:	85 b1       	in	r24, 0x05	; 5
  dc:	80 62       	ori	r24, 0x20	; 32
  de:	85 b9       	out	0x05, r24	; 5
	PORTB |= (1 << WR);
  e0:	85 b1       	in	r24, 0x05	; 5
  e2:	80 61       	ori	r24, 0x10	; 16
  e4:	85 b9       	out	0x05, r24	; 5
	PORTE |= (1 << RD);
  e6:	8e b1       	in	r24, 0x0e	; 14
  e8:	80 64       	ori	r24, 0x40	; 64
  ea:	8e b9       	out	0x0e, r24	; 14
	PORTE |= (1 << DC);
  ec:	8e b1       	in	r24, 0x0e	; 14
  ee:	80 68       	ori	r24, 0x80	; 128
  f0:	8e b9       	out	0x0e, r24	; 14
	// Set IO to output
	DDRA = 0xFF; // D0 - D7
  f2:	8f ef       	ldi	r24, 0xFF	; 255
  f4:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF; // D8 - D15
  f6:	87 b9       	out	0x07, r24	; 7
	CS_LOW;
  f8:	84 b1       	in	r24, 0x04	; 4
  fa:	8f 7b       	andi	r24, 0xBF	; 191
  fc:	84 b9       	out	0x04, r24	; 4
	// Power supply setting (See page 71 of SSD1289 datasheet):
	// Set R07h at 0021h
	writeIndex(0x07);
  fe:	87 e0       	ldi	r24, 0x07	; 7
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x21, 0x00);
 106:	60 e0       	ldi	r22, 0x00	; 0
 108:	81 e2       	ldi	r24, 0x21	; 33
 10a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Set R00h at 0001h
	writeIndex(0x00);
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x01, 0x00);
 116:	60 e0       	ldi	r22, 0x00	; 0
 118:	81 e0       	ldi	r24, 0x01	; 1
 11a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Set R07h at 0023h
	writeIndex(0x07);
 11e:	87 e0       	ldi	r24, 0x07	; 7
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x23, 0x00);
 126:	60 e0       	ldi	r22, 0x00	; 0
 128:	83 e2       	ldi	r24, 0x23	; 35
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Set R10h at 0000h Exit sleep mode
	writeIndex(0x10);
 12e:	80 e1       	ldi	r24, 0x10	; 16
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x00, 0x00);
 136:	60 e0       	ldi	r22, 0x00	; 0
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 13e:	2f ef       	ldi	r18, 0xFF	; 255
 140:	8f e1       	ldi	r24, 0x1F	; 31
 142:	91 e0       	ldi	r25, 0x01	; 1
 144:	21 50       	subi	r18, 0x01	; 1
 146:	80 40       	sbci	r24, 0x00	; 0
 148:	90 40       	sbci	r25, 0x00	; 0
 14a:	e1 f7       	brne	.-8      	; 0x144 <initHY32D+0x8e>
 14c:	00 c0       	rjmp	.+0      	; 0x14e <initHY32D+0x98>
 14e:	00 00       	nop
	// wait 30ms
	_delay_ms(50);
	// Set R07h at 0033h
	writeIndex(0x07);
 150:	87 e0       	ldi	r24, 0x07	; 7
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x33, 0x00);
 158:	60 e0       	ldi	r22, 0x00	; 0
 15a:	83 e3       	ldi	r24, 0x33	; 51
 15c:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Entry mode setting
	writeIndex(0x11);
 160:	81 e1       	ldi	r24, 0x11	; 17
 162:	90 e0       	ldi	r25, 0x00	; 0
 164:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x30, 0x68);
 168:	68 e6       	ldi	r22, 0x68	; 104
 16a:	80 e3       	ldi	r24, 0x30	; 48
 16c:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// LCD driver AC setting
	writeIndex(0x02);
 170:	82 e0       	ldi	r24, 0x02	; 2
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x00, 0x00);
 178:	60 e0       	ldi	r22, 0x00	; 0
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Ram data write
	writeIndex(0x22);
 180:	82 e2       	ldi	r24, 0x22	; 34
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(0x00, 0x00);
 188:	60 e0       	ldi	r22, 0x00	; 0
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	// Display on
	CS_HIGH;
 190:	84 b1       	in	r24, 0x04	; 4
 192:	80 64       	ori	r24, 0x40	; 64
 194:	84 b9       	out	0x04, r24	; 4
 196:	08 95       	ret

00000198 <main>:
}

int main(void)
{	
	// Startup sequence
    initUART(); // initialize the UART
 198:	0e 94 1b 01 	call	0x236	; 0x236 <initUART>
	initHY32D(); // initialize HY32D screen
 19c:	0e 94 5b 00 	call	0xb6	; 0xb6 <initHY32D>
	sei(); //Enable global interrupt
 1a0:	78 94       	sei
	startupMessage();
 1a2:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <startupMessage>
 1a6:	ff cf       	rjmp	.-2      	; 0x1a6 <main+0xe>

000001a8 <__vector_13>:
		Få kontakt med flashminnet
		Tegn fra flashminnet til skjermen*/
    }
}

ISR(USART0_RX_vect){
 1a8:	1f 92       	push	r1
 1aa:	0f 92       	push	r0
 1ac:	0f b6       	in	r0, 0x3f	; 63
 1ae:	0f 92       	push	r0
 1b0:	11 24       	eor	r1, r1
 1b2:	2f 93       	push	r18
 1b4:	3f 93       	push	r19
 1b6:	4f 93       	push	r20
 1b8:	5f 93       	push	r21
 1ba:	6f 93       	push	r22
 1bc:	7f 93       	push	r23
 1be:	8f 93       	push	r24
 1c0:	9f 93       	push	r25
 1c2:	af 93       	push	r26
 1c4:	bf 93       	push	r27
 1c6:	cf 93       	push	r28
 1c8:	ef 93       	push	r30
 1ca:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	unsigned char receivedByte = UARTBuffer; // local temporary variable for received byte
 1cc:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 1d0:	cc 23       	and	r28, r28
 1d2:	61 f0       	breq	.+24     	; 0x1ec <__vector_13+0x44>
		if (receivedByte == 45) { // that's the '-' sign.
 1d4:	cd 32       	cpi	r28, 0x2D	; 45
 1d6:	31 f4       	brne	.+12     	; 0x1e4 <__vector_13+0x3c>
			remoteEcho = ~remoteEcho;
 1d8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 1dc:	80 95       	com	r24
 1de:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 1e2:	04 c0       	rjmp	.+8      	; 0x1ec <__vector_13+0x44>
		}else if(receivedByte == S){
 1e4:	c3 35       	cpi	r28, 0x53	; 83
 1e6:	11 f4       	brne	.+4      	; 0x1ec <__vector_13+0x44>
			systemCheck();
 1e8:	0e 94 3d 01 	call	0x27a	; 0x27a <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 1ec:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 1f0:	88 23       	and	r24, r24
 1f2:	79 f0       	breq	.+30     	; 0x212 <__EEPROM_REGION_LENGTH__+0x12>
 1f4:	c0 32       	cpi	r28, 0x20	; 32
 1f6:	40 f4       	brcc	.+16     	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
 1f8:	c7 30       	cpi	r28, 0x07	; 7
 1fa:	31 f0       	breq	.+12     	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
 1fc:	cd 30       	cpi	r28, 0x0D	; 13
 1fe:	21 f0       	breq	.+8      	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
 200:	ca 30       	cpi	r28, 0x0A	; 10
 202:	11 f0       	breq	.+4      	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
 204:	c8 30       	cpi	r28, 0x08	; 8
 206:	29 f4       	brne	.+10     	; 0x212 <__EEPROM_REGION_LENGTH__+0x12>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 208:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 20c:	85 fd       	sbrc	r24, 5
			UARTBuffer = receivedByte;
 20e:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
 212:	ff 91       	pop	r31
 214:	ef 91       	pop	r30
 216:	cf 91       	pop	r28
 218:	bf 91       	pop	r27
 21a:	af 91       	pop	r26
 21c:	9f 91       	pop	r25
 21e:	8f 91       	pop	r24
 220:	7f 91       	pop	r23
 222:	6f 91       	pop	r22
 224:	5f 91       	pop	r21
 226:	4f 91       	pop	r20
 228:	3f 91       	pop	r19
 22a:	2f 91       	pop	r18
 22c:	0f 90       	pop	r0
 22e:	0f be       	out	0x3f, r0	; 63
 230:	0f 90       	pop	r0
 232:	1f 90       	pop	r1
 234:	18 95       	reti

00000236 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 236:	8f e2       	ldi	r24, 0x2F	; 47
 238:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 23c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 240:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 244:	88 e9       	ldi	r24, 0x98	; 152
 246:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 24a:	86 e0       	ldi	r24, 0x06	; 6
 24c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 250:	08 95       	ret

00000252 <transmitUART>:
}

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 252:	20 e0       	ldi	r18, 0x00	; 0
 254:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 256:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 25a:	95 ff       	sbrs	r25, 5
 25c:	05 c0       	rjmp	.+10     	; 0x268 <transmitUART+0x16>
			UARTBuffer = data;
 25e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 262:	81 e0       	ldi	r24, 0x01	; 1
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	08 95       	ret
			}else{
			timeout++;
 268:	2f 5f       	subi	r18, 0xFF	; 255
 26a:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 26c:	29 3e       	cpi	r18, 0xE9	; 233
 26e:	93 e0       	ldi	r25, 0x03	; 3
 270:	39 07       	cpc	r19, r25
 272:	8c f3       	brlt	.-30     	; 0x256 <transmitUART+0x4>
				return 0;
 274:	80 e0       	ldi	r24, 0x00	; 0
 276:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 278:	08 95       	ret

0000027a <systemCheck>:
#include "ASCII.h"
#include "UART.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 27a:	8d e0       	ldi	r24, 0x0D	; 13
 27c:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(S);
 280:	83 e5       	ldi	r24, 0x53	; 83
 282:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(y);
 286:	89 e7       	ldi	r24, 0x79	; 121
 288:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(s);
 28c:	83 e7       	ldi	r24, 0x73	; 115
 28e:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(t);
 292:	84 e7       	ldi	r24, 0x74	; 116
 294:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(e);
 298:	85 e6       	ldi	r24, 0x65	; 101
 29a:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(m);
 29e:	8d e6       	ldi	r24, 0x6D	; 109
 2a0:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(_space);
 2a4:	80 e2       	ldi	r24, 0x20	; 32
 2a6:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(c);
 2aa:	83 e6       	ldi	r24, 0x63	; 99
 2ac:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(h);
 2b0:	88 e6       	ldi	r24, 0x68	; 104
 2b2:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(e);
 2b6:	85 e6       	ldi	r24, 0x65	; 101
 2b8:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(c);
 2bc:	83 e6       	ldi	r24, 0x63	; 99
 2be:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(k);
 2c2:	8b e6       	ldi	r24, 0x6B	; 107
 2c4:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(_colon);
 2c8:	8a e3       	ldi	r24, 0x3A	; 58
 2ca:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(CR);
 2ce:	8d e0       	ldi	r24, 0x0D	; 13
 2d0:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
 2d4:	08 95       	ret

000002d6 <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART(CR);
 2d6:	8d e0       	ldi	r24, 0x0D	; 13
 2d8:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(B);
 2dc:	82 e4       	ldi	r24, 0x42	; 66
 2de:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(l);
 2e2:	8c e6       	ldi	r24, 0x6C	; 108
 2e4:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(i);
 2e8:	89 e6       	ldi	r24, 0x69	; 105
 2ea:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(t);
 2ee:	84 e7       	ldi	r24, 0x74	; 116
 2f0:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(t);
 2f4:	84 e7       	ldi	r24, 0x74	; 116
 2f6:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(e);
 2fa:	85 e6       	ldi	r24, 0x65	; 101
 2fc:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(r);
 300:	82 e7       	ldi	r24, 0x72	; 114
 302:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(_space);
 306:	80 e2       	ldi	r24, 0x20	; 32
 308:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(r);
 30c:	82 e7       	ldi	r24, 0x72	; 114
 30e:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(e);
 312:	85 e6       	ldi	r24, 0x65	; 101
 314:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(a);
 318:	81 e6       	ldi	r24, 0x61	; 97
 31a:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(d);
 31e:	84 e6       	ldi	r24, 0x64	; 100
 320:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(y);
 324:	89 e7       	ldi	r24, 0x79	; 121
 326:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
	transmitUART(CR);
 32a:	8d e0       	ldi	r24, 0x0D	; 13
 32c:	0e 94 29 01 	call	0x252	; 0x252 <transmitUART>
 330:	08 95       	ret

00000332 <_exit>:
 332:	f8 94       	cli

00000334 <__stop_program>:
 334:	ff cf       	rjmp	.-2      	; 0x334 <__stop_program>
