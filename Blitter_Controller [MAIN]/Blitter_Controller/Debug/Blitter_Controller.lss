
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000558  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004e4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  00000558  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000558  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000588  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000f8  00000000  00000000  000005c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000014f1  00000000  00000000  000006c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000aa8  00000000  00000000  00001bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009d7  00000000  00000000  00002659  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000224  00000000  00000000  00003030  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005f4  00000000  00000000  00003254  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000006ba  00000000  00000000  00003848  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b8  00000000  00000000  00003f02  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 ab 01 	jmp	0x356	; 0x356 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 a3 01 	call	0x346	; 0x346 <main>
  7c:	0c 94 70 02 	jmp	0x4e0	; 0x4e0 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DDRA = 0xFF;
	DDRC = 0xFF;
}
void setIOtoInput(void){
	DDRA = 0x00;
	DDRC = 0x00;
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <fillScreen>:
}

void fillScreen(unsigned short color){
  e4:	cf 92       	push	r12
  e6:	df 92       	push	r13
  e8:	ef 92       	push	r14
  ea:	ff 92       	push	r15
  ec:	cf 93       	push	r28
  ee:	df 93       	push	r29
  f0:	ec 01       	movw	r28, r24
	CS_LOW;
  f2:	85 b1       	in	r24, 0x05	; 5
  f4:	8f 7b       	andi	r24, 0xBF	; 191
  f6:	85 b9       	out	0x05, r24	; 5
	writeIndex(0x22);
  f8:	82 e2       	ldi	r24, 0x22	; 34
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	for(unsigned long int it = 0; it < pixels; it++){
 100:	c1 2c       	mov	r12, r1
 102:	d1 2c       	mov	r13, r1
 104:	76 01       	movw	r14, r12
 106:	08 c0       	rjmp	.+16     	; 0x118 <fillScreen+0x34>
		writeData(color);
 108:	ce 01       	movw	r24, r28
 10a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
}

void fillScreen(unsigned short color){
	CS_LOW;
	writeIndex(0x22);
	for(unsigned long int it = 0; it < pixels; it++){
 10e:	8f ef       	ldi	r24, 0xFF	; 255
 110:	c8 1a       	sub	r12, r24
 112:	d8 0a       	sbc	r13, r24
 114:	e8 0a       	sbc	r14, r24
 116:	f8 0a       	sbc	r15, r24
 118:	c1 14       	cp	r12, r1
 11a:	8c e2       	ldi	r24, 0x2C	; 44
 11c:	d8 06       	cpc	r13, r24
 11e:	81 e0       	ldi	r24, 0x01	; 1
 120:	e8 06       	cpc	r14, r24
 122:	f1 04       	cpc	r15, r1
 124:	88 f3       	brcs	.-30     	; 0x108 <fillScreen+0x24>
		writeData(color);
	}
	CS_HIGH;
 126:	85 b1       	in	r24, 0x05	; 5
 128:	80 64       	ori	r24, 0x40	; 64
 12a:	85 b9       	out	0x05, r24	; 5
}
 12c:	df 91       	pop	r29
 12e:	cf 91       	pop	r28
 130:	ff 90       	pop	r15
 132:	ef 90       	pop	r14
 134:	df 90       	pop	r13
 136:	cf 90       	pop	r12
 138:	08 95       	ret

0000013a <colorTest>:

void colorTest(void){
 13a:	cf 93       	push	r28
 13c:	df 93       	push	r29
	CS_LOW;
 13e:	85 b1       	in	r24, 0x05	; 5
 140:	8f 7b       	andi	r24, 0xBF	; 191
 142:	85 b9       	out	0x05, r24	; 5
	writeIndex(0x22);
 144:	82 e2       	ldi	r24, 0x22	; 34
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	for(int it = 0; it < 7680; it++){
 14c:	c0 e0       	ldi	r28, 0x00	; 0
 14e:	d0 e0       	ldi	r29, 0x00	; 0
 150:	05 c0       	rjmp	.+10     	; 0x15c <colorTest+0x22>
		writeData(White);
 152:	8f ef       	ldi	r24, 0xFF	; 255
 154:	9f ef       	ldi	r25, 0xFF	; 255
 156:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
}

void colorTest(void){
	CS_LOW;
	writeIndex(0x22);
	for(int it = 0; it < 7680; it++){
 15a:	21 96       	adiw	r28, 0x01	; 1
 15c:	c1 15       	cp	r28, r1
 15e:	8e e1       	ldi	r24, 0x1E	; 30
 160:	d8 07       	cpc	r29, r24
 162:	bc f3       	brlt	.-18     	; 0x152 <colorTest+0x18>
 164:	c0 e0       	ldi	r28, 0x00	; 0
 166:	d0 e0       	ldi	r29, 0x00	; 0
 168:	05 c0       	rjmp	.+10     	; 0x174 <colorTest+0x3a>
		writeData(White);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Black);
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	CS_LOW;
	writeIndex(0x22);
	for(int it = 0; it < 7680; it++){
		writeData(White);
	}
	for(int it = 0; it < 7680; it++){
 172:	21 96       	adiw	r28, 0x01	; 1
 174:	c1 15       	cp	r28, r1
 176:	8e e1       	ldi	r24, 0x1E	; 30
 178:	d8 07       	cpc	r29, r24
 17a:	bc f3       	brlt	.-18     	; 0x16a <colorTest+0x30>
 17c:	c0 e0       	ldi	r28, 0x00	; 0
 17e:	d0 e0       	ldi	r29, 0x00	; 0
 180:	05 c0       	rjmp	.+10     	; 0x18c <colorTest+0x52>
		writeData(Black);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Grey);
 182:	8e ed       	ldi	r24, 0xDE	; 222
 184:	97 ef       	ldi	r25, 0xF7	; 247
 186:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(White);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Black);
	}
	for(int it = 0; it < 7680; it++){
 18a:	21 96       	adiw	r28, 0x01	; 1
 18c:	c1 15       	cp	r28, r1
 18e:	8e e1       	ldi	r24, 0x1E	; 30
 190:	d8 07       	cpc	r29, r24
 192:	bc f3       	brlt	.-18     	; 0x182 <colorTest+0x48>
 194:	c0 e0       	ldi	r28, 0x00	; 0
 196:	d0 e0       	ldi	r29, 0x00	; 0
 198:	05 c0       	rjmp	.+10     	; 0x1a4 <colorTest+0x6a>
		writeData(Grey);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Blue);
 19a:	80 e0       	ldi	r24, 0x00	; 0
 19c:	98 ef       	ldi	r25, 0xF8	; 248
 19e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Black);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Grey);
	}
	for(int it = 0; it < 7680; it++){
 1a2:	21 96       	adiw	r28, 0x01	; 1
 1a4:	c1 15       	cp	r28, r1
 1a6:	8e e1       	ldi	r24, 0x1E	; 30
 1a8:	d8 07       	cpc	r29, r24
 1aa:	bc f3       	brlt	.-18     	; 0x19a <colorTest+0x60>
 1ac:	c0 e0       	ldi	r28, 0x00	; 0
 1ae:	d0 e0       	ldi	r29, 0x00	; 0
 1b0:	05 c0       	rjmp	.+10     	; 0x1bc <colorTest+0x82>
		writeData(Blue);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Light_Blue);
 1b2:	87 ee       	ldi	r24, 0xE7	; 231
 1b4:	9c ef       	ldi	r25, 0xFC	; 252
 1b6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Grey);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Blue);
	}
	for(int it = 0; it < 7680; it++){
 1ba:	21 96       	adiw	r28, 0x01	; 1
 1bc:	c1 15       	cp	r28, r1
 1be:	8e e1       	ldi	r24, 0x1E	; 30
 1c0:	d8 07       	cpc	r29, r24
 1c2:	bc f3       	brlt	.-18     	; 0x1b2 <colorTest+0x78>
 1c4:	c0 e0       	ldi	r28, 0x00	; 0
 1c6:	d0 e0       	ldi	r29, 0x00	; 0
 1c8:	05 c0       	rjmp	.+10     	; 0x1d4 <colorTest+0x9a>
		writeData(Light_Blue);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Red);
 1ca:	8f e1       	ldi	r24, 0x1F	; 31
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Blue);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Light_Blue);
	}
	for(int it = 0; it < 7680; it++){
 1d2:	21 96       	adiw	r28, 0x01	; 1
 1d4:	c1 15       	cp	r28, r1
 1d6:	8e e1       	ldi	r24, 0x1E	; 30
 1d8:	d8 07       	cpc	r29, r24
 1da:	bc f3       	brlt	.-18     	; 0x1ca <colorTest+0x90>
 1dc:	c0 e0       	ldi	r28, 0x00	; 0
 1de:	d0 e0       	ldi	r29, 0x00	; 0
 1e0:	05 c0       	rjmp	.+10     	; 0x1ec <colorTest+0xb2>
		writeData(Red);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Magenta);
 1e2:	8f e1       	ldi	r24, 0x1F	; 31
 1e4:	98 ef       	ldi	r25, 0xF8	; 248
 1e6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Light_Blue);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Red);
	}
	for(int it = 0; it < 7680; it++){
 1ea:	21 96       	adiw	r28, 0x01	; 1
 1ec:	c1 15       	cp	r28, r1
 1ee:	8e e1       	ldi	r24, 0x1E	; 30
 1f0:	d8 07       	cpc	r29, r24
 1f2:	bc f3       	brlt	.-18     	; 0x1e2 <colorTest+0xa8>
 1f4:	c0 e0       	ldi	r28, 0x00	; 0
 1f6:	d0 e0       	ldi	r29, 0x00	; 0
 1f8:	05 c0       	rjmp	.+10     	; 0x204 <__EEPROM_REGION_LENGTH__+0x4>
		writeData(Magenta);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Green);
 1fa:	80 ee       	ldi	r24, 0xE0	; 224
 1fc:	97 e0       	ldi	r25, 0x07	; 7
 1fe:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Red);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Magenta);
	}
	for(int it = 0; it < 7680; it++){
 202:	21 96       	adiw	r28, 0x01	; 1
 204:	c1 15       	cp	r28, r1
 206:	8e e1       	ldi	r24, 0x1E	; 30
 208:	d8 07       	cpc	r29, r24
 20a:	bc f3       	brlt	.-18     	; 0x1fa <colorTest+0xc0>
 20c:	c0 e0       	ldi	r28, 0x00	; 0
 20e:	d0 e0       	ldi	r29, 0x00	; 0
 210:	05 c0       	rjmp	.+10     	; 0x21c <__EEPROM_REGION_LENGTH__+0x1c>
		writeData(Green);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Cyan);
 212:	80 ee       	ldi	r24, 0xE0	; 224
 214:	9f ef       	ldi	r25, 0xFF	; 255
 216:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Magenta);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Green);
	}
	for(int it = 0; it < 7680; it++){
 21a:	21 96       	adiw	r28, 0x01	; 1
 21c:	c1 15       	cp	r28, r1
 21e:	8e e1       	ldi	r24, 0x1E	; 30
 220:	d8 07       	cpc	r29, r24
 222:	bc f3       	brlt	.-18     	; 0x212 <__EEPROM_REGION_LENGTH__+0x12>
 224:	c0 e0       	ldi	r28, 0x00	; 0
 226:	d0 e0       	ldi	r29, 0x00	; 0
 228:	05 c0       	rjmp	.+10     	; 0x234 <__EEPROM_REGION_LENGTH__+0x34>
		writeData(Cyan);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Yellow);
 22a:	8f e1       	ldi	r24, 0x1F	; 31
 22c:	95 e0       	ldi	r25, 0x05	; 5
 22e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
		writeData(Green);
	}
	for(int it = 0; it < 7680; it++){
		writeData(Cyan);
	}
	for(int it = 0; it < 7680; it++){
 232:	21 96       	adiw	r28, 0x01	; 1
 234:	c1 15       	cp	r28, r1
 236:	8e e1       	ldi	r24, 0x1E	; 30
 238:	d8 07       	cpc	r29, r24
 23a:	bc f3       	brlt	.-18     	; 0x22a <__EEPROM_REGION_LENGTH__+0x2a>
		writeData(Yellow);
	}
	CS_HIGH;
 23c:	85 b1       	in	r24, 0x05	; 5
 23e:	80 64       	ori	r24, 0x40	; 64
 240:	85 b9       	out	0x05, r24	; 5
 242:	df 91       	pop	r29
 244:	cf 91       	pop	r28
 246:	08 95       	ret

00000248 <initHY32D>:
unsigned char hData;

// This isn't ready, see datasheet on how to complete start up sequence.
void initHY32D(void){
	// Setting CS, DC, RD, WR to output.
	DDRB |= (1 << CS);
 248:	84 b1       	in	r24, 0x04	; 4
 24a:	80 64       	ori	r24, 0x40	; 64
 24c:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << BL_PWM);
 24e:	84 b1       	in	r24, 0x04	; 4
 250:	80 62       	ori	r24, 0x20	; 32
 252:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << WR);
 254:	84 b1       	in	r24, 0x04	; 4
 256:	80 61       	ori	r24, 0x10	; 16
 258:	84 b9       	out	0x04, r24	; 4
	DDRE |= (1 << RD);
 25a:	8d b1       	in	r24, 0x0d	; 13
 25c:	80 64       	ori	r24, 0x40	; 64
 25e:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << DC);
 260:	8d b1       	in	r24, 0x0d	; 13
 262:	80 68       	ori	r24, 0x80	; 128
 264:	8d b9       	out	0x0d, r24	; 13
	// All are set to High (disabled). DC doesn't matter.
	PORTB |= (1 << CS);
 266:	85 b1       	in	r24, 0x05	; 5
 268:	80 64       	ori	r24, 0x40	; 64
 26a:	85 b9       	out	0x05, r24	; 5
	//PORTB |= (1 << BL_PWM);
	PORTB |= (1 << WR);
 26c:	85 b1       	in	r24, 0x05	; 5
 26e:	80 61       	ori	r24, 0x10	; 16
 270:	85 b9       	out	0x05, r24	; 5
	PORTE |= (1 << RD);
 272:	8e b1       	in	r24, 0x0e	; 14
 274:	80 64       	ori	r24, 0x40	; 64
 276:	8e b9       	out	0x0e, r24	; 14
	PORTE |= (1 << DC);
 278:	8e b1       	in	r24, 0x0e	; 14
 27a:	80 68       	ori	r24, 0x80	; 128
 27c:	8e b9       	out	0x0e, r24	; 14
	// Set IO to output
	DDRA = 0xFF; // D0 - D7
 27e:	8f ef       	ldi	r24, 0xFF	; 255
 280:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF; // D8 - D15
 282:	87 b9       	out	0x07, r24	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 284:	2f ef       	ldi	r18, 0xFF	; 255
 286:	8f e3       	ldi	r24, 0x3F	; 63
 288:	92 e0       	ldi	r25, 0x02	; 2
 28a:	21 50       	subi	r18, 0x01	; 1
 28c:	80 40       	sbci	r24, 0x00	; 0
 28e:	90 40       	sbci	r25, 0x00	; 0
 290:	e1 f7       	brne	.-8      	; 0x28a <initHY32D+0x42>
 292:	00 c0       	rjmp	.+0      	; 0x294 <initHY32D+0x4c>
 294:	00 00       	nop
	_delay_ms(100);
	RST_HIGH;
 296:	85 b1       	in	r24, 0x05	; 5
 298:	81 60       	ori	r24, 0x01	; 1
 29a:	85 b9       	out	0x05, r24	; 5
 29c:	8f ef       	ldi	r24, 0xFF	; 255
 29e:	93 e2       	ldi	r25, 0x23	; 35
 2a0:	01 97       	sbiw	r24, 0x01	; 1
 2a2:	f1 f7       	brne	.-4      	; 0x2a0 <initHY32D+0x58>
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <initHY32D+0x5e>
 2a6:	00 00       	nop
	_delay_ms(5);
	RST_LOW;
 2a8:	85 b1       	in	r24, 0x05	; 5
 2aa:	8e 7f       	andi	r24, 0xFE	; 254
 2ac:	85 b9       	out	0x05, r24	; 5
 2ae:	8f ef       	ldi	r24, 0xFF	; 255
 2b0:	9b e6       	ldi	r25, 0x6B	; 107
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <initHY32D+0x6a>
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <initHY32D+0x70>
 2b8:	00 00       	nop
	_delay_ms(15);
	RST_HIGH;
 2ba:	85 b1       	in	r24, 0x05	; 5
 2bc:	81 60       	ori	r24, 0x01	; 1
 2be:	85 b9       	out	0x05, r24	; 5
 2c0:	8f ef       	ldi	r24, 0xFF	; 255
 2c2:	9b e6       	ldi	r25, 0x6B	; 107
 2c4:	01 97       	sbiw	r24, 0x01	; 1
 2c6:	f1 f7       	brne	.-4      	; 0x2c4 <initHY32D+0x7c>
 2c8:	00 c0       	rjmp	.+0      	; 0x2ca <initHY32D+0x82>
 2ca:	00 00       	nop
	_delay_ms(15);
	
	// Power supply setting (See page 71 of SSD1289 datasheet):
	// Set R07h at 0021h
	writeToRegister(0x07, 0x0021);
 2cc:	61 e2       	ldi	r22, 0x21	; 33
 2ce:	70 e0       	ldi	r23, 0x00	; 0
 2d0:	87 e0       	ldi	r24, 0x07	; 7
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// Set R00h at 0001h (turn on oscillator)
	writeToRegister(0x00, 0x0001);
 2d8:	61 e0       	ldi	r22, 0x01	; 1
 2da:	70 e0       	ldi	r23, 0x00	; 0
 2dc:	80 e0       	ldi	r24, 0x00	; 0
 2de:	90 e0       	ldi	r25, 0x00	; 0
 2e0:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// Set R07h at 0023h
	writeToRegister(0x07, 0x0023);
 2e4:	63 e2       	ldi	r22, 0x23	; 35
 2e6:	70 e0       	ldi	r23, 0x00	; 0
 2e8:	87 e0       	ldi	r24, 0x07	; 7
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// Set R10h at 0000h Exit sleep mode
	writeToRegister(0x10, 0x0000);
 2f0:	60 e0       	ldi	r22, 0x00	; 0
 2f2:	70 e0       	ldi	r23, 0x00	; 0
 2f4:	80 e1       	ldi	r24, 0x10	; 16
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2fc:	8f ef       	ldi	r24, 0xFF	; 255
 2fe:	97 ed       	ldi	r25, 0xD7	; 215
 300:	01 97       	sbiw	r24, 0x01	; 1
 302:	f1 f7       	brne	.-4      	; 0x300 <initHY32D+0xb8>
 304:	00 c0       	rjmp	.+0      	; 0x306 <initHY32D+0xbe>
 306:	00 00       	nop
	// wait 30ms
	_delay_ms(30);
	// Set R07h at 0033h. Which means grayscale level output. See page 36.
	writeToRegister(0x07, 0x0033);
 308:	63 e3       	ldi	r22, 0x33	; 51
 30a:	70 e0       	ldi	r23, 0x00	; 0
 30c:	87 e0       	ldi	r24, 0x07	; 7
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// Entry mode setting
	writeToRegister(0x11, 0x6830);
 314:	60 e3       	ldi	r22, 0x30	; 48
 316:	78 e6       	ldi	r23, 0x68	; 104
 318:	81 e1       	ldi	r24, 0x11	; 17
 31a:	90 e0       	ldi	r25, 0x00	; 0
 31c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// LCD driver AC setting
	writeToRegister(0x02, 0x0000);
 320:	60 e0       	ldi	r22, 0x00	; 0
 322:	70 e0       	ldi	r23, 0x00	; 0
 324:	82 e0       	ldi	r24, 0x02	; 2
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
	// Ram data write
	fillScreen(Light_Yellow);
 32c:	8f ef       	ldi	r24, 0xFF	; 255
 32e:	9f e7       	ldi	r25, 0x7F	; 127
 330:	0e 94 72 00 	call	0xe4	; 0xe4 <fillScreen>
	colorTest();
 334:	0e 94 9d 00 	call	0x13a	; 0x13a <colorTest>
	fillScreen(Light_Blue);
 338:	87 ee       	ldi	r24, 0xE7	; 231
 33a:	9c ef       	ldi	r25, 0xFC	; 252
 33c:	0e 94 72 00 	call	0xe4	; 0xe4 <fillScreen>
	colorTest();
 340:	0e 94 9d 00 	call	0x13a	; 0x13a <colorTest>
 344:	08 95       	ret

00000346 <main>:
}

int main(void)
{	
	// Startup sequence
    initUART(); // initialize the UART
 346:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <initUART>
	initHY32D(); // initialize HY32D screen
 34a:	0e 94 24 01 	call	0x248	; 0x248 <initHY32D>
	sei(); //Enable global interrupt
 34e:	78 94       	sei
	startupMessage();
 350:	0e 94 42 02 	call	0x484	; 0x484 <startupMessage>
 354:	ff cf       	rjmp	.-2      	; 0x354 <main+0xe>

00000356 <__vector_13>:
		Tegn fra flashminnet til skjermen via tellere
		*/
    }
}

ISR(USART0_RX_vect){
 356:	1f 92       	push	r1
 358:	0f 92       	push	r0
 35a:	0f b6       	in	r0, 0x3f	; 63
 35c:	0f 92       	push	r0
 35e:	11 24       	eor	r1, r1
 360:	2f 93       	push	r18
 362:	3f 93       	push	r19
 364:	4f 93       	push	r20
 366:	5f 93       	push	r21
 368:	6f 93       	push	r22
 36a:	7f 93       	push	r23
 36c:	8f 93       	push	r24
 36e:	9f 93       	push	r25
 370:	af 93       	push	r26
 372:	bf 93       	push	r27
 374:	cf 93       	push	r28
 376:	ef 93       	push	r30
 378:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	unsigned char receivedByte = UARTBuffer; // local temporary variable for received byte
 37a:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 37e:	cc 23       	and	r28, r28
 380:	61 f0       	breq	.+24     	; 0x39a <__vector_13+0x44>
		if (receivedByte == 45) { // that's the '-' sign.
 382:	cd 32       	cpi	r28, 0x2D	; 45
 384:	31 f4       	brne	.+12     	; 0x392 <__vector_13+0x3c>
			remoteEcho = ~remoteEcho;
 386:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 38a:	80 95       	com	r24
 38c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 390:	04 c0       	rjmp	.+8      	; 0x39a <__vector_13+0x44>
		}else if(receivedByte == S){
 392:	c3 35       	cpi	r28, 0x53	; 83
 394:	11 f4       	brne	.+4      	; 0x39a <__vector_13+0x44>
			systemCheck();
 396:	0e 94 14 02 	call	0x428	; 0x428 <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 39a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 39e:	88 23       	and	r24, r24
 3a0:	79 f0       	breq	.+30     	; 0x3c0 <__vector_13+0x6a>
 3a2:	c0 32       	cpi	r28, 0x20	; 32
 3a4:	40 f4       	brcc	.+16     	; 0x3b6 <__vector_13+0x60>
 3a6:	c7 30       	cpi	r28, 0x07	; 7
 3a8:	31 f0       	breq	.+12     	; 0x3b6 <__vector_13+0x60>
 3aa:	cd 30       	cpi	r28, 0x0D	; 13
 3ac:	21 f0       	breq	.+8      	; 0x3b6 <__vector_13+0x60>
 3ae:	ca 30       	cpi	r28, 0x0A	; 10
 3b0:	11 f0       	breq	.+4      	; 0x3b6 <__vector_13+0x60>
 3b2:	c8 30       	cpi	r28, 0x08	; 8
 3b4:	29 f4       	brne	.+10     	; 0x3c0 <__vector_13+0x6a>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 3b6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 3ba:	85 fd       	sbrc	r24, 5
			UARTBuffer = receivedByte;
 3bc:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
 3c0:	ff 91       	pop	r31
 3c2:	ef 91       	pop	r30
 3c4:	cf 91       	pop	r28
 3c6:	bf 91       	pop	r27
 3c8:	af 91       	pop	r26
 3ca:	9f 91       	pop	r25
 3cc:	8f 91       	pop	r24
 3ce:	7f 91       	pop	r23
 3d0:	6f 91       	pop	r22
 3d2:	5f 91       	pop	r21
 3d4:	4f 91       	pop	r20
 3d6:	3f 91       	pop	r19
 3d8:	2f 91       	pop	r18
 3da:	0f 90       	pop	r0
 3dc:	0f be       	out	0x3f, r0	; 63
 3de:	0f 90       	pop	r0
 3e0:	1f 90       	pop	r1
 3e2:	18 95       	reti

000003e4 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 3e4:	8f e2       	ldi	r24, 0x2F	; 47
 3e6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 3ea:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 3ee:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 3f2:	88 e9       	ldi	r24, 0x98	; 152
 3f4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 3f8:	86 e0       	ldi	r24, 0x06	; 6
 3fa:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 3fe:	08 95       	ret

00000400 <transmitUART>:
}

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 400:	20 e0       	ldi	r18, 0x00	; 0
 402:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 404:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 408:	95 ff       	sbrs	r25, 5
 40a:	05 c0       	rjmp	.+10     	; 0x416 <transmitUART+0x16>
			UARTBuffer = data;
 40c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 410:	81 e0       	ldi	r24, 0x01	; 1
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	08 95       	ret
			}else{
			timeout++;
 416:	2f 5f       	subi	r18, 0xFF	; 255
 418:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 41a:	29 3e       	cpi	r18, 0xE9	; 233
 41c:	93 e0       	ldi	r25, 0x03	; 3
 41e:	39 07       	cpc	r19, r25
 420:	8c f3       	brlt	.-30     	; 0x404 <transmitUART+0x4>
				return 0;
 422:	80 e0       	ldi	r24, 0x00	; 0
 424:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 426:	08 95       	ret

00000428 <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 428:	8d e0       	ldi	r24, 0x0D	; 13
 42a:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(S);
 42e:	83 e5       	ldi	r24, 0x53	; 83
 430:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(y);
 434:	89 e7       	ldi	r24, 0x79	; 121
 436:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(s);
 43a:	83 e7       	ldi	r24, 0x73	; 115
 43c:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(t);
 440:	84 e7       	ldi	r24, 0x74	; 116
 442:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(e);
 446:	85 e6       	ldi	r24, 0x65	; 101
 448:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(m);
 44c:	8d e6       	ldi	r24, 0x6D	; 109
 44e:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(_space);
 452:	80 e2       	ldi	r24, 0x20	; 32
 454:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(c);
 458:	83 e6       	ldi	r24, 0x63	; 99
 45a:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(h);
 45e:	88 e6       	ldi	r24, 0x68	; 104
 460:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(e);
 464:	85 e6       	ldi	r24, 0x65	; 101
 466:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(c);
 46a:	83 e6       	ldi	r24, 0x63	; 99
 46c:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(k);
 470:	8b e6       	ldi	r24, 0x6B	; 107
 472:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(_colon);
 476:	8a e3       	ldi	r24, 0x3A	; 58
 478:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(CR);
 47c:	8d e0       	ldi	r24, 0x0D	; 13
 47e:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
 482:	08 95       	ret

00000484 <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART(CR);
 484:	8d e0       	ldi	r24, 0x0D	; 13
 486:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(B);
 48a:	82 e4       	ldi	r24, 0x42	; 66
 48c:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(l);
 490:	8c e6       	ldi	r24, 0x6C	; 108
 492:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(i);
 496:	89 e6       	ldi	r24, 0x69	; 105
 498:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(t);
 49c:	84 e7       	ldi	r24, 0x74	; 116
 49e:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(t);
 4a2:	84 e7       	ldi	r24, 0x74	; 116
 4a4:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(e);
 4a8:	85 e6       	ldi	r24, 0x65	; 101
 4aa:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(r);
 4ae:	82 e7       	ldi	r24, 0x72	; 114
 4b0:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(_space);
 4b4:	80 e2       	ldi	r24, 0x20	; 32
 4b6:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(r);
 4ba:	82 e7       	ldi	r24, 0x72	; 114
 4bc:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(e);
 4c0:	85 e6       	ldi	r24, 0x65	; 101
 4c2:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(a);
 4c6:	81 e6       	ldi	r24, 0x61	; 97
 4c8:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(d);
 4cc:	84 e6       	ldi	r24, 0x64	; 100
 4ce:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(y);
 4d2:	89 e7       	ldi	r24, 0x79	; 121
 4d4:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
	transmitUART(CR);
 4d8:	8d e0       	ldi	r24, 0x0D	; 13
 4da:	0e 94 00 02 	call	0x400	; 0x400 <transmitUART>
 4de:	08 95       	ret

000004e0 <_exit>:
 4e0:	f8 94       	cli

000004e2 <__stop_program>:
 4e2:	ff cf       	rjmp	.-2      	; 0x4e2 <__stop_program>
