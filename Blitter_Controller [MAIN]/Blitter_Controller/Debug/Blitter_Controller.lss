
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000075a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006e6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  0000075a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000075a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000078c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000158  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001b39  00000000  00000000  00000924  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c44  00000000  00000000  0000245d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cfc  00000000  00000000  000030a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002e4  00000000  00000000  00003da0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000070c  00000000  00000000  00004084  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009a3  00000000  00000000  00004790  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  00005133  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 6f 02 	jmp	0x4de	; 0x4de <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 5f 02 	call	0x4be	; 0x4be <main>
  7c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DC_HIGH;
	WR_BLT_CLK_HIGH;
	data = readDataLines();
	transmitUART((char)data);
	return data;
}
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <setIOtoOutput>:
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	81 b9       	out	0x01, r24	; 1
  e8:	87 b9       	out	0x07, r24	; 7
  ea:	08 95       	ret

000000ec <setIOtoInput>:
  ec:	11 b8       	out	0x01, r1	; 1
  ee:	17 b8       	out	0x07, r1	; 7
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	8f e3       	ldi	r24, 0x3F	; 63
  f4:	92 e0       	ldi	r25, 0x02	; 2
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <setIOtoInput+0xa>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <setIOtoInput+0x14>
 100:	00 00       	nop
 102:	08 95       	ret

00000104 <fillScreen>:
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ef 92       	push	r14
 10a:	ff 92       	push	r15
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	ec 01       	movw	r28, r24
 112:	85 b1       	in	r24, 0x05	; 5
 114:	8f 7b       	andi	r24, 0xBF	; 191
 116:	85 b9       	out	0x05, r24	; 5
 118:	82 e2       	ldi	r24, 0x22	; 34
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	c1 2c       	mov	r12, r1
 122:	d1 2c       	mov	r13, r1
 124:	76 01       	movw	r14, r12
 126:	08 c0       	rjmp	.+16     	; 0x138 <fillScreen+0x34>
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 12e:	8f ef       	ldi	r24, 0xFF	; 255
 130:	c8 1a       	sub	r12, r24
 132:	d8 0a       	sbc	r13, r24
 134:	e8 0a       	sbc	r14, r24
 136:	f8 0a       	sbc	r15, r24
 138:	c1 14       	cp	r12, r1
 13a:	8c e2       	ldi	r24, 0x2C	; 44
 13c:	d8 06       	cpc	r13, r24
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	e8 06       	cpc	r14, r24
 142:	f1 04       	cpc	r15, r1
 144:	88 f3       	brcs	.-30     	; 0x128 <fillScreen+0x24>
 146:	85 b1       	in	r24, 0x05	; 5
 148:	80 64       	ori	r24, 0x40	; 64
 14a:	85 b9       	out	0x05, r24	; 5
 14c:	df 91       	pop	r29
 14e:	cf 91       	pop	r28
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

0000015a <colorTest>:
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	85 b1       	in	r24, 0x05	; 5
 160:	8f 7b       	andi	r24, 0xBF	; 191
 162:	85 b9       	out	0x05, r24	; 5
 164:	82 e2       	ldi	r24, 0x22	; 34
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 16c:	c0 e0       	ldi	r28, 0x00	; 0
 16e:	d0 e0       	ldi	r29, 0x00	; 0
 170:	05 c0       	rjmp	.+10     	; 0x17c <colorTest+0x22>
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	9f ef       	ldi	r25, 0xFF	; 255
 176:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 17a:	21 96       	adiw	r28, 0x01	; 1
 17c:	c1 15       	cp	r28, r1
 17e:	8e e1       	ldi	r24, 0x1E	; 30
 180:	d8 07       	cpc	r29, r24
 182:	bc f3       	brlt	.-18     	; 0x172 <colorTest+0x18>
 184:	c0 e0       	ldi	r28, 0x00	; 0
 186:	d0 e0       	ldi	r29, 0x00	; 0
 188:	05 c0       	rjmp	.+10     	; 0x194 <colorTest+0x3a>
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 192:	21 96       	adiw	r28, 0x01	; 1
 194:	c1 15       	cp	r28, r1
 196:	8e e1       	ldi	r24, 0x1E	; 30
 198:	d8 07       	cpc	r29, r24
 19a:	bc f3       	brlt	.-18     	; 0x18a <colorTest+0x30>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <colorTest+0x52>
 1a2:	8e ed       	ldi	r24, 0xDE	; 222
 1a4:	97 ef       	ldi	r25, 0xF7	; 247
 1a6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1aa:	21 96       	adiw	r28, 0x01	; 1
 1ac:	c1 15       	cp	r28, r1
 1ae:	8e e1       	ldi	r24, 0x1E	; 30
 1b0:	d8 07       	cpc	r29, r24
 1b2:	bc f3       	brlt	.-18     	; 0x1a2 <colorTest+0x48>
 1b4:	c0 e0       	ldi	r28, 0x00	; 0
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <colorTest+0x6a>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	98 ef       	ldi	r25, 0xF8	; 248
 1be:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1c2:	21 96       	adiw	r28, 0x01	; 1
 1c4:	c1 15       	cp	r28, r1
 1c6:	8e e1       	ldi	r24, 0x1E	; 30
 1c8:	d8 07       	cpc	r29, r24
 1ca:	bc f3       	brlt	.-18     	; 0x1ba <colorTest+0x60>
 1cc:	c0 e0       	ldi	r28, 0x00	; 0
 1ce:	d0 e0       	ldi	r29, 0x00	; 0
 1d0:	05 c0       	rjmp	.+10     	; 0x1dc <colorTest+0x82>
 1d2:	87 ee       	ldi	r24, 0xE7	; 231
 1d4:	9c ef       	ldi	r25, 0xFC	; 252
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	c1 15       	cp	r28, r1
 1de:	8e e1       	ldi	r24, 0x1E	; 30
 1e0:	d8 07       	cpc	r29, r24
 1e2:	bc f3       	brlt	.-18     	; 0x1d2 <colorTest+0x78>
 1e4:	c0 e0       	ldi	r28, 0x00	; 0
 1e6:	d0 e0       	ldi	r29, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <colorTest+0x9a>
 1ea:	8f e1       	ldi	r24, 0x1F	; 31
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1f2:	21 96       	adiw	r28, 0x01	; 1
 1f4:	c1 15       	cp	r28, r1
 1f6:	8e e1       	ldi	r24, 0x1E	; 30
 1f8:	d8 07       	cpc	r29, r24
 1fa:	bc f3       	brlt	.-18     	; 0x1ea <colorTest+0x90>
 1fc:	c0 e0       	ldi	r28, 0x00	; 0
 1fe:	d0 e0       	ldi	r29, 0x00	; 0
 200:	05 c0       	rjmp	.+10     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
 202:	8f e1       	ldi	r24, 0x1F	; 31
 204:	98 ef       	ldi	r25, 0xF8	; 248
 206:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	c1 15       	cp	r28, r1
 20e:	8e e1       	ldi	r24, 0x1E	; 30
 210:	d8 07       	cpc	r29, r24
 212:	bc f3       	brlt	.-18     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
 214:	c0 e0       	ldi	r28, 0x00	; 0
 216:	d0 e0       	ldi	r29, 0x00	; 0
 218:	05 c0       	rjmp	.+10     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	97 e0       	ldi	r25, 0x07	; 7
 21e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 222:	21 96       	adiw	r28, 0x01	; 1
 224:	c1 15       	cp	r28, r1
 226:	8e e1       	ldi	r24, 0x1E	; 30
 228:	d8 07       	cpc	r29, r24
 22a:	bc f3       	brlt	.-18     	; 0x21a <__EEPROM_REGION_LENGTH__+0x1a>
 22c:	c0 e0       	ldi	r28, 0x00	; 0
 22e:	d0 e0       	ldi	r29, 0x00	; 0
 230:	05 c0       	rjmp	.+10     	; 0x23c <__EEPROM_REGION_LENGTH__+0x3c>
 232:	80 ee       	ldi	r24, 0xE0	; 224
 234:	9f ef       	ldi	r25, 0xFF	; 255
 236:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 23a:	21 96       	adiw	r28, 0x01	; 1
 23c:	c1 15       	cp	r28, r1
 23e:	8e e1       	ldi	r24, 0x1E	; 30
 240:	d8 07       	cpc	r29, r24
 242:	bc f3       	brlt	.-18     	; 0x232 <__EEPROM_REGION_LENGTH__+0x32>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 24a:	8f e1       	ldi	r24, 0x1F	; 31
 24c:	95 e0       	ldi	r25, 0x05	; 5
 24e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 252:	21 96       	adiw	r28, 0x01	; 1
 254:	c1 15       	cp	r28, r1
 256:	8e e1       	ldi	r24, 0x1E	; 30
 258:	d8 07       	cpc	r29, r24
 25a:	bc f3       	brlt	.-18     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 25c:	85 b1       	in	r24, 0x05	; 5
 25e:	80 64       	ori	r24, 0x40	; 64
 260:	85 b9       	out	0x05, r24	; 5
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <initHY32D>:
 268:	84 b1       	in	r24, 0x04	; 4
 26a:	80 64       	ori	r24, 0x40	; 64
 26c:	84 b9       	out	0x04, r24	; 4
 26e:	84 b1       	in	r24, 0x04	; 4
 270:	80 62       	ori	r24, 0x20	; 32
 272:	84 b9       	out	0x04, r24	; 4
 274:	84 b1       	in	r24, 0x04	; 4
 276:	80 61       	ori	r24, 0x10	; 16
 278:	84 b9       	out	0x04, r24	; 4
 27a:	8d b1       	in	r24, 0x0d	; 13
 27c:	80 64       	ori	r24, 0x40	; 64
 27e:	8d b9       	out	0x0d, r24	; 13
 280:	8d b1       	in	r24, 0x0d	; 13
 282:	80 68       	ori	r24, 0x80	; 128
 284:	8d b9       	out	0x0d, r24	; 13
 286:	85 b1       	in	r24, 0x05	; 5
 288:	80 64       	ori	r24, 0x40	; 64
 28a:	85 b9       	out	0x05, r24	; 5
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	80 61       	ori	r24, 0x10	; 16
 290:	85 b9       	out	0x05, r24	; 5
 292:	8e b1       	in	r24, 0x0e	; 14
 294:	80 64       	ori	r24, 0x40	; 64
 296:	8e b9       	out	0x0e, r24	; 14
 298:	8e b1       	in	r24, 0x0e	; 14
 29a:	80 68       	ori	r24, 0x80	; 128
 29c:	8e b9       	out	0x0e, r24	; 14
 29e:	8f ef       	ldi	r24, 0xFF	; 255
 2a0:	81 b9       	out	0x01, r24	; 1
 2a2:	87 b9       	out	0x07, r24	; 7
 2a4:	2f ef       	ldi	r18, 0xFF	; 255
 2a6:	8f e3       	ldi	r24, 0x3F	; 63
 2a8:	92 e0       	ldi	r25, 0x02	; 2
 2aa:	21 50       	subi	r18, 0x01	; 1
 2ac:	80 40       	sbci	r24, 0x00	; 0
 2ae:	90 40       	sbci	r25, 0x00	; 0
 2b0:	e1 f7       	brne	.-8      	; 0x2aa <initHY32D+0x42>
 2b2:	00 c0       	rjmp	.+0      	; 0x2b4 <initHY32D+0x4c>
 2b4:	00 00       	nop
 2b6:	85 b1       	in	r24, 0x05	; 5
 2b8:	81 60       	ori	r24, 0x01	; 1
 2ba:	85 b9       	out	0x05, r24	; 5
 2bc:	8f ef       	ldi	r24, 0xFF	; 255
 2be:	93 e2       	ldi	r25, 0x23	; 35
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <initHY32D+0x58>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <initHY32D+0x5e>
 2c6:	00 00       	nop
 2c8:	85 b1       	in	r24, 0x05	; 5
 2ca:	8e 7f       	andi	r24, 0xFE	; 254
 2cc:	85 b9       	out	0x05, r24	; 5
 2ce:	8f ef       	ldi	r24, 0xFF	; 255
 2d0:	9b e6       	ldi	r25, 0x6B	; 107
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <initHY32D+0x6a>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <initHY32D+0x70>
 2d8:	00 00       	nop
 2da:	85 b1       	in	r24, 0x05	; 5
 2dc:	81 60       	ori	r24, 0x01	; 1
 2de:	85 b9       	out	0x05, r24	; 5
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	9b e6       	ldi	r25, 0x6B	; 107
 2e4:	01 97       	sbiw	r24, 0x01	; 1
 2e6:	f1 f7       	brne	.-4      	; 0x2e4 <initHY32D+0x7c>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <initHY32D+0x82>
 2ea:	00 00       	nop
 2ec:	61 e2       	ldi	r22, 0x21	; 33
 2ee:	70 e0       	ldi	r23, 0x00	; 0
 2f0:	87 e0       	ldi	r24, 0x07	; 7
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	70 e0       	ldi	r23, 0x00	; 0
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 304:	63 e2       	ldi	r22, 0x23	; 35
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	87 e0       	ldi	r24, 0x07	; 7
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	70 e0       	ldi	r23, 0x00	; 0
 314:	80 e1       	ldi	r24, 0x10	; 16
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	97 ed       	ldi	r25, 0xD7	; 215
 320:	01 97       	sbiw	r24, 0x01	; 1
 322:	f1 f7       	brne	.-4      	; 0x320 <initHY32D+0xb8>
 324:	00 c0       	rjmp	.+0      	; 0x326 <initHY32D+0xbe>
 326:	00 00       	nop
 328:	63 e3       	ldi	r22, 0x33	; 51
 32a:	70 e0       	ldi	r23, 0x00	; 0
 32c:	87 e0       	ldi	r24, 0x07	; 7
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 334:	60 e3       	ldi	r22, 0x30	; 48
 336:	78 e6       	ldi	r23, 0x68	; 104
 338:	81 e1       	ldi	r24, 0x11	; 17
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	82 e0       	ldi	r24, 0x02	; 2
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 34c:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 350:	08 95       	ret

00000352 <screenTest>:
 352:	85 b1       	in	r24, 0x05	; 5
 354:	8f 7b       	andi	r24, 0xBF	; 191
 356:	85 b9       	out	0x05, r24	; 5
 358:	8f ef       	ldi	r24, 0xFF	; 255
 35a:	9f ef       	ldi	r25, 0xFF	; 255
 35c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 360:	80 e0       	ldi	r24, 0x00	; 0
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 368:	8e ed       	ldi	r24, 0xDE	; 222
 36a:	97 ef       	ldi	r25, 0xF7	; 247
 36c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 370:	8f e1       	ldi	r24, 0x1F	; 31
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 378:	8f e1       	ldi	r24, 0x1F	; 31
 37a:	95 e0       	ldi	r25, 0x05	; 5
 37c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 380:	80 e0       	ldi	r24, 0x00	; 0
 382:	98 ef       	ldi	r25, 0xF8	; 248
 384:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 388:	8f e1       	ldi	r24, 0x1F	; 31
 38a:	98 ef       	ldi	r25, 0xF8	; 248
 38c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 390:	80 ee       	ldi	r24, 0xE0	; 224
 392:	97 e0       	ldi	r25, 0x07	; 7
 394:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 398:	80 ee       	ldi	r24, 0xE0	; 224
 39a:	9f ef       	ldi	r25, 0xFF	; 255
 39c:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a0:	8f ef       	ldi	r24, 0xFF	; 255
 3a2:	9f e7       	ldi	r25, 0x7F	; 127
 3a4:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3a8:	87 ee       	ldi	r24, 0xE7	; 231
 3aa:	9c ef       	ldi	r25, 0xFC	; 252
 3ac:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 3b0:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 3b4:	85 b1       	in	r24, 0x05	; 5
 3b6:	80 64       	ori	r24, 0x40	; 64
 3b8:	85 b9       	out	0x05, r24	; 5
 3ba:	08 95       	ret

000003bc <readDataLines>:
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
 3c0:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
 3c4:	8e b1       	in	r24, 0x0e	; 14
 3c6:	8f 7b       	andi	r24, 0xBF	; 191
 3c8:	8e b9       	out	0x0e, r24	; 14
 3ca:	86 b1       	in	r24, 0x06	; 6
 3cc:	80 b1       	in	r24, 0x00	; 0
 3ce:	c6 b1       	in	r28, 0x06	; 6
 3d0:	d0 e0       	ldi	r29, 0x00	; 0
 3d2:	dc 2f       	mov	r29, r28
 3d4:	cc 27       	eor	r28, r28
 3d6:	80 b1       	in	r24, 0x00	; 0
 3d8:	c8 2b       	or	r28, r24
 3da:	8e b1       	in	r24, 0x0e	; 14
 3dc:	80 64       	ori	r24, 0x40	; 64
 3de:	8e b9       	out	0x0e, r24	; 14
 3e0:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
 3e4:	ce 01       	movw	r24, r28
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	08 95       	ret

000003ec <lcdStatusRead>:

void lcdStatusRead(void){ // reads SR register
 3ec:	1f 93       	push	r17
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
	unsigned short data;
	CS_LOW;
 3f2:	85 b1       	in	r24, 0x05	; 5
 3f4:	8f 7b       	andi	r24, 0xBF	; 191
 3f6:	85 b9       	out	0x05, r24	; 5
	DC_LOW;
 3f8:	8e b1       	in	r24, 0x0e	; 14
 3fa:	8f 77       	andi	r24, 0x7F	; 127
 3fc:	8e b9       	out	0x0e, r24	; 14
	data = readDataLines();// read data coming through IO lines
 3fe:	0e 94 de 01 	call	0x3bc	; 0x3bc <readDataLines>
 402:	c8 2f       	mov	r28, r24
 404:	d9 2f       	mov	r29, r25
	uint8_t udata = ((data >> 8) & 0xFF);
	uint8_t ldata = (data & 0xFF);
	transmitUART(CR);
 406:	8d e0       	ldi	r24, 0x0D	; 13
 408:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('S'); 	transmitUART('C'); 	transmitUART('R'); transmitUART('E'); 	transmitUART('E');
 40c:	83 e5       	ldi	r24, 0x53	; 83
 40e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 412:	83 e4       	ldi	r24, 0x43	; 67
 414:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 418:	82 e5       	ldi	r24, 0x52	; 82
 41a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 41e:	85 e4       	ldi	r24, 0x45	; 69
 420:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 424:	85 e4       	ldi	r24, 0x45	; 69
 426:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('N'); 	transmitUART(' '); transmitUART('S'); 	transmitUART('T'); transmitUART('A');
 42a:	8e e4       	ldi	r24, 0x4E	; 78
 42c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 430:	80 e2       	ldi	r24, 0x20	; 32
 432:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 436:	83 e5       	ldi	r24, 0x53	; 83
 438:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 43c:	84 e5       	ldi	r24, 0x54	; 84
 43e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 442:	81 e4       	ldi	r24, 0x41	; 65
 444:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('T'); 	transmitUART('U'); transmitUART('S'); 	transmitUART(':'); transmitUART(' ');
 448:	84 e5       	ldi	r24, 0x54	; 84
 44a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 44e:	85 e5       	ldi	r24, 0x55	; 85
 450:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 454:	83 e5       	ldi	r24, 0x53	; 83
 456:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 45a:	8a e3       	ldi	r24, 0x3A	; 58
 45c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 460:	80 e2       	ldi	r24, 0x20	; 32
 462:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('0');
 466:	80 e3       	ldi	r24, 0x30	; 48
 468:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('x');
 46c:	88 e7       	ldi	r24, 0x78	; 120
 46e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	uint8_t udatauhex = ((udata >> 4) & 0x0F);
	uint8_t udatalhex = (udata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 472:	1d 2f       	mov	r17, r29
 474:	1f 70       	andi	r17, 0x0F	; 15
	transmitUART(toHex(udatauhex));
 476:	8d 2f       	mov	r24, r29
 478:	82 95       	swap	r24
 47a:	8f 70       	andi	r24, 0x0F	; 15
 47c:	0e 94 c7 02 	call	0x58e	; 0x58e <toHex>
 480:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART(toHex(udatalhex));
 484:	81 2f       	mov	r24, r17
 486:	0e 94 c7 02 	call	0x58e	; 0x58e <toHex>
 48a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	uint8_t ldatauhex = ((ldata >> 4) & 0x0F);
	uint8_t ldatalhex = (ldata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 48e:	dc 2f       	mov	r29, r28
 490:	df 70       	andi	r29, 0x0F	; 15
	transmitUART(toHex(ldatauhex));
 492:	8c 2f       	mov	r24, r28
 494:	82 95       	swap	r24
 496:	8f 70       	andi	r24, 0x0F	; 15
 498:	0e 94 c7 02 	call	0x58e	; 0x58e <toHex>
 49c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART(toHex(ldatalhex));
 4a0:	8d 2f       	mov	r24, r29
 4a2:	0e 94 c7 02 	call	0x58e	; 0x58e <toHex>
 4a6:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART(CR);
 4aa:	8d e0       	ldi	r24, 0x0D	; 13
 4ac:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	CS_HIGH;
 4b0:	85 b1       	in	r24, 0x05	; 5
 4b2:	80 64       	ori	r24, 0x40	; 64
 4b4:	85 b9       	out	0x05, r24	; 5
 4b6:	df 91       	pop	r29
 4b8:	cf 91       	pop	r28
 4ba:	1f 91       	pop	r17
 4bc:	08 95       	ret

000004be <main>:
int main(void)
{	
	// Startup sequence
	
	// Init counters:
	DDRE |= (1 << PE3); // Setting LOAD to output;
 4be:	8d b1       	in	r24, 0x0d	; 13
 4c0:	88 60       	ori	r24, 0x08	; 8
 4c2:	8d b9       	out	0x0d, r24	; 13
	PORTE |= (1 << PE3); // Setting LOAD to high (disabled)
 4c4:	8e b1       	in	r24, 0x0e	; 14
 4c6:	88 60       	ori	r24, 0x08	; 8
 4c8:	8e b9       	out	0x0e, r24	; 14
	
    initUART(); // initialize the UART
 4ca:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <initUART>
	initHY32D(); // initialize HY32D screen
 4ce:	0e 94 34 01 	call	0x268	; 0x268 <initHY32D>
	sei(); //Enable global interrupt
 4d2:	78 94       	sei
	systemCheck();
 4d4:	0e 94 13 03 	call	0x626	; 0x626 <systemCheck>
	startupMessage();
 4d8:	0e 94 46 03 	call	0x68c	; 0x68c <startupMessage>
 4dc:	ff cf       	rjmp	.-2      	; 0x4dc <main+0x1e>

000004de <__vector_13>:
		- INFO:Utviklingen vil skje på egen maskinvareplattform.
		*/
    }
}

ISR(USART0_RX_vect){
 4de:	1f 92       	push	r1
 4e0:	0f 92       	push	r0
 4e2:	0f b6       	in	r0, 0x3f	; 63
 4e4:	0f 92       	push	r0
 4e6:	11 24       	eor	r1, r1
 4e8:	2f 93       	push	r18
 4ea:	3f 93       	push	r19
 4ec:	4f 93       	push	r20
 4ee:	5f 93       	push	r21
 4f0:	6f 93       	push	r22
 4f2:	7f 93       	push	r23
 4f4:	8f 93       	push	r24
 4f6:	9f 93       	push	r25
 4f8:	af 93       	push	r26
 4fa:	bf 93       	push	r27
 4fc:	cf 93       	push	r28
 4fe:	ef 93       	push	r30
 500:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	uint8_t receivedByte = UARTBuffer; // local temporary variable for received byte
 502:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 506:	cc 23       	and	r28, r28
 508:	f9 f0       	breq	.+62     	; 0x548 <__stack+0x49>
		if (receivedByte == 45) { // that's the '-' sign.
 50a:	cd 32       	cpi	r28, 0x2D	; 45
 50c:	31 f4       	brne	.+12     	; 0x51a <__stack+0x1b>
			remoteEcho = ~remoteEcho;
 50e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 512:	80 95       	com	r24
 514:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 518:	17 c0       	rjmp	.+46     	; 0x548 <__stack+0x49>
		}else if(receivedByte == 's'){
 51a:	c3 37       	cpi	r28, 0x73	; 115
 51c:	19 f4       	brne	.+6      	; 0x524 <__stack+0x25>
			systemCheck();
 51e:	0e 94 13 03 	call	0x626	; 0x626 <systemCheck>
 522:	12 c0       	rjmp	.+36     	; 0x548 <__stack+0x49>
		}else if(receivedByte == 'l'){
 524:	cc 36       	cpi	r28, 0x6C	; 108
 526:	19 f4       	brne	.+6      	; 0x52e <__stack+0x2f>
			lcdStatusRead();
 528:	0e 94 f6 01 	call	0x3ec	; 0x3ec <lcdStatusRead>
 52c:	0d c0       	rjmp	.+26     	; 0x548 <__stack+0x49>
		}else if(receivedByte == 'b'){
 52e:	c2 36       	cpi	r28, 0x62	; 98
 530:	29 f4       	brne	.+10     	; 0x53c <__stack+0x3d>
			fillScreen(Blue);
 532:	80 e0       	ldi	r24, 0x00	; 0
 534:	98 ef       	ldi	r25, 0xF8	; 248
 536:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 53a:	06 c0       	rjmp	.+12     	; 0x548 <__stack+0x49>
		}else if(receivedByte == 'r'){
 53c:	c2 37       	cpi	r28, 0x72	; 114
 53e:	21 f0       	breq	.+8      	; 0x548 <__stack+0x49>
			//drawImage(image);
		}else if(receivedByte == 'T'){
 540:	c4 35       	cpi	r28, 0x54	; 84
 542:	11 f4       	brne	.+4      	; 0x548 <__stack+0x49>
			screenTest();
 544:	0e 94 a9 01 	call	0x352	; 0x352 <screenTest>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 548:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 54c:	88 23       	and	r24, r24
 54e:	69 f0       	breq	.+26     	; 0x56a <__stack+0x6b>
 550:	c0 32       	cpi	r28, 0x20	; 32
 552:	40 f4       	brcc	.+16     	; 0x564 <__stack+0x65>
 554:	c7 30       	cpi	r28, 0x07	; 7
 556:	31 f0       	breq	.+12     	; 0x564 <__stack+0x65>
 558:	cd 30       	cpi	r28, 0x0D	; 13
 55a:	21 f0       	breq	.+8      	; 0x564 <__stack+0x65>
 55c:	ca 30       	cpi	r28, 0x0A	; 10
 55e:	11 f0       	breq	.+4      	; 0x564 <__stack+0x65>
 560:	c8 30       	cpi	r28, 0x08	; 8
 562:	19 f4       	brne	.+6      	; 0x56a <__stack+0x6b>
		transmitUART(receivedByte);
 564:	8c 2f       	mov	r24, r28
 566:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	}
 56a:	ff 91       	pop	r31
 56c:	ef 91       	pop	r30
 56e:	cf 91       	pop	r28
 570:	bf 91       	pop	r27
 572:	af 91       	pop	r26
 574:	9f 91       	pop	r25
 576:	8f 91       	pop	r24
 578:	7f 91       	pop	r23
 57a:	6f 91       	pop	r22
 57c:	5f 91       	pop	r21
 57e:	4f 91       	pop	r20
 580:	3f 91       	pop	r19
 582:	2f 91       	pop	r18
 584:	0f 90       	pop	r0
 586:	0f be       	out	0x3f, r0	; 63
 588:	0f 90       	pop	r0
 58a:	1f 90       	pop	r1
 58c:	18 95       	reti

0000058e <toHex>:
 58e:	80 5d       	subi	r24, 0xD0	; 208
 590:	8a 33       	cpi	r24, 0x3A	; 58
 592:	c0 f0       	brcs	.+48     	; 0x5c4 <toHex+0x36>
 594:	8a 33       	cpi	r24, 0x3A	; 58
 596:	59 f0       	breq	.+22     	; 0x5ae <toHex+0x20>
 598:	8b 33       	cpi	r24, 0x3B	; 59
 59a:	59 f0       	breq	.+22     	; 0x5b2 <toHex+0x24>
 59c:	8c 33       	cpi	r24, 0x3C	; 60
 59e:	59 f0       	breq	.+22     	; 0x5b6 <toHex+0x28>
 5a0:	8d 33       	cpi	r24, 0x3D	; 61
 5a2:	59 f0       	breq	.+22     	; 0x5ba <toHex+0x2c>
 5a4:	8e 33       	cpi	r24, 0x3E	; 62
 5a6:	59 f0       	breq	.+22     	; 0x5be <toHex+0x30>
 5a8:	8f 33       	cpi	r24, 0x3F	; 63
 5aa:	59 f0       	breq	.+22     	; 0x5c2 <toHex+0x34>
 5ac:	08 95       	ret
 5ae:	81 e4       	ldi	r24, 0x41	; 65
 5b0:	08 95       	ret
 5b2:	82 e4       	ldi	r24, 0x42	; 66
 5b4:	08 95       	ret
 5b6:	83 e4       	ldi	r24, 0x43	; 67
 5b8:	08 95       	ret
 5ba:	84 e4       	ldi	r24, 0x44	; 68
 5bc:	08 95       	ret
 5be:	85 e4       	ldi	r24, 0x45	; 69
 5c0:	08 95       	ret
 5c2:	86 e4       	ldi	r24, 0x46	; 70
 5c4:	08 95       	ret

000005c6 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 5c6:	8f e2       	ldi	r24, 0x2F	; 47
 5c8:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 5cc:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 5d0:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 5d4:	88 e9       	ldi	r24, 0x98	; 152
 5d6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 5da:	86 e0       	ldi	r24, 0x06	; 6
 5dc:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 5e0:	08 95       	ret

000005e2 <puttyCompatibleCheck>:
}

uint8_t puttyCompatibleCheck(uint8_t byte){
	if((byte > 31) || (byte == Bell) || (byte == CR) || (byte == LF) || (byte == backspace)){
 5e2:	80 32       	cpi	r24, 0x20	; 32
 5e4:	48 f4       	brcc	.+18     	; 0x5f8 <puttyCompatibleCheck+0x16>
 5e6:	87 30       	cpi	r24, 0x07	; 7
 5e8:	39 f0       	breq	.+14     	; 0x5f8 <puttyCompatibleCheck+0x16>
 5ea:	8d 30       	cpi	r24, 0x0D	; 13
 5ec:	29 f0       	breq	.+10     	; 0x5f8 <puttyCompatibleCheck+0x16>
 5ee:	8a 30       	cpi	r24, 0x0A	; 10
 5f0:	19 f0       	breq	.+6      	; 0x5f8 <puttyCompatibleCheck+0x16>
 5f2:	88 30       	cpi	r24, 0x08	; 8
 5f4:	09 f0       	breq	.+2      	; 0x5f8 <puttyCompatibleCheck+0x16>
		return byte;
		}else{
		return (uint8_t)64;
 5f6:	80 e4       	ldi	r24, 0x40	; 64
	}
}
 5f8:	08 95       	ret

000005fa <transmitUART>:

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 5fa:	20 e0       	ldi	r18, 0x00	; 0
 5fc:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 5fe:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 602:	95 ff       	sbrs	r25, 5
 604:	07 c0       	rjmp	.+14     	; 0x614 <transmitUART+0x1a>
			UARTBuffer = puttyCompatibleCheck(data);
 606:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <puttyCompatibleCheck>
 60a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 60e:	81 e0       	ldi	r24, 0x01	; 1
 610:	90 e0       	ldi	r25, 0x00	; 0
 612:	08 95       	ret
			}else{
			timeout++;
 614:	2f 5f       	subi	r18, 0xFF	; 255
 616:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 618:	29 3e       	cpi	r18, 0xE9	; 233
 61a:	93 e0       	ldi	r25, 0x03	; 3
 61c:	39 07       	cpc	r19, r25
 61e:	7c f3       	brlt	.-34     	; 0x5fe <transmitUART+0x4>
				return 0;
 620:	80 e0       	ldi	r24, 0x00	; 0
 622:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 624:	08 95       	ret

00000626 <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 626:	8d e0       	ldi	r24, 0x0D	; 13
 628:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('-');
 62c:	8d e2       	ldi	r24, 0x2D	; 45
 62e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART(CR);
 632:	8d e0       	ldi	r24, 0x0D	; 13
 634:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('S');	transmitUART('y'); 	transmitUART('s'); 	transmitUART('t'); 	transmitUART('e');
 638:	83 e5       	ldi	r24, 0x53	; 83
 63a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 63e:	89 e7       	ldi	r24, 0x79	; 121
 640:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 644:	83 e7       	ldi	r24, 0x73	; 115
 646:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 64a:	84 e7       	ldi	r24, 0x74	; 116
 64c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 650:	85 e6       	ldi	r24, 0x65	; 101
 652:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('m');	transmitUART(' '); 	transmitUART('c'); 	transmitUART('h'); 	transmitUART('e');
 656:	8d e6       	ldi	r24, 0x6D	; 109
 658:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 65c:	80 e2       	ldi	r24, 0x20	; 32
 65e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 662:	83 e6       	ldi	r24, 0x63	; 99
 664:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 668:	88 e6       	ldi	r24, 0x68	; 104
 66a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 66e:	85 e6       	ldi	r24, 0x65	; 101
 670:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('c');	transmitUART('k'); 	transmitUART(':');
 674:	83 e6       	ldi	r24, 0x63	; 99
 676:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 67a:	8b e6       	ldi	r24, 0x6B	; 107
 67c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 680:	8a e3       	ldi	r24, 0x3A	; 58
 682:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	lcdStatusRead();
 686:	0e 94 f6 01 	call	0x3ec	; 0x3ec <lcdStatusRead>
 68a:	08 95       	ret

0000068c <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART('B');	transmitUART('l'); 	transmitUART('i'); 	transmitUART('t'); 	transmitUART('t');
 68c:	82 e4       	ldi	r24, 0x42	; 66
 68e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 692:	8c e6       	ldi	r24, 0x6C	; 108
 694:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 698:	89 e6       	ldi	r24, 0x69	; 105
 69a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 69e:	84 e7       	ldi	r24, 0x74	; 116
 6a0:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6a4:	84 e7       	ldi	r24, 0x74	; 116
 6a6:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('e');	transmitUART('r'); 	transmitUART(' '); 	transmitUART('r'); 	transmitUART('e');
 6aa:	85 e6       	ldi	r24, 0x65	; 101
 6ac:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6b0:	82 e7       	ldi	r24, 0x72	; 114
 6b2:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6b6:	80 e2       	ldi	r24, 0x20	; 32
 6b8:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6bc:	82 e7       	ldi	r24, 0x72	; 114
 6be:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6c2:	85 e6       	ldi	r24, 0x65	; 101
 6c4:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART('a');	transmitUART('d'); 	transmitUART('y');
 6c8:	81 e6       	ldi	r24, 0x61	; 97
 6ca:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6ce:	84 e6       	ldi	r24, 0x64	; 100
 6d0:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6d4:	89 e7       	ldi	r24, 0x79	; 121
 6d6:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
	transmitUART(CR);
 6da:	8d e0       	ldi	r24, 0x0D	; 13
 6dc:	0e 94 fd 02 	call	0x5fa	; 0x5fa <transmitUART>
 6e0:	08 95       	ret

000006e2 <_exit>:
 6e2:	f8 94       	cli

000006e4 <__stop_program>:
 6e4:	ff cf       	rjmp	.-2      	; 0x6e4 <__stop_program>
