
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000236  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001c2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800100  00800100  00000236  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000236  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000268  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  000002a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000bf5  00000000  00000000  00000328  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000965  00000000  00000000  00000f1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000475  00000000  00000000  00001882  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000110  00000000  00000000  00001cf8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000050c  00000000  00000000  00001e08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000168  00000000  00000000  00002314  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  0000247c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a2 30       	cpi	r26, 0x02	; 2
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 42 00 	call	0x84	; 0x84 <main>
  7c:	0c 94 df 00 	jmp	0x1be	; 0x1be <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <main>:
	
}
	
int main(void)
{	
    initUART(); // initialize the UART
  84:	0e 94 bd 00 	call	0x17a	; 0x17a <initUART>
	sei(); //Enable global interrupt
  88:	78 94       	sei
  8a:	ff cf       	rjmp	.-2      	; 0x8a <main+0x6>

0000008c <systemCheck>:
    }
}

// Type S for system check:
void systemCheck(){
	transmitUART(CR);
  8c:	8d e0       	ldi	r24, 0x0D	; 13
  8e:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(S);
  92:	83 e5       	ldi	r24, 0x53	; 83
  94:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(y);
  98:	89 e7       	ldi	r24, 0x79	; 121
  9a:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(s);
  9e:	83 e7       	ldi	r24, 0x73	; 115
  a0:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(t);
  a4:	84 e7       	ldi	r24, 0x74	; 116
  a6:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(e);
  aa:	85 e6       	ldi	r24, 0x65	; 101
  ac:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(m);
  b0:	8d e6       	ldi	r24, 0x6D	; 109
  b2:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(_space);
  b6:	80 e2       	ldi	r24, 0x20	; 32
  b8:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(c);
  bc:	83 e6       	ldi	r24, 0x63	; 99
  be:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(h);
  c2:	88 e6       	ldi	r24, 0x68	; 104
  c4:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(e);
  c8:	85 e6       	ldi	r24, 0x65	; 101
  ca:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(c);
  ce:	83 e6       	ldi	r24, 0x63	; 99
  d0:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(k);
  d4:	8b e6       	ldi	r24, 0x6B	; 107
  d6:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(_colon);
  da:	8a e3       	ldi	r24, 0x3A	; 58
  dc:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
	transmitUART(CR);
  e0:	8d e0       	ldi	r24, 0x0D	; 13
  e2:	0e 94 cb 00 	call	0x196	; 0x196 <transmitUART>
  e6:	08 95       	ret

000000e8 <__vector_13>:
	// Check and print results of various components on the blitter board:
}

ISR(USART0_RX_vect){
  e8:	1f 92       	push	r1
  ea:	0f 92       	push	r0
  ec:	0f b6       	in	r0, 0x3f	; 63
  ee:	0f 92       	push	r0
  f0:	11 24       	eor	r1, r1
  f2:	2f 93       	push	r18
  f4:	3f 93       	push	r19
  f6:	4f 93       	push	r20
  f8:	5f 93       	push	r21
  fa:	6f 93       	push	r22
  fc:	7f 93       	push	r23
  fe:	8f 93       	push	r24
 100:	9f 93       	push	r25
 102:	af 93       	push	r26
 104:	bf 93       	push	r27
 106:	ef 93       	push	r30
 108:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	receivedByte = UARTBuffer; // local temporary variable for received byte
 10a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
 10e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <receivedByte>
	if (receivedByte){
 112:	88 23       	and	r24, r24
 114:	61 f0       	breq	.+24     	; 0x12e <__vector_13+0x46>
		if (receivedByte == 45) { // that's the '-' sign.
 116:	8d 32       	cpi	r24, 0x2D	; 45
 118:	31 f4       	brne	.+12     	; 0x126 <__vector_13+0x3e>
			remoteEcho = ~remoteEcho;
 11a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 11e:	80 95       	com	r24
 120:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 124:	04 c0       	rjmp	.+8      	; 0x12e <__vector_13+0x46>
		}else if(receivedByte == S){
 126:	83 35       	cpi	r24, 0x53	; 83
 128:	11 f4       	brne	.+4      	; 0x12e <__vector_13+0x46>
			systemCheck();
 12a:	0e 94 46 00 	call	0x8c	; 0x8c <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 12e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 132:	88 23       	and	r24, r24
 134:	89 f0       	breq	.+34     	; 0x158 <__vector_13+0x70>
 136:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <receivedByte>
 13a:	80 32       	cpi	r24, 0x20	; 32
 13c:	40 f4       	brcc	.+16     	; 0x14e <__vector_13+0x66>
 13e:	87 30       	cpi	r24, 0x07	; 7
 140:	31 f0       	breq	.+12     	; 0x14e <__vector_13+0x66>
 142:	8d 30       	cpi	r24, 0x0D	; 13
 144:	21 f0       	breq	.+8      	; 0x14e <__vector_13+0x66>
 146:	8a 30       	cpi	r24, 0x0A	; 10
 148:	11 f0       	breq	.+4      	; 0x14e <__vector_13+0x66>
 14a:	88 30       	cpi	r24, 0x08	; 8
 14c:	29 f4       	brne	.+10     	; 0x158 <__vector_13+0x70>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 14e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 152:	95 fd       	sbrc	r25, 5
			UARTBuffer = receivedByte;
 154:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
 158:	ff 91       	pop	r31
 15a:	ef 91       	pop	r30
 15c:	bf 91       	pop	r27
 15e:	af 91       	pop	r26
 160:	9f 91       	pop	r25
 162:	8f 91       	pop	r24
 164:	7f 91       	pop	r23
 166:	6f 91       	pop	r22
 168:	5f 91       	pop	r21
 16a:	4f 91       	pop	r20
 16c:	3f 91       	pop	r19
 16e:	2f 91       	pop	r18
 170:	0f 90       	pop	r0
 172:	0f be       	out	0x3f, r0	; 63
 174:	0f 90       	pop	r0
 176:	1f 90       	pop	r1
 178:	18 95       	reti

0000017a <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 17a:	8f e2       	ldi	r24, 0x2F	; 47
 17c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 180:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 184:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 188:	88 e9       	ldi	r24, 0x98	; 152
 18a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 18e:	86 e0       	ldi	r24, 0x06	; 6
 190:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 194:	08 95       	ret

00000196 <transmitUART>:
}

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 196:	20 e0       	ldi	r18, 0x00	; 0
 198:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 19a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 19e:	95 ff       	sbrs	r25, 5
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <transmitUART+0x16>
			UARTBuffer = data;
 1a2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 1a6:	81 e0       	ldi	r24, 0x01	; 1
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	08 95       	ret
			}else{
			timeout++;
 1ac:	2f 5f       	subi	r18, 0xFF	; 255
 1ae:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 1b0:	29 3e       	cpi	r18, 0xE9	; 233
 1b2:	93 e0       	ldi	r25, 0x03	; 3
 1b4:	39 07       	cpc	r19, r25
 1b6:	8c f3       	brlt	.-30     	; 0x19a <transmitUART+0x4>
				return 0;
 1b8:	80 e0       	ldi	r24, 0x00	; 0
 1ba:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 1bc:	08 95       	ret

000001be <_exit>:
 1be:	f8 94       	cli

000001c0 <__stop_program>:
 1c0:	ff cf       	rjmp	.-2      	; 0x1c0 <__stop_program>
