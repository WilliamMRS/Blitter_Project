
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000091e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008aa  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  00800100  00800100  0000091e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000091e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000950  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000178  00000000  00000000  00000990  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d59  00000000  00000000  00000b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c66  00000000  00000000  00002861  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ea9  00000000  00000000  000034c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000338  00000000  00000000  00004370  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006e0  00000000  00000000  000046a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000abe  00000000  00000000  00004d88  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00005846  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 49 03 	jmp	0x692	; 0x692 <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a3 30       	cpi	r26, 0x03	; 3
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 15 03 	call	0x62a	; 0x62a <main>
  7c:	0c 94 53 04 	jmp	0x8a6	; 0x8a6 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	DC_HIGH;
	WR_BLT_CLK_HIGH;
	data = readDataLines();
	transmitUART((char)data);
	return data;
}
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
  9e:	82 b9       	out	0x02, r24	; 2
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
  a6:	2e b1       	in	r18, 0x0e	; 14
  a8:	20 68       	ori	r18, 0x80	; 128
  aa:	2e b9       	out	0x0e, r18	; 14
  ac:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
  b0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
  b4:	82 b9       	out	0x02, r24	; 2
  b6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
  ba:	88 b9       	out	0x08, r24	; 8
  bc:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  c0:	08 95       	ret

000000c2 <writeToRegister>:
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	eb 01       	movw	r28, r22
  c8:	25 b1       	in	r18, 0x05	; 5
  ca:	2f 7b       	andi	r18, 0xBF	; 191
  cc:	25 b9       	out	0x05, r18	; 5
  ce:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
  d2:	ce 01       	movw	r24, r28
  d4:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
  d8:	85 b1       	in	r24, 0x05	; 5
  da:	80 64       	ori	r24, 0x40	; 64
  dc:	85 b9       	out	0x05, r24	; 5
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <setIOtoOutput>:
  e4:	8f ef       	ldi	r24, 0xFF	; 255
  e6:	81 b9       	out	0x01, r24	; 1
  e8:	87 b9       	out	0x07, r24	; 7
  ea:	08 95       	ret

000000ec <setIOtoInput>:
  ec:	11 b8       	out	0x01, r1	; 1
  ee:	17 b8       	out	0x07, r1	; 7
  f0:	2f ef       	ldi	r18, 0xFF	; 255
  f2:	8f e3       	ldi	r24, 0x3F	; 63
  f4:	92 e0       	ldi	r25, 0x02	; 2
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	80 40       	sbci	r24, 0x00	; 0
  fa:	90 40       	sbci	r25, 0x00	; 0
  fc:	e1 f7       	brne	.-8      	; 0xf6 <setIOtoInput+0xa>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <setIOtoInput+0x14>
 100:	00 00       	nop
 102:	08 95       	ret

00000104 <fillScreen>:
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ef 92       	push	r14
 10a:	ff 92       	push	r15
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	ec 01       	movw	r28, r24
 112:	85 b1       	in	r24, 0x05	; 5
 114:	8f 7b       	andi	r24, 0xBF	; 191
 116:	85 b9       	out	0x05, r24	; 5
 118:	82 e2       	ldi	r24, 0x22	; 34
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 120:	c1 2c       	mov	r12, r1
 122:	d1 2c       	mov	r13, r1
 124:	76 01       	movw	r14, r12
 126:	08 c0       	rjmp	.+16     	; 0x138 <fillScreen+0x34>
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 12e:	8f ef       	ldi	r24, 0xFF	; 255
 130:	c8 1a       	sub	r12, r24
 132:	d8 0a       	sbc	r13, r24
 134:	e8 0a       	sbc	r14, r24
 136:	f8 0a       	sbc	r15, r24
 138:	c1 14       	cp	r12, r1
 13a:	8c e2       	ldi	r24, 0x2C	; 44
 13c:	d8 06       	cpc	r13, r24
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	e8 06       	cpc	r14, r24
 142:	f1 04       	cpc	r15, r1
 144:	88 f3       	brcs	.-30     	; 0x128 <fillScreen+0x24>
 146:	85 b1       	in	r24, 0x05	; 5
 148:	80 64       	ori	r24, 0x40	; 64
 14a:	85 b9       	out	0x05, r24	; 5
 14c:	df 91       	pop	r29
 14e:	cf 91       	pop	r28
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	08 95       	ret

0000015a <colorTest>:
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	85 b1       	in	r24, 0x05	; 5
 160:	8f 7b       	andi	r24, 0xBF	; 191
 162:	85 b9       	out	0x05, r24	; 5
 164:	82 e2       	ldi	r24, 0x22	; 34
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
 16c:	c0 e0       	ldi	r28, 0x00	; 0
 16e:	d0 e0       	ldi	r29, 0x00	; 0
 170:	05 c0       	rjmp	.+10     	; 0x17c <colorTest+0x22>
 172:	8f ef       	ldi	r24, 0xFF	; 255
 174:	9f ef       	ldi	r25, 0xFF	; 255
 176:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 17a:	21 96       	adiw	r28, 0x01	; 1
 17c:	c1 15       	cp	r28, r1
 17e:	8e e1       	ldi	r24, 0x1E	; 30
 180:	d8 07       	cpc	r29, r24
 182:	bc f3       	brlt	.-18     	; 0x172 <colorTest+0x18>
 184:	c0 e0       	ldi	r28, 0x00	; 0
 186:	d0 e0       	ldi	r29, 0x00	; 0
 188:	05 c0       	rjmp	.+10     	; 0x194 <colorTest+0x3a>
 18a:	80 e0       	ldi	r24, 0x00	; 0
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 192:	21 96       	adiw	r28, 0x01	; 1
 194:	c1 15       	cp	r28, r1
 196:	8e e1       	ldi	r24, 0x1E	; 30
 198:	d8 07       	cpc	r29, r24
 19a:	bc f3       	brlt	.-18     	; 0x18a <colorTest+0x30>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	05 c0       	rjmp	.+10     	; 0x1ac <colorTest+0x52>
 1a2:	8e ed       	ldi	r24, 0xDE	; 222
 1a4:	97 ef       	ldi	r25, 0xF7	; 247
 1a6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1aa:	21 96       	adiw	r28, 0x01	; 1
 1ac:	c1 15       	cp	r28, r1
 1ae:	8e e1       	ldi	r24, 0x1E	; 30
 1b0:	d8 07       	cpc	r29, r24
 1b2:	bc f3       	brlt	.-18     	; 0x1a2 <colorTest+0x48>
 1b4:	c0 e0       	ldi	r28, 0x00	; 0
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <colorTest+0x6a>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	98 ef       	ldi	r25, 0xF8	; 248
 1be:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1c2:	21 96       	adiw	r28, 0x01	; 1
 1c4:	c1 15       	cp	r28, r1
 1c6:	8e e1       	ldi	r24, 0x1E	; 30
 1c8:	d8 07       	cpc	r29, r24
 1ca:	bc f3       	brlt	.-18     	; 0x1ba <colorTest+0x60>
 1cc:	c0 e0       	ldi	r28, 0x00	; 0
 1ce:	d0 e0       	ldi	r29, 0x00	; 0
 1d0:	05 c0       	rjmp	.+10     	; 0x1dc <colorTest+0x82>
 1d2:	87 ee       	ldi	r24, 0xE7	; 231
 1d4:	9c ef       	ldi	r25, 0xFC	; 252
 1d6:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	c1 15       	cp	r28, r1
 1de:	8e e1       	ldi	r24, 0x1E	; 30
 1e0:	d8 07       	cpc	r29, r24
 1e2:	bc f3       	brlt	.-18     	; 0x1d2 <colorTest+0x78>
 1e4:	c0 e0       	ldi	r28, 0x00	; 0
 1e6:	d0 e0       	ldi	r29, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <colorTest+0x9a>
 1ea:	8f e1       	ldi	r24, 0x1F	; 31
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 1f2:	21 96       	adiw	r28, 0x01	; 1
 1f4:	c1 15       	cp	r28, r1
 1f6:	8e e1       	ldi	r24, 0x1E	; 30
 1f8:	d8 07       	cpc	r29, r24
 1fa:	bc f3       	brlt	.-18     	; 0x1ea <colorTest+0x90>
 1fc:	c0 e0       	ldi	r28, 0x00	; 0
 1fe:	d0 e0       	ldi	r29, 0x00	; 0
 200:	05 c0       	rjmp	.+10     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
 202:	8f e1       	ldi	r24, 0x1F	; 31
 204:	98 ef       	ldi	r25, 0xF8	; 248
 206:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	c1 15       	cp	r28, r1
 20e:	8e e1       	ldi	r24, 0x1E	; 30
 210:	d8 07       	cpc	r29, r24
 212:	bc f3       	brlt	.-18     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
 214:	c0 e0       	ldi	r28, 0x00	; 0
 216:	d0 e0       	ldi	r29, 0x00	; 0
 218:	05 c0       	rjmp	.+10     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	97 e0       	ldi	r25, 0x07	; 7
 21e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 222:	21 96       	adiw	r28, 0x01	; 1
 224:	c1 15       	cp	r28, r1
 226:	8e e1       	ldi	r24, 0x1E	; 30
 228:	d8 07       	cpc	r29, r24
 22a:	bc f3       	brlt	.-18     	; 0x21a <__EEPROM_REGION_LENGTH__+0x1a>
 22c:	c0 e0       	ldi	r28, 0x00	; 0
 22e:	d0 e0       	ldi	r29, 0x00	; 0
 230:	05 c0       	rjmp	.+10     	; 0x23c <__EEPROM_REGION_LENGTH__+0x3c>
 232:	80 ee       	ldi	r24, 0xE0	; 224
 234:	9f ef       	ldi	r25, 0xFF	; 255
 236:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 23a:	21 96       	adiw	r28, 0x01	; 1
 23c:	c1 15       	cp	r28, r1
 23e:	8e e1       	ldi	r24, 0x1E	; 30
 240:	d8 07       	cpc	r29, r24
 242:	bc f3       	brlt	.-18     	; 0x232 <__EEPROM_REGION_LENGTH__+0x32>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 24a:	8f e1       	ldi	r24, 0x1F	; 31
 24c:	95 e0       	ldi	r25, 0x05	; 5
 24e:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
 252:	21 96       	adiw	r28, 0x01	; 1
 254:	c1 15       	cp	r28, r1
 256:	8e e1       	ldi	r24, 0x1E	; 30
 258:	d8 07       	cpc	r29, r24
 25a:	bc f3       	brlt	.-18     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 25c:	85 b1       	in	r24, 0x05	; 5
 25e:	80 64       	ori	r24, 0x40	; 64
 260:	85 b9       	out	0x05, r24	; 5
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <initHY32D>:
 268:	2f ef       	ldi	r18, 0xFF	; 255
 26a:	8f e3       	ldi	r24, 0x3F	; 63
 26c:	92 e0       	ldi	r25, 0x02	; 2
 26e:	21 50       	subi	r18, 0x01	; 1
 270:	80 40       	sbci	r24, 0x00	; 0
 272:	90 40       	sbci	r25, 0x00	; 0
 274:	e1 f7       	brne	.-8      	; 0x26e <initHY32D+0x6>
 276:	00 c0       	rjmp	.+0      	; 0x278 <initHY32D+0x10>
 278:	00 00       	nop
 27a:	85 b1       	in	r24, 0x05	; 5
 27c:	81 60       	ori	r24, 0x01	; 1
 27e:	85 b9       	out	0x05, r24	; 5
 280:	8f ef       	ldi	r24, 0xFF	; 255
 282:	93 e2       	ldi	r25, 0x23	; 35
 284:	01 97       	sbiw	r24, 0x01	; 1
 286:	f1 f7       	brne	.-4      	; 0x284 <initHY32D+0x1c>
 288:	00 c0       	rjmp	.+0      	; 0x28a <initHY32D+0x22>
 28a:	00 00       	nop
 28c:	85 b1       	in	r24, 0x05	; 5
 28e:	8e 7f       	andi	r24, 0xFE	; 254
 290:	85 b9       	out	0x05, r24	; 5
 292:	8f ef       	ldi	r24, 0xFF	; 255
 294:	9b e6       	ldi	r25, 0x6B	; 107
 296:	01 97       	sbiw	r24, 0x01	; 1
 298:	f1 f7       	brne	.-4      	; 0x296 <initHY32D+0x2e>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <initHY32D+0x34>
 29c:	00 00       	nop
 29e:	85 b1       	in	r24, 0x05	; 5
 2a0:	81 60       	ori	r24, 0x01	; 1
 2a2:	85 b9       	out	0x05, r24	; 5
 2a4:	8f ef       	ldi	r24, 0xFF	; 255
 2a6:	9b e6       	ldi	r25, 0x6B	; 107
 2a8:	01 97       	sbiw	r24, 0x01	; 1
 2aa:	f1 f7       	brne	.-4      	; 0x2a8 <initHY32D+0x40>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <initHY32D+0x46>
 2ae:	00 00       	nop
 2b0:	61 e2       	ldi	r22, 0x21	; 33
 2b2:	70 e0       	ldi	r23, 0x00	; 0
 2b4:	87 e0       	ldi	r24, 0x07	; 7
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2bc:	61 e0       	ldi	r22, 0x01	; 1
 2be:	70 e0       	ldi	r23, 0x00	; 0
 2c0:	80 e0       	ldi	r24, 0x00	; 0
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2c8:	63 e2       	ldi	r22, 0x23	; 35
 2ca:	70 e0       	ldi	r23, 0x00	; 0
 2cc:	87 e0       	ldi	r24, 0x07	; 7
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2d4:	60 e0       	ldi	r22, 0x00	; 0
 2d6:	70 e0       	ldi	r23, 0x00	; 0
 2d8:	80 e1       	ldi	r24, 0x10	; 16
 2da:	90 e0       	ldi	r25, 0x00	; 0
 2dc:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	97 ed       	ldi	r25, 0xD7	; 215
 2e4:	01 97       	sbiw	r24, 0x01	; 1
 2e6:	f1 f7       	brne	.-4      	; 0x2e4 <initHY32D+0x7c>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <initHY32D+0x82>
 2ea:	00 00       	nop
 2ec:	63 e3       	ldi	r22, 0x33	; 51
 2ee:	70 e0       	ldi	r23, 0x00	; 0
 2f0:	87 e0       	ldi	r24, 0x07	; 7
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 2f8:	60 e3       	ldi	r22, 0x30	; 48
 2fa:	78 e6       	ldi	r23, 0x68	; 104
 2fc:	81 e1       	ldi	r24, 0x11	; 17
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 304:	60 e0       	ldi	r22, 0x00	; 0
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	82 e0       	ldi	r24, 0x02	; 2
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	0e 94 61 00 	call	0xc2	; 0xc2 <writeToRegister>
 310:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 314:	08 95       	ret

00000316 <screenTest>:
 316:	85 b1       	in	r24, 0x05	; 5
 318:	8f 7b       	andi	r24, 0xBF	; 191
 31a:	85 b9       	out	0x05, r24	; 5
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	9f ef       	ldi	r25, 0xFF	; 255
 320:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 32c:	8e ed       	ldi	r24, 0xDE	; 222
 32e:	97 ef       	ldi	r25, 0xF7	; 247
 330:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 334:	8f e1       	ldi	r24, 0x1F	; 31
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 33c:	8f e1       	ldi	r24, 0x1F	; 31
 33e:	95 e0       	ldi	r25, 0x05	; 5
 340:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 344:	80 e0       	ldi	r24, 0x00	; 0
 346:	98 ef       	ldi	r25, 0xF8	; 248
 348:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 34c:	8f e1       	ldi	r24, 0x1F	; 31
 34e:	98 ef       	ldi	r25, 0xF8	; 248
 350:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 354:	80 ee       	ldi	r24, 0xE0	; 224
 356:	97 e0       	ldi	r25, 0x07	; 7
 358:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 35c:	80 ee       	ldi	r24, 0xE0	; 224
 35e:	9f ef       	ldi	r25, 0xFF	; 255
 360:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 364:	8f ef       	ldi	r24, 0xFF	; 255
 366:	9f e7       	ldi	r25, 0x7F	; 127
 368:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 36c:	87 ee       	ldi	r24, 0xE7	; 231
 36e:	9c ef       	ldi	r25, 0xFC	; 252
 370:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 374:	0e 94 ad 00 	call	0x15a	; 0x15a <colorTest>
 378:	85 b1       	in	r24, 0x05	; 5
 37a:	80 64       	ori	r24, 0x40	; 64
 37c:	85 b9       	out	0x05, r24	; 5
 37e:	08 95       	ret

00000380 <readDataLines>:
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
 388:	8e b1       	in	r24, 0x0e	; 14
 38a:	8f 7b       	andi	r24, 0xBF	; 191
 38c:	8e b9       	out	0x0e, r24	; 14
 38e:	86 b1       	in	r24, 0x06	; 6
 390:	80 b1       	in	r24, 0x00	; 0
 392:	c6 b1       	in	r28, 0x06	; 6
 394:	d0 e0       	ldi	r29, 0x00	; 0
 396:	dc 2f       	mov	r29, r28
 398:	cc 27       	eor	r28, r28
 39a:	80 b1       	in	r24, 0x00	; 0
 39c:	c8 2b       	or	r28, r24
 39e:	8e b1       	in	r24, 0x0e	; 14
 3a0:	80 64       	ori	r24, 0x40	; 64
 3a2:	8e b9       	out	0x0e, r24	; 14
 3a4:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
 3a8:	ce 01       	movw	r24, r28
 3aa:	df 91       	pop	r29
 3ac:	cf 91       	pop	r28
 3ae:	08 95       	ret

000003b0 <lcdStatusRead>:

void lcdStatusRead(void){ // reads SR register
 3b0:	1f 93       	push	r17
 3b2:	cf 93       	push	r28
 3b4:	df 93       	push	r29
	unsigned short data;
	CS_LOW;
 3b6:	85 b1       	in	r24, 0x05	; 5
 3b8:	8f 7b       	andi	r24, 0xBF	; 191
 3ba:	85 b9       	out	0x05, r24	; 5
	DC_LOW;
 3bc:	8e b1       	in	r24, 0x0e	; 14
 3be:	8f 77       	andi	r24, 0x7F	; 127
 3c0:	8e b9       	out	0x0e, r24	; 14
	data = readDataLines();// read data coming through IO lines
 3c2:	0e 94 c0 01 	call	0x380	; 0x380 <readDataLines>
 3c6:	c8 2f       	mov	r28, r24
 3c8:	d9 2f       	mov	r29, r25
	uint8_t udata = ((data >> 8) & 0xFF);
	uint8_t ldata = (data & 0xFF);
	transmitUART(CR);
 3ca:	8d e0       	ldi	r24, 0x0D	; 13
 3cc:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('S'); 	transmitUART('C'); 	transmitUART('R'); transmitUART('E'); 	transmitUART('E');
 3d0:	83 e5       	ldi	r24, 0x53	; 83
 3d2:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3d6:	83 e4       	ldi	r24, 0x43	; 67
 3d8:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3dc:	82 e5       	ldi	r24, 0x52	; 82
 3de:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3e2:	85 e4       	ldi	r24, 0x45	; 69
 3e4:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3e8:	85 e4       	ldi	r24, 0x45	; 69
 3ea:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('N'); 	transmitUART(' '); transmitUART('S'); 	transmitUART('T'); transmitUART('A');
 3ee:	8e e4       	ldi	r24, 0x4E	; 78
 3f0:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3f4:	80 e2       	ldi	r24, 0x20	; 32
 3f6:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 3fa:	83 e5       	ldi	r24, 0x53	; 83
 3fc:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 400:	84 e5       	ldi	r24, 0x54	; 84
 402:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 406:	81 e4       	ldi	r24, 0x41	; 65
 408:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('T'); 	transmitUART('U'); transmitUART('S'); 	transmitUART(':'); transmitUART(' ');
 40c:	84 e5       	ldi	r24, 0x54	; 84
 40e:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 412:	85 e5       	ldi	r24, 0x55	; 85
 414:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 418:	83 e5       	ldi	r24, 0x53	; 83
 41a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 41e:	8a e3       	ldi	r24, 0x3A	; 58
 420:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 424:	80 e2       	ldi	r24, 0x20	; 32
 426:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('0');
 42a:	80 e3       	ldi	r24, 0x30	; 48
 42c:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('x');
 430:	88 e7       	ldi	r24, 0x78	; 120
 432:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	uint8_t udatauhex = ((udata >> 4) & 0x0F);
	uint8_t udatalhex = (udata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 436:	1d 2f       	mov	r17, r29
 438:	1f 70       	andi	r17, 0x0F	; 15
	transmitUART(toHex(udatauhex));
 43a:	8d 2f       	mov	r24, r29
 43c:	82 95       	swap	r24
 43e:	8f 70       	andi	r24, 0x0F	; 15
 440:	0e 94 a9 03 	call	0x752	; 0x752 <toHex>
 444:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART(toHex(udatalhex));
 448:	81 2f       	mov	r24, r17
 44a:	0e 94 a9 03 	call	0x752	; 0x752 <toHex>
 44e:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	uint8_t ldatauhex = ((ldata >> 4) & 0x0F);
	uint8_t ldatalhex = (ldata & 0x0F); // xxxx xxxx & 0000 1111 => xxxx 1001
 452:	dc 2f       	mov	r29, r28
 454:	df 70       	andi	r29, 0x0F	; 15
	transmitUART(toHex(ldatauhex));
 456:	8c 2f       	mov	r24, r28
 458:	82 95       	swap	r24
 45a:	8f 70       	andi	r24, 0x0F	; 15
 45c:	0e 94 a9 03 	call	0x752	; 0x752 <toHex>
 460:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART(toHex(ldatalhex));
 464:	8d 2f       	mov	r24, r29
 466:	0e 94 a9 03 	call	0x752	; 0x752 <toHex>
 46a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART(CR);
 46e:	8d e0       	ldi	r24, 0x0D	; 13
 470:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	CS_HIGH;
 474:	85 b1       	in	r24, 0x05	; 5
 476:	80 64       	ori	r24, 0x40	; 64
 478:	85 b9       	out	0x05, r24	; 5
 47a:	df 91       	pop	r29
 47c:	cf 91       	pop	r28
 47e:	1f 91       	pop	r17
 480:	08 95       	ret

00000482 <blitSignal>:
void blitSignal(void){
	WR_BLT_CLK_LOW;
	WR_BLT_CLK_HIGH;
}

void blitFromSRAM(void){
 482:	85 b1       	in	r24, 0x05	; 5
 484:	8f 7e       	andi	r24, 0xEF	; 239
 486:	85 b9       	out	0x05, r24	; 5
 488:	85 b1       	in	r24, 0x05	; 5
 48a:	80 61       	ori	r24, 0x10	; 16
 48c:	85 b9       	out	0x05, r24	; 5
 48e:	08 95       	ret

00000490 <loadDataToOutputLines>:
	// Sett CS_LOW (enabling both SRAM and Screen)
	// Send blitSignal (this sends write signal to screen, and increments counters by 1)
}

void loadDataToOutputLines(unsigned short data){
	lData = (data & 0xFF);
 490:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <lData>
	hData = ((data >> 8) & 0xFF);
 494:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <hData>
	D0_D7 = lData; // Write data to GPIO lines (lines should by default be output)
 498:	82 b9       	out	0x02, r24	; 2
	D8_D15 = hData;
 49a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <hData>
 49e:	88 b9       	out	0x08, r24	; 8
 4a0:	08 95       	ret

000004a2 <setExtraBlitIOToOutput>:
}

void setExtraBlitIOToOutput(void) {
	// This can probably be done at startup/initialization
	DDRE |= (1 << PE4); // Port 4 to output (/SRAM OE)	(D16)
 4a2:	8d b1       	in	r24, 0x0d	; 13
 4a4:	80 61       	ori	r24, 0x10	; 16
 4a6:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE5); // Port 5 to output (/SRAM WE)	(D17)
 4a8:	8d b1       	in	r24, 0x0d	; 13
 4aa:	80 62       	ori	r24, 0x20	; 32
 4ac:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE6); // Port 6 to output (RD)			(D18)
 4ae:	8d b1       	in	r24, 0x0d	; 13
 4b0:	80 64       	ori	r24, 0x40	; 64
 4b2:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << PE7); // Port 7 to output (DC)			(D19)
 4b4:	8d b1       	in	r24, 0x0d	; 13
 4b6:	80 68       	ori	r24, 0x80	; 128
 4b8:	8d b9       	out	0x0d, r24	; 13
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4ba:	2f ef       	ldi	r18, 0xFF	; 255
 4bc:	8f e3       	ldi	r24, 0x3F	; 63
 4be:	92 e0       	ldi	r25, 0x02	; 2
 4c0:	21 50       	subi	r18, 0x01	; 1
 4c2:	80 40       	sbci	r24, 0x00	; 0
 4c4:	90 40       	sbci	r25, 0x00	; 0
 4c6:	e1 f7       	brne	.-8      	; 0x4c0 <setExtraBlitIOToOutput+0x1e>
 4c8:	00 c0       	rjmp	.+0      	; 0x4ca <setExtraBlitIOToOutput+0x28>
 4ca:	00 00       	nop
 4cc:	08 95       	ret

000004ce <presetCountersToZero>:
	_delay_ms(100); // Not sure if this is necessary, check later
}

// BLT_RST (to reset counter values is also an option. See counter datasheet.
void presetCountersToZero(void){
	CS_HIGH; // Deselect LCD and SRAM
 4ce:	85 b1       	in	r24, 0x05	; 5
 4d0:	80 64       	ori	r24, 0x40	; 64
 4d2:	85 b9       	out	0x05, r24	; 5
	setIOtoOutput(); // Set all lines to output
 4d4:	0e 94 72 00 	call	0xe4	; 0xe4 <setIOtoOutput>
	setExtraBlitIOToOutput();
 4d8:	0e 94 51 02 	call	0x4a2	; 0x4a2 <setExtraBlitIOToOutput>
	// Give all outlines a value of 0
	D0_D7 = 0x00;
 4dc:	12 b8       	out	0x02, r1	; 2
	D8_D15 = 0x00;
 4de:	18 b8       	out	0x08, r1	; 8
	PORTE &= ~(1 << PE4);
 4e0:	8e b1       	in	r24, 0x0e	; 14
 4e2:	8f 7e       	andi	r24, 0xEF	; 239
 4e4:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE5);
 4e6:	8e b1       	in	r24, 0x0e	; 14
 4e8:	8f 7d       	andi	r24, 0xDF	; 223
 4ea:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE6);
 4ec:	8e b1       	in	r24, 0x0e	; 14
 4ee:	8f 7b       	andi	r24, 0xBF	; 191
 4f0:	8e b9       	out	0x0e, r24	; 14
	PORTE &= ~(1 << PE7);
 4f2:	8e b1       	in	r24, 0x0e	; 14
 4f4:	8f 77       	andi	r24, 0x7F	; 127
 4f6:	8e b9       	out	0x0e, r24	; 14
 4f8:	83 e3       	ldi	r24, 0x33	; 51
 4fa:	97 e0       	ldi	r25, 0x07	; 7
 4fc:	01 97       	sbiw	r24, 0x01	; 1
 4fe:	f1 f7       	brne	.-4      	; 0x4fc <presetCountersToZero+0x2e>
	_delay_ms(1);
	// Counter signal lines
	RESET_HIGH; // Set CLR(BLT_RST)(PB0)(RESET) to HIGH
 500:	85 b1       	in	r24, 0x05	; 5
 502:	81 60       	ori	r24, 0x01	; 1
 504:	85 b9       	out	0x05, r24	; 5
	LOAD_LOW; // Set LOAD(PE3) to LOW
 506:	8e b1       	in	r24, 0x0e	; 14
 508:	87 7f       	andi	r24, 0xF7	; 247
 50a:	8e b9       	out	0x0e, r24	; 14
	blitSignal();// Send blitsignal (aka a clk)
 50c:	0e 94 41 02 	call	0x482	; 0x482 <blitSignal>
	LOAD_HIGH;
 510:	8e b1       	in	r24, 0x0e	; 14
 512:	88 60       	ori	r24, 0x08	; 8
 514:	8e b9       	out	0x0e, r24	; 14
 516:	08 95       	ret

00000518 <wrSignalSRAM>:
}

void wrSignalSRAM(){
	SRAM_WE_LOW;
 518:	8e b1       	in	r24, 0x0e	; 14
 51a:	8f 7d       	andi	r24, 0xDF	; 223
 51c:	8e b9       	out	0x0e, r24	; 14
	SRAM_WE_HIGH;
 51e:	8e b1       	in	r24, 0x0e	; 14
 520:	80 62       	ori	r24, 0x20	; 32
 522:	8e b9       	out	0x0e, r24	; 14
 524:	08 95       	ret

00000526 <rdSignalSRAM>:
}

void rdSignalSRAM(){
	SRAM_OE_LOW;
 526:	8e b1       	in	r24, 0x0e	; 14
 528:	8f 7e       	andi	r24, 0xEF	; 239
 52a:	8e b9       	out	0x0e, r24	; 14
	SRAM_OE_HIGH;
 52c:	8e b1       	in	r24, 0x0e	; 14
 52e:	80 61       	ori	r24, 0x10	; 16
 530:	8e b9       	out	0x0e, r24	; 14
 532:	08 95       	ret

00000534 <readSRAM>:
}

void readSRAM(void){
	presetCountersToZero();
 534:	0e 94 67 02 	call	0x4ce	; 0x4ce <presetCountersToZero>
	CS_LOW;
 538:	85 b1       	in	r24, 0x05	; 5
 53a:	8f 7b       	andi	r24, 0xBF	; 191
 53c:	85 b9       	out	0x05, r24	; 5
	BLT_EN_HIGH;
 53e:	85 b1       	in	r24, 0x05	; 5
 540:	80 68       	ori	r24, 0x80	; 128
 542:	85 b9       	out	0x05, r24	; 5
	
	setIOtoInput(); // Set D0-D15 to input so it doesn't interfere with SRAM to Screen lines
 544:	0e 94 76 00 	call	0xec	; 0xec <setIOtoInput>
	rdSignalSRAM(); // SRAM OE goes HIGH-LOW-HIGH
 548:	0e 94 93 02 	call	0x526	; 0x526 <rdSignalSRAM>
	blitSignal();
 54c:	0e 94 41 02 	call	0x482	; 0x482 <blitSignal>
	
	CS_HIGH;
 550:	85 b1       	in	r24, 0x05	; 5
 552:	80 64       	ori	r24, 0x40	; 64
 554:	85 b9       	out	0x05, r24	; 5
	BLT_EN_LOW;
 556:	85 b1       	in	r24, 0x05	; 5
 558:	8f 77       	andi	r24, 0x7F	; 127
 55a:	85 b9       	out	0x05, r24	; 5
 55c:	08 95       	ret

0000055e <writeSRAM>:
}

void writeSRAM(void){
 55e:	cf 92       	push	r12
 560:	df 92       	push	r13
 562:	ef 92       	push	r14
 564:	ff 92       	push	r15
	presetCountersToZero(); // Set counters to your desired value (up to 2^20, or about 1 million)
 566:	0e 94 67 02 	call	0x4ce	; 0x4ce <presetCountersToZero>
	CS_LOW; // Select SRAM (and display)
 56a:	85 b1       	in	r24, 0x05	; 5
 56c:	8f 7b       	andi	r24, 0xBF	; 191
 56e:	85 b9       	out	0x05, r24	; 5
	BLT_EN_HIGH; // BLT_EN HIGH so the address gets incremented by each write.
 570:	85 b1       	in	r24, 0x05	; 5
 572:	80 68       	ori	r24, 0x80	; 128
 574:	85 b9       	out	0x05, r24	; 5
	SRAM_OE_HIGH; // Output enable to high (disabled). Isn't needed I think.
 576:	8e b1       	in	r24, 0x0e	; 14
 578:	80 61       	ori	r24, 0x10	; 16
 57a:	8e b9       	out	0x0e, r24	; 14
	writeIndex(0x22); // Set display to write to video ram to avoid it writing to any other register.
 57c:	82 e2       	ldi	r24, 0x22	; 34
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	// Loops with data to transfer. This is hardcoded for now.
	
	DC_HIGH;
 584:	8e b1       	in	r24, 0x0e	; 14
 586:	80 68       	ori	r24, 0x80	; 128
 588:	8e b9       	out	0x0e, r24	; 14
	for(unsigned long int i = 0; i < (pixels/3); i++){
 58a:	c1 2c       	mov	r12, r1
 58c:	d1 2c       	mov	r13, r1
 58e:	76 01       	movw	r14, r12
 590:	0d c0       	rjmp	.+26     	; 0x5ac <writeSRAM+0x4e>
		loadDataToOutputLines(Red);
 592:	8f e1       	ldi	r24, 0x1F	; 31
 594:	90 e0       	ldi	r25, 0x00	; 0
 596:	0e 94 48 02 	call	0x490	; 0x490 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
 59a:	0e 94 8c 02 	call	0x518	; 0x518 <wrSignalSRAM>
		blitSignal(); // counters increment by one.
 59e:	0e 94 41 02 	call	0x482	; 0x482 <blitSignal>
	SRAM_OE_HIGH; // Output enable to high (disabled). Isn't needed I think.
	writeIndex(0x22); // Set display to write to video ram to avoid it writing to any other register.
	// Loops with data to transfer. This is hardcoded for now.
	
	DC_HIGH;
	for(unsigned long int i = 0; i < (pixels/3); i++){
 5a2:	8f ef       	ldi	r24, 0xFF	; 255
 5a4:	c8 1a       	sub	r12, r24
 5a6:	d8 0a       	sbc	r13, r24
 5a8:	e8 0a       	sbc	r14, r24
 5aa:	f8 0a       	sbc	r15, r24
 5ac:	c1 14       	cp	r12, r1
 5ae:	84 e6       	ldi	r24, 0x64	; 100
 5b0:	d8 06       	cpc	r13, r24
 5b2:	e1 04       	cpc	r14, r1
 5b4:	f1 04       	cpc	r15, r1
 5b6:	68 f3       	brcs	.-38     	; 0x592 <writeSRAM+0x34>
 5b8:	c1 2c       	mov	r12, r1
 5ba:	d1 2c       	mov	r13, r1
 5bc:	76 01       	movw	r14, r12
 5be:	0d c0       	rjmp	.+26     	; 0x5da <writeSRAM+0x7c>
		loadDataToOutputLines(Red);
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
		blitSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Green);
 5c0:	80 ee       	ldi	r24, 0xE0	; 224
 5c2:	97 e0       	ldi	r25, 0x07	; 7
 5c4:	0e 94 48 02 	call	0x490	; 0x490 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
 5c8:	0e 94 8c 02 	call	0x518	; 0x518 <wrSignalSRAM>
		blitSignal(); // counters increment by one.
 5cc:	0e 94 41 02 	call	0x482	; 0x482 <blitSignal>
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Red);
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
		blitSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
 5d0:	8f ef       	ldi	r24, 0xFF	; 255
 5d2:	c8 1a       	sub	r12, r24
 5d4:	d8 0a       	sbc	r13, r24
 5d6:	e8 0a       	sbc	r14, r24
 5d8:	f8 0a       	sbc	r15, r24
 5da:	c1 14       	cp	r12, r1
 5dc:	84 e6       	ldi	r24, 0x64	; 100
 5de:	d8 06       	cpc	r13, r24
 5e0:	e1 04       	cpc	r14, r1
 5e2:	f1 04       	cpc	r15, r1
 5e4:	68 f3       	brcs	.-38     	; 0x5c0 <writeSRAM+0x62>
 5e6:	c1 2c       	mov	r12, r1
 5e8:	d1 2c       	mov	r13, r1
 5ea:	76 01       	movw	r14, r12
 5ec:	0d c0       	rjmp	.+26     	; 0x608 <writeSRAM+0xaa>
		loadDataToOutputLines(Green);
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
		blitSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Blue);
 5ee:	80 e0       	ldi	r24, 0x00	; 0
 5f0:	98 ef       	ldi	r25, 0xF8	; 248
 5f2:	0e 94 48 02 	call	0x490	; 0x490 <loadDataToOutputLines>
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
 5f6:	0e 94 8c 02 	call	0x518	; 0x518 <wrSignalSRAM>
		blitSignal(); // counters increment by one.
 5fa:	0e 94 41 02 	call	0x482	; 0x482 <blitSignal>
	for(unsigned long int i = 0; i < (pixels/3); i++){
		loadDataToOutputLines(Green);
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
		blitSignal(); // counters increment by one.
	}
	for(unsigned long int i = 0; i < (pixels/3); i++){
 5fe:	8f ef       	ldi	r24, 0xFF	; 255
 600:	c8 1a       	sub	r12, r24
 602:	d8 0a       	sbc	r13, r24
 604:	e8 0a       	sbc	r14, r24
 606:	f8 0a       	sbc	r15, r24
 608:	c1 14       	cp	r12, r1
 60a:	84 e6       	ldi	r24, 0x64	; 100
 60c:	d8 06       	cpc	r13, r24
 60e:	e1 04       	cpc	r14, r1
 610:	f1 04       	cpc	r15, r1
 612:	68 f3       	brcs	.-38     	; 0x5ee <writeSRAM+0x90>
		loadDataToOutputLines(Blue);
		wrSignalSRAM(); // WriteEnable to SRAM (this increments internal address by 1)
		blitSignal(); // counters increment by one.
	}
	
	CS_HIGH; // deselect LCD and SRAM
 614:	85 b1       	in	r24, 0x05	; 5
 616:	80 64       	ori	r24, 0x40	; 64
 618:	85 b9       	out	0x05, r24	; 5
	BLT_EN_LOW;
 61a:	85 b1       	in	r24, 0x05	; 5
 61c:	8f 77       	andi	r24, 0x7F	; 127
 61e:	85 b9       	out	0x05, r24	; 5
}
 620:	ff 90       	pop	r15
 622:	ef 90       	pop	r14
 624:	df 90       	pop	r13
 626:	cf 90       	pop	r12
 628:	08 95       	ret

0000062a <main>:
int main(void)
{	
	// Startup sequence
	
	// Init counters:
	DDRE |= (1 << LOAD); // Setting LOAD to output;
 62a:	8d b1       	in	r24, 0x0d	; 13
 62c:	88 60       	ori	r24, 0x08	; 8
 62e:	8d b9       	out	0x0d, r24	; 13
	LOAD_HIGH; // Setting LOAD to high (disabled)
 630:	8e b1       	in	r24, 0x0e	; 14
 632:	88 60       	ori	r24, 0x08	; 8
 634:	8e b9       	out	0x0e, r24	; 14
	
	DDRB |= (1 << PB7); // Setting BLT_EN to output;
 636:	84 b1       	in	r24, 0x04	; 4
 638:	80 68       	ori	r24, 0x80	; 128
 63a:	84 b9       	out	0x04, r24	; 4
	BLT_EN_LOW; // Setting BLT_EN to low.
 63c:	85 b1       	in	r24, 0x05	; 5
 63e:	8f 77       	andi	r24, 0x7F	; 127
 640:	85 b9       	out	0x05, r24	; 5
	
	// Init IO and LCD:
	// Setting CS, DC, RD, WR to output.
	DDRB |= (1 << CS);
 642:	84 b1       	in	r24, 0x04	; 4
 644:	80 64       	ori	r24, 0x40	; 64
 646:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << BL_PWM);
 648:	84 b1       	in	r24, 0x04	; 4
 64a:	80 62       	ori	r24, 0x20	; 32
 64c:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << WR_BLT_CLK);
 64e:	84 b1       	in	r24, 0x04	; 4
 650:	80 61       	ori	r24, 0x10	; 16
 652:	84 b9       	out	0x04, r24	; 4
	DDRE |= (1 << RD);
 654:	8d b1       	in	r24, 0x0d	; 13
 656:	80 64       	ori	r24, 0x40	; 64
 658:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << DC);
 65a:	8d b1       	in	r24, 0x0d	; 13
 65c:	80 68       	ori	r24, 0x80	; 128
 65e:	8d b9       	out	0x0d, r24	; 13
	// All are set to High (disabled). DC doesn't matter.
	PORTB |= (1 << CS);
 660:	85 b1       	in	r24, 0x05	; 5
 662:	80 64       	ori	r24, 0x40	; 64
 664:	85 b9       	out	0x05, r24	; 5
	//PORTB |= (1 << BL_PWM); // Not enabled rn as it turns off display. Fix this later.
	PORTB |= (1 << WR_BLT_CLK);
 666:	85 b1       	in	r24, 0x05	; 5
 668:	80 61       	ori	r24, 0x10	; 16
 66a:	85 b9       	out	0x05, r24	; 5
	PORTE |= (1 << RD);
 66c:	8e b1       	in	r24, 0x0e	; 14
 66e:	80 64       	ori	r24, 0x40	; 64
 670:	8e b9       	out	0x0e, r24	; 14
	PORTE |= (1 << DC);
 672:	8e b1       	in	r24, 0x0e	; 14
 674:	80 68       	ori	r24, 0x80	; 128
 676:	8e b9       	out	0x0e, r24	; 14
	// Set IO to output
	DDRA = 0xFF; // D0 - D7
 678:	8f ef       	ldi	r24, 0xFF	; 255
 67a:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF; // D8 - D15
 67c:	87 b9       	out	0x07, r24	; 7
	
    initUART(); // initialize the UART
 67e:	0e 94 c5 03 	call	0x78a	; 0x78a <initUART>
	initHY32D(); // initialize HY32D screen
 682:	0e 94 34 01 	call	0x268	; 0x268 <initHY32D>
	sei(); //Enable global interrupt
 686:	78 94       	sei
	systemCheck();
 688:	0e 94 f5 03 	call	0x7ea	; 0x7ea <systemCheck>
	startupMessage();
 68c:	0e 94 28 04 	call	0x850	; 0x850 <startupMessage>
 690:	ff cf       	rjmp	.-2      	; 0x690 <main+0x66>

00000692 <__vector_13>:
		- INFO:Utviklingen vil skje på egen maskinvareplattform.
		*/
    }
}

ISR(USART0_RX_vect){
 692:	1f 92       	push	r1
 694:	0f 92       	push	r0
 696:	0f b6       	in	r0, 0x3f	; 63
 698:	0f 92       	push	r0
 69a:	11 24       	eor	r1, r1
 69c:	2f 93       	push	r18
 69e:	3f 93       	push	r19
 6a0:	4f 93       	push	r20
 6a2:	5f 93       	push	r21
 6a4:	6f 93       	push	r22
 6a6:	7f 93       	push	r23
 6a8:	8f 93       	push	r24
 6aa:	9f 93       	push	r25
 6ac:	af 93       	push	r26
 6ae:	bf 93       	push	r27
 6b0:	cf 93       	push	r28
 6b2:	ef 93       	push	r30
 6b4:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	uint8_t receivedByte = UARTBuffer; // local temporary variable for received byte
 6b6:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 6ba:	cc 23       	and	r28, r28
 6bc:	39 f1       	breq	.+78     	; 0x70c <__vector_13+0x7a>
		if (receivedByte == 45) { // that's the '-' sign.
 6be:	cd 32       	cpi	r28, 0x2D	; 45
 6c0:	31 f4       	brne	.+12     	; 0x6ce <__vector_13+0x3c>
			remoteEcho = ~remoteEcho;
 6c2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6c6:	80 95       	com	r24
 6c8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 6cc:	1f c0       	rjmp	.+62     	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 's'){
 6ce:	c3 37       	cpi	r28, 0x73	; 115
 6d0:	19 f4       	brne	.+6      	; 0x6d8 <__vector_13+0x46>
			systemCheck();
 6d2:	0e 94 f5 03 	call	0x7ea	; 0x7ea <systemCheck>
 6d6:	1a c0       	rjmp	.+52     	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 'l'){
 6d8:	cc 36       	cpi	r28, 0x6C	; 108
 6da:	19 f4       	brne	.+6      	; 0x6e2 <__vector_13+0x50>
			lcdStatusRead();
 6dc:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <lcdStatusRead>
 6e0:	15 c0       	rjmp	.+42     	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 'b'){
 6e2:	c2 36       	cpi	r28, 0x62	; 98
 6e4:	29 f4       	brne	.+10     	; 0x6f0 <__vector_13+0x5e>
			fillScreen(Blue);
 6e6:	80 e0       	ldi	r24, 0x00	; 0
 6e8:	98 ef       	ldi	r25, 0xF8	; 248
 6ea:	0e 94 82 00 	call	0x104	; 0x104 <fillScreen>
 6ee:	0e c0       	rjmp	.+28     	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 'w'){
 6f0:	c7 37       	cpi	r28, 0x77	; 119
 6f2:	19 f4       	brne	.+6      	; 0x6fa <__vector_13+0x68>
			writeSRAM();
 6f4:	0e 94 af 02 	call	0x55e	; 0x55e <writeSRAM>
 6f8:	09 c0       	rjmp	.+18     	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 'r'){
 6fa:	c2 37       	cpi	r28, 0x72	; 114
 6fc:	19 f4       	brne	.+6      	; 0x704 <__vector_13+0x72>
			readSRAM();
 6fe:	0e 94 9a 02 	call	0x534	; 0x534 <readSRAM>
 702:	04 c0       	rjmp	.+8      	; 0x70c <__vector_13+0x7a>
		}else if(receivedByte == 'T'){
 704:	c4 35       	cpi	r28, 0x54	; 84
 706:	11 f4       	brne	.+4      	; 0x70c <__vector_13+0x7a>
			screenTest();
 708:	0e 94 8b 01 	call	0x316	; 0x316 <screenTest>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 70c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 710:	88 23       	and	r24, r24
 712:	69 f0       	breq	.+26     	; 0x72e <__vector_13+0x9c>
 714:	c0 32       	cpi	r28, 0x20	; 32
 716:	40 f4       	brcc	.+16     	; 0x728 <__vector_13+0x96>
 718:	c7 30       	cpi	r28, 0x07	; 7
 71a:	31 f0       	breq	.+12     	; 0x728 <__vector_13+0x96>
 71c:	cd 30       	cpi	r28, 0x0D	; 13
 71e:	21 f0       	breq	.+8      	; 0x728 <__vector_13+0x96>
 720:	ca 30       	cpi	r28, 0x0A	; 10
 722:	11 f0       	breq	.+4      	; 0x728 <__vector_13+0x96>
 724:	c8 30       	cpi	r28, 0x08	; 8
 726:	19 f4       	brne	.+6      	; 0x72e <__vector_13+0x9c>
		transmitUART(receivedByte);
 728:	8c 2f       	mov	r24, r28
 72a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	}
 72e:	ff 91       	pop	r31
 730:	ef 91       	pop	r30
 732:	cf 91       	pop	r28
 734:	bf 91       	pop	r27
 736:	af 91       	pop	r26
 738:	9f 91       	pop	r25
 73a:	8f 91       	pop	r24
 73c:	7f 91       	pop	r23
 73e:	6f 91       	pop	r22
 740:	5f 91       	pop	r21
 742:	4f 91       	pop	r20
 744:	3f 91       	pop	r19
 746:	2f 91       	pop	r18
 748:	0f 90       	pop	r0
 74a:	0f be       	out	0x3f, r0	; 63
 74c:	0f 90       	pop	r0
 74e:	1f 90       	pop	r1
 750:	18 95       	reti

00000752 <toHex>:
 */ 

#include "stdint.h"

uint8_t toHex(uint8_t number) {
	uint8_t num = '0'+number;
 752:	80 5d       	subi	r24, 0xD0	; 208
	if(num < 58){
 754:	8a 33       	cpi	r24, 0x3A	; 58
 756:	c0 f0       	brcs	.+48     	; 0x788 <toHex+0x36>
		return num;
	}
	else if(num == 58){
 758:	8a 33       	cpi	r24, 0x3A	; 58
 75a:	59 f0       	breq	.+22     	; 0x772 <toHex+0x20>
		return 'A';
	}
	else if(num == 59){
 75c:	8b 33       	cpi	r24, 0x3B	; 59
 75e:	59 f0       	breq	.+22     	; 0x776 <toHex+0x24>
		return 'B';
	}
	else if(num == 60){
 760:	8c 33       	cpi	r24, 0x3C	; 60
 762:	59 f0       	breq	.+22     	; 0x77a <toHex+0x28>
		return 'C';
	}
	else if(num == 61){
 764:	8d 33       	cpi	r24, 0x3D	; 61
 766:	59 f0       	breq	.+22     	; 0x77e <toHex+0x2c>
		return 'D';
	}
	else if(num == 62){
 768:	8e 33       	cpi	r24, 0x3E	; 62
 76a:	59 f0       	breq	.+22     	; 0x782 <toHex+0x30>
		return 'E';
	}
	else if(num == 63){
 76c:	8f 33       	cpi	r24, 0x3F	; 63
 76e:	59 f0       	breq	.+22     	; 0x786 <toHex+0x34>
		return 'F';
	}
 770:	08 95       	ret
	uint8_t num = '0'+number;
	if(num < 58){
		return num;
	}
	else if(num == 58){
		return 'A';
 772:	81 e4       	ldi	r24, 0x41	; 65
 774:	08 95       	ret
	}
	else if(num == 59){
		return 'B';
 776:	82 e4       	ldi	r24, 0x42	; 66
 778:	08 95       	ret
	}
	else if(num == 60){
		return 'C';
 77a:	83 e4       	ldi	r24, 0x43	; 67
 77c:	08 95       	ret
	}
	else if(num == 61){
		return 'D';
 77e:	84 e4       	ldi	r24, 0x44	; 68
 780:	08 95       	ret
	}
	else if(num == 62){
		return 'E';
 782:	85 e4       	ldi	r24, 0x45	; 69
 784:	08 95       	ret
	}
	else if(num == 63){
		return 'F';
 786:	86 e4       	ldi	r24, 0x46	; 70
	}
 788:	08 95       	ret

0000078a <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 78a:	8f e2       	ldi	r24, 0x2F	; 47
 78c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 790:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 794:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 798:	88 e9       	ldi	r24, 0x98	; 152
 79a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 79e:	86 e0       	ldi	r24, 0x06	; 6
 7a0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 7a4:	08 95       	ret

000007a6 <puttyCompatibleCheck>:
}

uint8_t puttyCompatibleCheck(uint8_t byte){
	if((byte > 31) || (byte == Bell) || (byte == CR) || (byte == LF) || (byte == backspace)){
 7a6:	80 32       	cpi	r24, 0x20	; 32
 7a8:	48 f4       	brcc	.+18     	; 0x7bc <puttyCompatibleCheck+0x16>
 7aa:	87 30       	cpi	r24, 0x07	; 7
 7ac:	39 f0       	breq	.+14     	; 0x7bc <puttyCompatibleCheck+0x16>
 7ae:	8d 30       	cpi	r24, 0x0D	; 13
 7b0:	29 f0       	breq	.+10     	; 0x7bc <puttyCompatibleCheck+0x16>
 7b2:	8a 30       	cpi	r24, 0x0A	; 10
 7b4:	19 f0       	breq	.+6      	; 0x7bc <puttyCompatibleCheck+0x16>
 7b6:	88 30       	cpi	r24, 0x08	; 8
 7b8:	09 f0       	breq	.+2      	; 0x7bc <puttyCompatibleCheck+0x16>
		return byte;
		}else{
		return (uint8_t)64;
 7ba:	80 e4       	ldi	r24, 0x40	; 64
	}
}
 7bc:	08 95       	ret

000007be <transmitUART>:

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 7be:	20 e0       	ldi	r18, 0x00	; 0
 7c0:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 7c2:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 7c6:	95 ff       	sbrs	r25, 5
 7c8:	07 c0       	rjmp	.+14     	; 0x7d8 <transmitUART+0x1a>
			UARTBuffer = puttyCompatibleCheck(data);
 7ca:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <puttyCompatibleCheck>
 7ce:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 7d2:	81 e0       	ldi	r24, 0x01	; 1
 7d4:	90 e0       	ldi	r25, 0x00	; 0
 7d6:	08 95       	ret
			}else{
			timeout++;
 7d8:	2f 5f       	subi	r18, 0xFF	; 255
 7da:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 7dc:	29 3e       	cpi	r18, 0xE9	; 233
 7de:	93 e0       	ldi	r25, 0x03	; 3
 7e0:	39 07       	cpc	r19, r25
 7e2:	7c f3       	brlt	.-34     	; 0x7c2 <transmitUART+0x4>
				return 0;
 7e4:	80 e0       	ldi	r24, 0x00	; 0
 7e6:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 7e8:	08 95       	ret

000007ea <systemCheck>:
#include "UART.h"
#include "HY32D.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 7ea:	8d e0       	ldi	r24, 0x0D	; 13
 7ec:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('-');
 7f0:	8d e2       	ldi	r24, 0x2D	; 45
 7f2:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART(CR);
 7f6:	8d e0       	ldi	r24, 0x0D	; 13
 7f8:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('S');	transmitUART('y'); 	transmitUART('s'); 	transmitUART('t'); 	transmitUART('e');
 7fc:	83 e5       	ldi	r24, 0x53	; 83
 7fe:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 802:	89 e7       	ldi	r24, 0x79	; 121
 804:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 808:	83 e7       	ldi	r24, 0x73	; 115
 80a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 80e:	84 e7       	ldi	r24, 0x74	; 116
 810:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 814:	85 e6       	ldi	r24, 0x65	; 101
 816:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('m');	transmitUART(' '); 	transmitUART('c'); 	transmitUART('h'); 	transmitUART('e');
 81a:	8d e6       	ldi	r24, 0x6D	; 109
 81c:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 820:	80 e2       	ldi	r24, 0x20	; 32
 822:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 826:	83 e6       	ldi	r24, 0x63	; 99
 828:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 82c:	88 e6       	ldi	r24, 0x68	; 104
 82e:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 832:	85 e6       	ldi	r24, 0x65	; 101
 834:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('c');	transmitUART('k'); 	transmitUART(':');
 838:	83 e6       	ldi	r24, 0x63	; 99
 83a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 83e:	8b e6       	ldi	r24, 0x6B	; 107
 840:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 844:	8a e3       	ldi	r24, 0x3A	; 58
 846:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	lcdStatusRead();
 84a:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <lcdStatusRead>
 84e:	08 95       	ret

00000850 <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART('B');	transmitUART('l'); 	transmitUART('i'); 	transmitUART('t'); 	transmitUART('t');
 850:	82 e4       	ldi	r24, 0x42	; 66
 852:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 856:	8c e6       	ldi	r24, 0x6C	; 108
 858:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 85c:	89 e6       	ldi	r24, 0x69	; 105
 85e:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 862:	84 e7       	ldi	r24, 0x74	; 116
 864:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 868:	84 e7       	ldi	r24, 0x74	; 116
 86a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('e');	transmitUART('r'); 	transmitUART(' '); 	transmitUART('r'); 	transmitUART('e');
 86e:	85 e6       	ldi	r24, 0x65	; 101
 870:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 874:	82 e7       	ldi	r24, 0x72	; 114
 876:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 87a:	80 e2       	ldi	r24, 0x20	; 32
 87c:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 880:	82 e7       	ldi	r24, 0x72	; 114
 882:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 886:	85 e6       	ldi	r24, 0x65	; 101
 888:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART('a');	transmitUART('d'); 	transmitUART('y');
 88c:	81 e6       	ldi	r24, 0x61	; 97
 88e:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 892:	84 e6       	ldi	r24, 0x64	; 100
 894:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 898:	89 e7       	ldi	r24, 0x79	; 121
 89a:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
	transmitUART(CR);
 89e:	8d e0       	ldi	r24, 0x0D	; 13
 8a0:	0e 94 df 03 	call	0x7be	; 0x7be <transmitUART>
 8a4:	08 95       	ret

000008a6 <_exit>:
 8a6:	f8 94       	cli

000008a8 <__stop_program>:
 8a8:	ff cf       	rjmp	.-2      	; 0x8a8 <__stop_program>
