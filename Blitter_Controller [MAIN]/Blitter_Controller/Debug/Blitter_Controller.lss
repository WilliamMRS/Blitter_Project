
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000003ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000378  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000003ec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003ec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000041c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  0000045c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000126f  00000000  00000000  00000544  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ac4  00000000  00000000  000017b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000813  00000000  00000000  00002277  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001d8  00000000  00000000  00002a8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005d9  00000000  00000000  00002c64  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000050b  00000000  00000000  0000323d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00003748  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a1 30       	cpi	r26, 0x01	; 1
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 ed 00 	call	0x1da	; 0x1da <main>
  7c:	0c 94 ba 01 	jmp	0x374	; 0x374 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <wrSignal>:
	writeData(lData, hData);
	CS_HIGH;
}

void wrSignal(void){
	WR_LOW;
  84:	85 b1       	in	r24, 0x05	; 5
  86:	8f 7e       	andi	r24, 0xEF	; 239
  88:	85 b9       	out	0x05, r24	; 5
	WR_HIGH;
  8a:	85 b1       	in	r24, 0x05	; 5
  8c:	80 61       	ori	r24, 0x10	; 16
  8e:	85 b9       	out	0x05, r24	; 5
  90:	08 95       	ret

00000092 <writeIndex>:
/*
	Usage: Writes to the index register. The index register points to where the next written data should go.
	Prereq: Set CS_LOW first.
*/
void writeIndex(unsigned short index){
	DC_LOW; // DC LOW
  92:	9e b1       	in	r25, 0x0e	; 14
  94:	9f 77       	andi	r25, 0x7F	; 127
  96:	9e b9       	out	0x0e, r25	; 14
	RD_HIGH; // RD High (for good measure? can be omitted as RD should always be high)
  98:	9e b1       	in	r25, 0x0e	; 14
  9a:	90 64       	ori	r25, 0x40	; 64
  9c:	9e b9       	out	0x0e, r25	; 14
	D0_D7 = index; // IO Write
  9e:	82 b9       	out	0x02, r24	; 2
	wrSignal();
  a0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  a4:	08 95       	ret

000000a6 <writeData>:
/*
	Usage: Writes to the index register. The index register points to where the next written data should go.
	Prereq: Set CS_LOW first.
*/
void writeData(unsigned char lData, unsigned char hData){
	DC_HIGH;
  a6:	9e b1       	in	r25, 0x0e	; 14
  a8:	90 68       	ori	r25, 0x80	; 128
  aa:	9e b9       	out	0x0e, r25	; 14
	D0_D7 = lData; // Write data to GPIO lines (lines should by default be output)
  ac:	82 b9       	out	0x02, r24	; 2
	D8_D15 = hData;
  ae:	68 b9       	out	0x08, r22	; 8
	wrSignal();
  b0:	0e 94 42 00 	call	0x84	; 0x84 <wrSignal>
  b4:	08 95       	ret

000000b6 <writeToRegister>:
}

void writeToRegister(unsigned short index, unsigned char lData, unsigned char hData){
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	c6 2f       	mov	r28, r22
  bc:	d4 2f       	mov	r29, r20
	CS_LOW;
  be:	25 b1       	in	r18, 0x05	; 5
  c0:	2f 7b       	andi	r18, 0xBF	; 191
  c2:	25 b9       	out	0x05, r18	; 5
	writeIndex(index);
  c4:	0e 94 49 00 	call	0x92	; 0x92 <writeIndex>
	writeData(lData, hData);
  c8:	6d 2f       	mov	r22, r29
  ca:	8c 2f       	mov	r24, r28
  cc:	0e 94 53 00 	call	0xa6	; 0xa6 <writeData>
	CS_HIGH;
  d0:	85 b1       	in	r24, 0x05	; 5
  d2:	80 64       	ori	r24, 0x40	; 64
  d4:	85 b9       	out	0x05, r24	; 5
}
  d6:	df 91       	pop	r29
  d8:	cf 91       	pop	r28
  da:	08 95       	ret

000000dc <initHY32D>:
#include <util/delay.h>

// This isn't ready, see datasheet on how to complete start up sequence.
void initHY32D(void){
	// Setting CS, DC, RD, WR to output.
	DDRB |= (1 << CS);
  dc:	84 b1       	in	r24, 0x04	; 4
  de:	80 64       	ori	r24, 0x40	; 64
  e0:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << BL_PWM);
  e2:	84 b1       	in	r24, 0x04	; 4
  e4:	80 62       	ori	r24, 0x20	; 32
  e6:	84 b9       	out	0x04, r24	; 4
	DDRB |= (1 << WR);
  e8:	84 b1       	in	r24, 0x04	; 4
  ea:	80 61       	ori	r24, 0x10	; 16
  ec:	84 b9       	out	0x04, r24	; 4
	DDRE |= (1 << RD);
  ee:	8d b1       	in	r24, 0x0d	; 13
  f0:	80 64       	ori	r24, 0x40	; 64
  f2:	8d b9       	out	0x0d, r24	; 13
	DDRE |= (1 << DC);
  f4:	8d b1       	in	r24, 0x0d	; 13
  f6:	80 68       	ori	r24, 0x80	; 128
  f8:	8d b9       	out	0x0d, r24	; 13
	// All are set to High (disabled). DC doesn't matter.
	PORTB |= (1 << CS);
  fa:	85 b1       	in	r24, 0x05	; 5
  fc:	80 64       	ori	r24, 0x40	; 64
  fe:	85 b9       	out	0x05, r24	; 5
	//PORTB |= (1 << BL_PWM);
	PORTB |= (1 << WR);
 100:	85 b1       	in	r24, 0x05	; 5
 102:	80 61       	ori	r24, 0x10	; 16
 104:	85 b9       	out	0x05, r24	; 5
	PORTE |= (1 << RD);
 106:	8e b1       	in	r24, 0x0e	; 14
 108:	80 64       	ori	r24, 0x40	; 64
 10a:	8e b9       	out	0x0e, r24	; 14
	PORTE |= (1 << DC);
 10c:	8e b1       	in	r24, 0x0e	; 14
 10e:	80 68       	ori	r24, 0x80	; 128
 110:	8e b9       	out	0x0e, r24	; 14
	// Set IO to output
	DDRA = 0xFF; // D0 - D7
 112:	8f ef       	ldi	r24, 0xFF	; 255
 114:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF; // D8 - D15
 116:	87 b9       	out	0x07, r24	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 118:	2f ef       	ldi	r18, 0xFF	; 255
 11a:	8f e3       	ldi	r24, 0x3F	; 63
 11c:	92 e0       	ldi	r25, 0x02	; 2
 11e:	21 50       	subi	r18, 0x01	; 1
 120:	80 40       	sbci	r24, 0x00	; 0
 122:	90 40       	sbci	r25, 0x00	; 0
 124:	e1 f7       	brne	.-8      	; 0x11e <initHY32D+0x42>
 126:	00 c0       	rjmp	.+0      	; 0x128 <initHY32D+0x4c>
 128:	00 00       	nop
	
	_delay_ms(100);
	
	RST_HIGH;
 12a:	85 b1       	in	r24, 0x05	; 5
 12c:	81 60       	ori	r24, 0x01	; 1
 12e:	85 b9       	out	0x05, r24	; 5
 130:	8f ef       	ldi	r24, 0xFF	; 255
 132:	93 e2       	ldi	r25, 0x23	; 35
 134:	01 97       	sbiw	r24, 0x01	; 1
 136:	f1 f7       	brne	.-4      	; 0x134 <initHY32D+0x58>
 138:	00 c0       	rjmp	.+0      	; 0x13a <initHY32D+0x5e>
 13a:	00 00       	nop
	_delay_ms(5);
	RST_LOW;
 13c:	85 b1       	in	r24, 0x05	; 5
 13e:	8e 7f       	andi	r24, 0xFE	; 254
 140:	85 b9       	out	0x05, r24	; 5
 142:	8f ef       	ldi	r24, 0xFF	; 255
 144:	9b e6       	ldi	r25, 0x6B	; 107
 146:	01 97       	sbiw	r24, 0x01	; 1
 148:	f1 f7       	brne	.-4      	; 0x146 <initHY32D+0x6a>
 14a:	00 c0       	rjmp	.+0      	; 0x14c <initHY32D+0x70>
 14c:	00 00       	nop
	_delay_ms(15);
	RST_HIGH;
 14e:	85 b1       	in	r24, 0x05	; 5
 150:	81 60       	ori	r24, 0x01	; 1
 152:	85 b9       	out	0x05, r24	; 5
 154:	8f ef       	ldi	r24, 0xFF	; 255
 156:	9b e6       	ldi	r25, 0x6B	; 107
 158:	01 97       	sbiw	r24, 0x01	; 1
 15a:	f1 f7       	brne	.-4      	; 0x158 <initHY32D+0x7c>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <initHY32D+0x82>
 15e:	00 00       	nop
	_delay_ms(15);
	
	// Power supply setting (See page 71 of SSD1289 datasheet):
	// Set R07h at 0021h
	writeToRegister(0x07, 0x21, 0x00);
 160:	40 e0       	ldi	r20, 0x00	; 0
 162:	61 e2       	ldi	r22, 0x21	; 33
 164:	87 e0       	ldi	r24, 0x07	; 7
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// Set R00h at 0001h (turn on oscillator)
	writeToRegister(0x00, 0x01, 0x00);
 16c:	40 e0       	ldi	r20, 0x00	; 0
 16e:	61 e0       	ldi	r22, 0x01	; 1
 170:	80 e0       	ldi	r24, 0x00	; 0
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// Set R07h at 0023h
	writeToRegister(0x07, 0x23, 0x00);
 178:	40 e0       	ldi	r20, 0x00	; 0
 17a:	63 e2       	ldi	r22, 0x23	; 35
 17c:	87 e0       	ldi	r24, 0x07	; 7
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// Set R10h at 0000h Exit sleep mode
	writeToRegister(0x10, 0x00, 0x00);
 184:	40 e0       	ldi	r20, 0x00	; 0
 186:	60 e0       	ldi	r22, 0x00	; 0
 188:	80 e1       	ldi	r24, 0x10	; 16
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
 190:	9f ef       	ldi	r25, 0xFF	; 255
 192:	2f e1       	ldi	r18, 0x1F	; 31
 194:	81 e0       	ldi	r24, 0x01	; 1
 196:	91 50       	subi	r25, 0x01	; 1
 198:	20 40       	sbci	r18, 0x00	; 0
 19a:	80 40       	sbci	r24, 0x00	; 0
 19c:	e1 f7       	brne	.-8      	; 0x196 <initHY32D+0xba>
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <initHY32D+0xc4>
 1a0:	00 00       	nop
	// wait 30ms
	_delay_ms(50);
	// Set R07h at 0033h. Which means grayscale level output. See page 36.
	writeToRegister(0x07, 0x33, 0x00);
 1a2:	40 e0       	ldi	r20, 0x00	; 0
 1a4:	63 e3       	ldi	r22, 0x33	; 51
 1a6:	87 e0       	ldi	r24, 0x07	; 7
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// Entry mode setting
	writeToRegister(0x11, 0x30, 0x68);
 1ae:	48 e6       	ldi	r20, 0x68	; 104
 1b0:	60 e3       	ldi	r22, 0x30	; 48
 1b2:	81 e1       	ldi	r24, 0x11	; 17
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// LCD driver AC setting
	writeToRegister(0x02, 0x00, 0x00);
 1ba:	40 e0       	ldi	r20, 0x00	; 0
 1bc:	60 e0       	ldi	r22, 0x00	; 0
 1be:	82 e0       	ldi	r24, 0x02	; 2
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
	// Ram data write
	for(int it = 0; it < 62000; it++){
		writeToRegister(0x22, 0x8E, 0x45);
 1c6:	45 e4       	ldi	r20, 0x45	; 69
 1c8:	6e e8       	ldi	r22, 0x8E	; 142
 1ca:	82 e2       	ldi	r24, 0x22	; 34
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	0e 94 5b 00 	call	0xb6	; 0xb6 <writeToRegister>
		transmitUART(S);
 1d2:	83 e5       	ldi	r24, 0x53	; 83
 1d4:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
 1d8:	f6 cf       	rjmp	.-20     	; 0x1c6 <initHY32D+0xea>

000001da <main>:
}

int main(void)
{	
	// Startup sequence
    initUART(); // initialize the UART
 1da:	0e 94 3c 01 	call	0x278	; 0x278 <initUART>
	initHY32D(); // initialize HY32D screen
 1de:	0e 94 6e 00 	call	0xdc	; 0xdc <initHY32D>
	sei(); //Enable global interrupt
 1e2:	78 94       	sei
	startupMessage();
 1e4:	0e 94 8c 01 	call	0x318	; 0x318 <startupMessage>
 1e8:	ff cf       	rjmp	.-2      	; 0x1e8 <main+0xe>

000001ea <__vector_13>:
		Få kontakt med flashminnet
		Tegn fra flashminnet til skjermen*/
    }
}

ISR(USART0_RX_vect){
 1ea:	1f 92       	push	r1
 1ec:	0f 92       	push	r0
 1ee:	0f b6       	in	r0, 0x3f	; 63
 1f0:	0f 92       	push	r0
 1f2:	11 24       	eor	r1, r1
 1f4:	2f 93       	push	r18
 1f6:	3f 93       	push	r19
 1f8:	4f 93       	push	r20
 1fa:	5f 93       	push	r21
 1fc:	6f 93       	push	r22
 1fe:	7f 93       	push	r23
 200:	8f 93       	push	r24
 202:	9f 93       	push	r25
 204:	af 93       	push	r26
 206:	bf 93       	push	r27
 208:	cf 93       	push	r28
 20a:	ef 93       	push	r30
 20c:	ff 93       	push	r31
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	unsigned char receivedByte = UARTBuffer; // local temporary variable for received byte
 20e:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
	if (receivedByte){
 212:	cc 23       	and	r28, r28
 214:	61 f0       	breq	.+24     	; 0x22e <__EEPROM_REGION_LENGTH__+0x2e>
		if (receivedByte == 45) { // that's the '-' sign.
 216:	cd 32       	cpi	r28, 0x2D	; 45
 218:	31 f4       	brne	.+12     	; 0x226 <__EEPROM_REGION_LENGTH__+0x26>
			remoteEcho = ~remoteEcho;
 21a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 21e:	80 95       	com	r24
 220:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 224:	04 c0       	rjmp	.+8      	; 0x22e <__EEPROM_REGION_LENGTH__+0x2e>
		}else if(receivedByte == S){
 226:	c3 35       	cpi	r28, 0x53	; 83
 228:	11 f4       	brne	.+4      	; 0x22e <__EEPROM_REGION_LENGTH__+0x2e>
			systemCheck();
 22a:	0e 94 5e 01 	call	0x2bc	; 0x2bc <systemCheck>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
 22e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 232:	88 23       	and	r24, r24
 234:	79 f0       	breq	.+30     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
 236:	c0 32       	cpi	r28, 0x20	; 32
 238:	40 f4       	brcc	.+16     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 23a:	c7 30       	cpi	r28, 0x07	; 7
 23c:	31 f0       	breq	.+12     	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 23e:	cd 30       	cpi	r28, 0x0D	; 13
 240:	21 f0       	breq	.+8      	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 242:	ca 30       	cpi	r28, 0x0A	; 10
 244:	11 f0       	breq	.+4      	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 246:	c8 30       	cpi	r28, 0x08	; 8
 248:	29 f4       	brne	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
 24a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 24e:	85 fd       	sbrc	r24, 5
			UARTBuffer = receivedByte;
 250:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
 254:	ff 91       	pop	r31
 256:	ef 91       	pop	r30
 258:	cf 91       	pop	r28
 25a:	bf 91       	pop	r27
 25c:	af 91       	pop	r26
 25e:	9f 91       	pop	r25
 260:	8f 91       	pop	r24
 262:	7f 91       	pop	r23
 264:	6f 91       	pop	r22
 266:	5f 91       	pop	r21
 268:	4f 91       	pop	r20
 26a:	3f 91       	pop	r19
 26c:	2f 91       	pop	r18
 26e:	0f 90       	pop	r0
 270:	0f be       	out	0x3f, r0	; 63
 272:	0f 90       	pop	r0
 274:	1f 90       	pop	r1
 276:	18 95       	reti

00000278 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 278:	8f e2       	ldi	r24, 0x2F	; 47
 27a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 27e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 282:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 286:	88 e9       	ldi	r24, 0x98	; 152
 288:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 28c:	86 e0       	ldi	r24, 0x06	; 6
 28e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 292:	08 95       	ret

00000294 <transmitUART>:
}

int transmitUART (char data){
	short timeoutLimit = 1000; // after 1000 tries, just skip it and try next char. This is about 136 microseconds of time at 7.37 Mhz
	short timeout = 0;
 294:	20 e0       	ldi	r18, 0x00	; 0
 296:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
 298:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 29c:	95 ff       	sbrs	r25, 5
 29e:	05 c0       	rjmp	.+10     	; 0x2aa <transmitUART+0x16>
			UARTBuffer = data;
 2a0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
 2a4:	81 e0       	ldi	r24, 0x01	; 1
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	08 95       	ret
			}else{
			timeout++;
 2aa:	2f 5f       	subi	r18, 0xFF	; 255
 2ac:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
 2ae:	29 3e       	cpi	r18, 0xE9	; 233
 2b0:	93 e0       	ldi	r25, 0x03	; 3
 2b2:	39 07       	cpc	r19, r25
 2b4:	8c f3       	brlt	.-30     	; 0x298 <transmitUART+0x4>
				return 0;
 2b6:	80 e0       	ldi	r24, 0x00	; 0
 2b8:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
 2ba:	08 95       	ret

000002bc <systemCheck>:
#include "ASCII.h"
#include "UART.h"

// Type S for system check:
void systemCheck(void){
	transmitUART(CR);
 2bc:	8d e0       	ldi	r24, 0x0D	; 13
 2be:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(S);
 2c2:	83 e5       	ldi	r24, 0x53	; 83
 2c4:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(y);
 2c8:	89 e7       	ldi	r24, 0x79	; 121
 2ca:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(s);
 2ce:	83 e7       	ldi	r24, 0x73	; 115
 2d0:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(t);
 2d4:	84 e7       	ldi	r24, 0x74	; 116
 2d6:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(e);
 2da:	85 e6       	ldi	r24, 0x65	; 101
 2dc:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(m);
 2e0:	8d e6       	ldi	r24, 0x6D	; 109
 2e2:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(_space);
 2e6:	80 e2       	ldi	r24, 0x20	; 32
 2e8:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(c);
 2ec:	83 e6       	ldi	r24, 0x63	; 99
 2ee:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(h);
 2f2:	88 e6       	ldi	r24, 0x68	; 104
 2f4:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(e);
 2f8:	85 e6       	ldi	r24, 0x65	; 101
 2fa:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(c);
 2fe:	83 e6       	ldi	r24, 0x63	; 99
 300:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(k);
 304:	8b e6       	ldi	r24, 0x6B	; 107
 306:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(_colon);
 30a:	8a e3       	ldi	r24, 0x3A	; 58
 30c:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(CR);
 310:	8d e0       	ldi	r24, 0x0D	; 13
 312:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
 316:	08 95       	ret

00000318 <startupMessage>:
	// Check and print results of various components on the blitter board:
}

void startupMessage(void){
	transmitUART(CR);
 318:	8d e0       	ldi	r24, 0x0D	; 13
 31a:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(B);
 31e:	82 e4       	ldi	r24, 0x42	; 66
 320:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(l);
 324:	8c e6       	ldi	r24, 0x6C	; 108
 326:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(i);
 32a:	89 e6       	ldi	r24, 0x69	; 105
 32c:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(t);
 330:	84 e7       	ldi	r24, 0x74	; 116
 332:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(t);
 336:	84 e7       	ldi	r24, 0x74	; 116
 338:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(e);
 33c:	85 e6       	ldi	r24, 0x65	; 101
 33e:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(r);
 342:	82 e7       	ldi	r24, 0x72	; 114
 344:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(_space);
 348:	80 e2       	ldi	r24, 0x20	; 32
 34a:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(r);
 34e:	82 e7       	ldi	r24, 0x72	; 114
 350:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(e);
 354:	85 e6       	ldi	r24, 0x65	; 101
 356:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(a);
 35a:	81 e6       	ldi	r24, 0x61	; 97
 35c:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(d);
 360:	84 e6       	ldi	r24, 0x64	; 100
 362:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(y);
 366:	89 e7       	ldi	r24, 0x79	; 121
 368:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
	transmitUART(CR);
 36c:	8d e0       	ldi	r24, 0x0D	; 13
 36e:	0e 94 4a 01 	call	0x294	; 0x294 <transmitUART>
 372:	08 95       	ret

00000374 <_exit>:
 374:	f8 94       	cli

00000376 <__stop_program>:
 376:	ff cf       	rjmp	.-2      	; 0x376 <__stop_program>
