
Blitter_Controller.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000001ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000015a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800100  00800100  000001ce  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000001ce  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000200  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000038  00000000  00000000  00000240  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000009e7  00000000  00000000  00000278  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008e5  00000000  00000000  00000c5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000348  00000000  00000000  00001544  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000068  00000000  00000000  0000188c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004c9  00000000  00000000  000018f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000a5  00000000  00000000  00001dbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000028  00000000  00000000  00001e62  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   8:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
   c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  10:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  14:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  18:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  1c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  20:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  24:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  28:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  2c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  30:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  34:	0c 94 56 00 	jmp	0xac	; 0xac <__vector_13>
  38:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  3c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  40:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  44:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  48:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  4c:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  50:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  54:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>
  58:	0c 94 40 00 	jmp	0x80	; 0x80 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	b1 e0       	ldi	r27, 0x01	; 1
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
  72:	a2 30       	cpi	r26, 0x02	; 2
  74:	b2 07       	cpc	r27, r18
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>
  78:	0e 94 92 00 	call	0x124	; 0x124 <main>
  7c:	0c 94 ab 00 	jmp	0x156	; 0x156 <_exit>

00000080 <__bad_interrupt>:
  80:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000084 <transmitUART>:
    }
}

int transmitUART (char data){
	short timeoutLimit = 1000;
	short timeout = 0;
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	30 e0       	ldi	r19, 0x00	; 0
	while(1){
		if(UCSR0A & (1 << UDRE0)){
  88:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
  8c:	95 ff       	sbrs	r25, 5
  8e:	05 c0       	rjmp	.+10     	; 0x9a <transmitUART+0x16>
			UARTBuffer = data;
  90:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
			return 1;
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	08 95       	ret
		}else{
			timeout++;
  9a:	2f 5f       	subi	r18, 0xFF	; 255
  9c:	3f 4f       	sbci	r19, 0xFF	; 255
			if(timeout > timeoutLimit){
  9e:	29 3e       	cpi	r18, 0xE9	; 233
  a0:	93 e0       	ldi	r25, 0x03	; 3
  a2:	39 07       	cpc	r19, r25
  a4:	8c f3       	brlt	.-30     	; 0x88 <transmitUART+0x4>
				return 0;
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
	}
}
  aa:	08 95       	ret

000000ac <__vector_13>:

ISR(USART0_RX_vect){
  ac:	1f 92       	push	r1
  ae:	0f 92       	push	r0
  b0:	0f b6       	in	r0, 0x3f	; 63
  b2:	0f 92       	push	r0
  b4:	11 24       	eor	r1, r1
  b6:	8f 93       	push	r24
  b8:	9f 93       	push	r25
	// Read received data to variable. This also clears the interrupt flag. If data isn't read a new interrupt will immediately happen. See 19.7.3 datasheet.
	// When the receive complete interrupt enable (RXCIEn) in UCSRnB is set, the USART receive complete interrupt will be executed as long as the RXCn flag is set.
	receivedByte = UARTBuffer; // local temporary variable for received byte
  ba:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
  be:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <receivedByte>
	if (receivedByte){
  c2:	88 23       	and	r24, r24
  c4:	39 f0       	breq	.+14     	; 0xd4 <__vector_13+0x28>
		//UARTBuffer = receivedByte;
		
		if (receivedByte == 45) { // that's the '-' sign.
  c6:	8d 32       	cpi	r24, 0x2D	; 45
  c8:	29 f4       	brne	.+10     	; 0xd4 <__vector_13+0x28>
			remoteEcho = ~remoteEcho;
  ca:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  ce:	90 95       	com	r25
  d0:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__DATA_REGION_ORIGIN__>
		}
	// If echo is on, and the ASCII character is higher than 31, or Bell, Carriage Return, Line Feed or backspace, then echo the character. Other are filtered as to not get strange behavior from Putty.
	}
	if (remoteEcho && ((receivedByte > 31) || (receivedByte == Bell) || (receivedByte == CR) || (receivedByte == LF) || (receivedByte == backspace))){
  d4:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  d8:	99 23       	and	r25, r25
  da:	79 f0       	breq	.+30     	; 0xfa <__vector_13+0x4e>
  dc:	80 32       	cpi	r24, 0x20	; 32
  de:	40 f4       	brcc	.+16     	; 0xf0 <__vector_13+0x44>
  e0:	87 30       	cpi	r24, 0x07	; 7
  e2:	31 f0       	breq	.+12     	; 0xf0 <__vector_13+0x44>
  e4:	8d 30       	cpi	r24, 0x0D	; 13
  e6:	21 f0       	breq	.+8      	; 0xf0 <__vector_13+0x44>
  e8:	8a 30       	cpi	r24, 0x0A	; 10
  ea:	11 f0       	breq	.+4      	; 0xf0 <__vector_13+0x44>
  ec:	88 30       	cpi	r24, 0x08	; 8
  ee:	29 f4       	brne	.+10     	; 0xfa <__vector_13+0x4e>
		if(UCSR0A & (1 << UDRE0)){ // check if byte is 1
  f0:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
  f4:	95 fd       	sbrc	r25, 5
			UARTBuffer = receivedByte;
  f6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
		}
	}
}
  fa:	9f 91       	pop	r25
  fc:	8f 91       	pop	r24
  fe:	0f 90       	pop	r0
 100:	0f be       	out	0x3f, r0	; 63
 102:	0f 90       	pop	r0
 104:	1f 90       	pop	r1
 106:	18 95       	reti

00000108 <initUART>:

void initUART (void){
	// calculating the baud rate clock division registers at compile time and setting the baud rate registers properly at run time.
	const uint8_t baudRateReg_low = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) & 0xFF);
	const uint8_t baudRateReg_high = (uint8_t) ((( F_CPU / ( 16 * uart_bps )) - 1 ) >> 8);
	UBRR0L = baudRateReg_low;
 108:	8e e2       	ldi	r24, 0x2E	; 46
 10a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
	UBRR0H = baudRateReg_high;
 10e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fc0c5>
	
	// Alternative way of calculating the baud rate register, with casting
	//	const uint8_t UBRR_reg_val = (uint8_t) ((sysClk / 16.0 * (float) uart_bps) - 1.0);

	// Setting up the USART control registers. All bits are included for sake of overview. Compiler will optimize.
	UCSR0A = 0x00 | (0 << RXC0) | (0 << TXC0) | (0 << UDRE0) | (0 << FE0) | (0 << DOR0) | (0 << UPE0) | (0 << U2X0) | (0 << MPCM0);  // NOT running 2x mode
 112:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
	UCSR0B = 0x00 | (1 << RXCIE0) | (0 << TXCIE0) | (0 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);  // Enable Rx and Tx setting the ports mux correctly
 116:	88 e9       	ldi	r24, 0x98	; 152
 118:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
	UCSR0C = 0x00 | (0 << UMSEL0) | (0 << UPM01) | (0 << UPM00) | (0 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00); // Selecting 8-bit character for the USART
 11c:	86 e0       	ldi	r24, 0x06	; 6
 11e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
 122:	08 95       	ret

00000124 <main>:
char receivedByte;
uint8_t remoteEcho = 0;

int main(void)
{	
    initUART(); // initialize the UART
 124:	0e 94 84 00 	call	0x108	; 0x108 <initUART>
	sei(); //Enable global interrupt
 128:	78 94       	sei
			Brukt USART til å kjøre kommandoer
			
			Få kontakt med flashminnet
			Tegn fra flashminnet til skjermen
	 */
		transmitUART(89);
 12a:	89 e5       	ldi	r24, 0x59	; 89
 12c:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
		transmitUART(69);
 130:	85 e4       	ldi	r24, 0x45	; 69
 132:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
		transmitUART(83);
 136:	83 e5       	ldi	r24, 0x53	; 83
 138:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
		transmitUART(CR);
 13c:	8d e0       	ldi	r24, 0x0D	; 13
 13e:	0e 94 42 00 	call	0x84	; 0x84 <transmitUART>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 142:	2f ec       	ldi	r18, 0xCF	; 207
 144:	8d e7       	ldi	r24, 0x7D	; 125
 146:	96 e1       	ldi	r25, 0x16	; 22
 148:	21 50       	subi	r18, 0x01	; 1
 14a:	80 40       	sbci	r24, 0x00	; 0
 14c:	90 40       	sbci	r25, 0x00	; 0
 14e:	e1 f7       	brne	.-8      	; 0x148 <main+0x24>
 150:	00 c0       	rjmp	.+0      	; 0x152 <main+0x2e>
 152:	00 00       	nop
 154:	ea cf       	rjmp	.-44     	; 0x12a <main+0x6>

00000156 <_exit>:
 156:	f8 94       	cli

00000158 <__stop_program>:
 158:	ff cf       	rjmp	.-2      	; 0x158 <__stop_program>
